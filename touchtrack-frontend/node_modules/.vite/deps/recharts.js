import { __commonJS, __export, __toESM } from "./chunk-DbKvDyjX.js";
import { require_react } from "./react-Dzmm40ca.js";
import { require_react_dom } from "./react-dom-Bu4ag0_3.js";

//#region node_modules/clsx/dist/clsx.mjs
var import_react = /* @__PURE__ */ __toESM(require_react());
function r(e) {
	var t, f, n = "";
	if ("string" == typeof e || "number" == typeof e) n += e;
	else if ("object" == typeof e) if (Array.isArray(e)) {
		var o = e.length;
		for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
	} else for (f in e) e[f] && (n && (n += " "), n += f);
	return n;
}
function clsx() {
	for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
	return n;
}

//#endregion
//#region node_modules/recharts/es6/util/excludeEventProps.js
var EventKeys = [
	"dangerouslySetInnerHTML",
	"onCopy",
	"onCopyCapture",
	"onCut",
	"onCutCapture",
	"onPaste",
	"onPasteCapture",
	"onCompositionEnd",
	"onCompositionEndCapture",
	"onCompositionStart",
	"onCompositionStartCapture",
	"onCompositionUpdate",
	"onCompositionUpdateCapture",
	"onFocus",
	"onFocusCapture",
	"onBlur",
	"onBlurCapture",
	"onChange",
	"onChangeCapture",
	"onBeforeInput",
	"onBeforeInputCapture",
	"onInput",
	"onInputCapture",
	"onReset",
	"onResetCapture",
	"onSubmit",
	"onSubmitCapture",
	"onInvalid",
	"onInvalidCapture",
	"onLoad",
	"onLoadCapture",
	"onError",
	"onErrorCapture",
	"onKeyDown",
	"onKeyDownCapture",
	"onKeyPress",
	"onKeyPressCapture",
	"onKeyUp",
	"onKeyUpCapture",
	"onAbort",
	"onAbortCapture",
	"onCanPlay",
	"onCanPlayCapture",
	"onCanPlayThrough",
	"onCanPlayThroughCapture",
	"onDurationChange",
	"onDurationChangeCapture",
	"onEmptied",
	"onEmptiedCapture",
	"onEncrypted",
	"onEncryptedCapture",
	"onEnded",
	"onEndedCapture",
	"onLoadedData",
	"onLoadedDataCapture",
	"onLoadedMetadata",
	"onLoadedMetadataCapture",
	"onLoadStart",
	"onLoadStartCapture",
	"onPause",
	"onPauseCapture",
	"onPlay",
	"onPlayCapture",
	"onPlaying",
	"onPlayingCapture",
	"onProgress",
	"onProgressCapture",
	"onRateChange",
	"onRateChangeCapture",
	"onSeeked",
	"onSeekedCapture",
	"onSeeking",
	"onSeekingCapture",
	"onStalled",
	"onStalledCapture",
	"onSuspend",
	"onSuspendCapture",
	"onTimeUpdate",
	"onTimeUpdateCapture",
	"onVolumeChange",
	"onVolumeChangeCapture",
	"onWaiting",
	"onWaitingCapture",
	"onAuxClick",
	"onAuxClickCapture",
	"onClick",
	"onClickCapture",
	"onContextMenu",
	"onContextMenuCapture",
	"onDoubleClick",
	"onDoubleClickCapture",
	"onDrag",
	"onDragCapture",
	"onDragEnd",
	"onDragEndCapture",
	"onDragEnter",
	"onDragEnterCapture",
	"onDragExit",
	"onDragExitCapture",
	"onDragLeave",
	"onDragLeaveCapture",
	"onDragOver",
	"onDragOverCapture",
	"onDragStart",
	"onDragStartCapture",
	"onDrop",
	"onDropCapture",
	"onMouseDown",
	"onMouseDownCapture",
	"onMouseEnter",
	"onMouseLeave",
	"onMouseMove",
	"onMouseMoveCapture",
	"onMouseOut",
	"onMouseOutCapture",
	"onMouseOver",
	"onMouseOverCapture",
	"onMouseUp",
	"onMouseUpCapture",
	"onSelect",
	"onSelectCapture",
	"onTouchCancel",
	"onTouchCancelCapture",
	"onTouchEnd",
	"onTouchEndCapture",
	"onTouchMove",
	"onTouchMoveCapture",
	"onTouchStart",
	"onTouchStartCapture",
	"onPointerDown",
	"onPointerDownCapture",
	"onPointerMove",
	"onPointerMoveCapture",
	"onPointerUp",
	"onPointerUpCapture",
	"onPointerCancel",
	"onPointerCancelCapture",
	"onPointerEnter",
	"onPointerEnterCapture",
	"onPointerLeave",
	"onPointerLeaveCapture",
	"onPointerOver",
	"onPointerOverCapture",
	"onPointerOut",
	"onPointerOutCapture",
	"onGotPointerCapture",
	"onGotPointerCaptureCapture",
	"onLostPointerCapture",
	"onLostPointerCaptureCapture",
	"onScroll",
	"onScrollCapture",
	"onWheel",
	"onWheelCapture",
	"onAnimationStart",
	"onAnimationStartCapture",
	"onAnimationEnd",
	"onAnimationEndCapture",
	"onAnimationIteration",
	"onAnimationIterationCapture",
	"onTransitionEnd",
	"onTransitionEndCapture"
];
function isEventKey(key) {
	if (typeof key !== "string") return false;
	return EventKeys.includes(key);
}

//#endregion
//#region node_modules/recharts/es6/util/svgPropertiesNoEvents.js
var SVGElementPropKeys = [
	"aria-activedescendant",
	"aria-atomic",
	"aria-autocomplete",
	"aria-busy",
	"aria-checked",
	"aria-colcount",
	"aria-colindex",
	"aria-colspan",
	"aria-controls",
	"aria-current",
	"aria-describedby",
	"aria-details",
	"aria-disabled",
	"aria-errormessage",
	"aria-expanded",
	"aria-flowto",
	"aria-haspopup",
	"aria-hidden",
	"aria-invalid",
	"aria-keyshortcuts",
	"aria-label",
	"aria-labelledby",
	"aria-level",
	"aria-live",
	"aria-modal",
	"aria-multiline",
	"aria-multiselectable",
	"aria-orientation",
	"aria-owns",
	"aria-placeholder",
	"aria-posinset",
	"aria-pressed",
	"aria-readonly",
	"aria-relevant",
	"aria-required",
	"aria-roledescription",
	"aria-rowcount",
	"aria-rowindex",
	"aria-rowspan",
	"aria-selected",
	"aria-setsize",
	"aria-sort",
	"aria-valuemax",
	"aria-valuemin",
	"aria-valuenow",
	"aria-valuetext",
	"className",
	"color",
	"height",
	"id",
	"lang",
	"max",
	"media",
	"method",
	"min",
	"name",
	"style",
	"target",
	"width",
	"role",
	"tabIndex",
	"accentHeight",
	"accumulate",
	"additive",
	"alignmentBaseline",
	"allowReorder",
	"alphabetic",
	"amplitude",
	"arabicForm",
	"ascent",
	"attributeName",
	"attributeType",
	"autoReverse",
	"azimuth",
	"baseFrequency",
	"baselineShift",
	"baseProfile",
	"bbox",
	"begin",
	"bias",
	"by",
	"calcMode",
	"capHeight",
	"clip",
	"clipPath",
	"clipPathUnits",
	"clipRule",
	"colorInterpolation",
	"colorInterpolationFilters",
	"colorProfile",
	"colorRendering",
	"contentScriptType",
	"contentStyleType",
	"cursor",
	"cx",
	"cy",
	"d",
	"decelerate",
	"descent",
	"diffuseConstant",
	"direction",
	"display",
	"divisor",
	"dominantBaseline",
	"dur",
	"dx",
	"dy",
	"edgeMode",
	"elevation",
	"enableBackground",
	"end",
	"exponent",
	"externalResourcesRequired",
	"fill",
	"fillOpacity",
	"fillRule",
	"filter",
	"filterRes",
	"filterUnits",
	"floodColor",
	"floodOpacity",
	"focusable",
	"fontFamily",
	"fontSize",
	"fontSizeAdjust",
	"fontStretch",
	"fontStyle",
	"fontVariant",
	"fontWeight",
	"format",
	"from",
	"fx",
	"fy",
	"g1",
	"g2",
	"glyphName",
	"glyphOrientationHorizontal",
	"glyphOrientationVertical",
	"glyphRef",
	"gradientTransform",
	"gradientUnits",
	"hanging",
	"horizAdvX",
	"horizOriginX",
	"href",
	"ideographic",
	"imageRendering",
	"in2",
	"in",
	"intercept",
	"k1",
	"k2",
	"k3",
	"k4",
	"k",
	"kernelMatrix",
	"kernelUnitLength",
	"kerning",
	"keyPoints",
	"keySplines",
	"keyTimes",
	"lengthAdjust",
	"letterSpacing",
	"lightingColor",
	"limitingConeAngle",
	"local",
	"markerEnd",
	"markerHeight",
	"markerMid",
	"markerStart",
	"markerUnits",
	"markerWidth",
	"mask",
	"maskContentUnits",
	"maskUnits",
	"mathematical",
	"mode",
	"numOctaves",
	"offset",
	"opacity",
	"operator",
	"order",
	"orient",
	"orientation",
	"origin",
	"overflow",
	"overlinePosition",
	"overlineThickness",
	"paintOrder",
	"panose1",
	"pathLength",
	"patternContentUnits",
	"patternTransform",
	"patternUnits",
	"pointerEvents",
	"pointsAtX",
	"pointsAtY",
	"pointsAtZ",
	"preserveAlpha",
	"preserveAspectRatio",
	"primitiveUnits",
	"r",
	"radius",
	"refX",
	"refY",
	"renderingIntent",
	"repeatCount",
	"repeatDur",
	"requiredExtensions",
	"requiredFeatures",
	"restart",
	"result",
	"rotate",
	"rx",
	"ry",
	"seed",
	"shapeRendering",
	"slope",
	"spacing",
	"specularConstant",
	"specularExponent",
	"speed",
	"spreadMethod",
	"startOffset",
	"stdDeviation",
	"stemh",
	"stemv",
	"stitchTiles",
	"stopColor",
	"stopOpacity",
	"strikethroughPosition",
	"strikethroughThickness",
	"string",
	"stroke",
	"strokeDasharray",
	"strokeDashoffset",
	"strokeLinecap",
	"strokeLinejoin",
	"strokeMiterlimit",
	"strokeOpacity",
	"strokeWidth",
	"surfaceScale",
	"systemLanguage",
	"tableValues",
	"targetX",
	"targetY",
	"textAnchor",
	"textDecoration",
	"textLength",
	"textRendering",
	"to",
	"transform",
	"u1",
	"u2",
	"underlinePosition",
	"underlineThickness",
	"unicode",
	"unicodeBidi",
	"unicodeRange",
	"unitsPerEm",
	"vAlphabetic",
	"values",
	"vectorEffect",
	"version",
	"vertAdvY",
	"vertOriginX",
	"vertOriginY",
	"vHanging",
	"vIdeographic",
	"viewTarget",
	"visibility",
	"vMathematical",
	"widths",
	"wordSpacing",
	"writingMode",
	"x1",
	"x2",
	"x",
	"xChannelSelector",
	"xHeight",
	"xlinkActuate",
	"xlinkArcrole",
	"xlinkHref",
	"xlinkRole",
	"xlinkShow",
	"xlinkTitle",
	"xlinkType",
	"xmlBase",
	"xmlLang",
	"xmlns",
	"xmlnsXlink",
	"xmlSpace",
	"y1",
	"y2",
	"y",
	"yChannelSelector",
	"z",
	"zoomAndPan",
	"ref",
	"key",
	"angle"
];
function isSvgElementPropKey(key) {
	if (typeof key !== "string") return false;
	return SVGElementPropKeys.includes(key);
}
/**
* Checks if the property is a data attribute.
* @param key The property key.
* @returns True if the key starts with 'data-', false otherwise.
*/
function isDataAttribute(key) {
	return typeof key === "string" && key.startsWith("data-");
}
/**
* Filters an object to only include SVG properties. Removes all event handlers too.
* @param obj - The object to filter
* @returns A new object containing only valid SVG properties, excluding event handlers.
*/
function svgPropertiesNoEvents(obj) {
	var filteredEntries = Object.entries(obj).filter((_ref$1) => {
		var [key] = _ref$1;
		return isSvgElementPropKey(key) || isDataAttribute(key);
	});
	return Object.fromEntries(filteredEntries);
}
/**
* Function to filter SVG properties from various input types.
* The input types can be:
* - A record of string keys to any values, in which case it returns a record of only SVG properties
* - A React element, in which case it returns the props of the element filtered to only SVG properties
* - Anything else, in which case it returns null
*
* This function has a wide-open return type, because it will read and filter the props of an arbitrary React element.
* This can be SVG, HTML, whatnot, with arbitrary values, so we can't type it more specifically.
*
* If you wish to have a type-safe version, use svgPropertiesNoEvents directly with a typed object.
*
* @param input - The input to filter, which can be a record, a React element, or other types.
* @returns A record of SVG properties if the input is a record or React element, otherwise null.
*/
function svgPropertiesNoEventsFromUnknown(input) {
	if (input == null) return null;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(input) && typeof input.props === "object" && input.props !== null) {
		var p = input.props;
		return svgPropertiesNoEvents(p);
	}
	if (typeof input === "object" && !Array.isArray(input)) return svgPropertiesNoEvents(input);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/util/svgPropertiesAndEvents.js
/**
* Filters an object to only include SVG properties, data attributes, and event handlers.
* @param obj - The object to filter.
* @returns A new object containing only valid SVG properties, data attributes, and event handlers.
*/
function svgPropertiesAndEvents(obj) {
	var filteredEntries = Object.entries(obj).filter((_ref$1) => {
		var [key] = _ref$1;
		return isSvgElementPropKey(key) || isDataAttribute(key) || isEventKey(key);
	});
	return Object.fromEntries(filteredEntries);
}
/**
* Function to filter SVG properties from various input types.
* The input types can be:
* - A record of string keys to any values, in which case it returns a record of only SVG properties
* - A React element, in which case it returns the props of the element filtered to only SVG properties
* - Anything else, in which case it returns null
*
* This function has a wide-open return type, because it will read and filter the props of an arbitrary React element.
* This can be SVG, HTML, whatnot, with arbitrary values, so we can't type it more specifically.
*
* If you wish to have a type-safe version, use svgPropertiesNoEvents directly with a typed object.
*
* @param input - The input to filter, which can be a record, a React element, or other types.
* @returns A record of SVG properties if the input is a record or React element, otherwise null.
*/
function svgPropertiesAndEventsFromUnknown(input) {
	if (input == null) return null;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(input)) return svgPropertiesAndEvents(input.props);
	if (typeof input === "object" && !Array.isArray(input)) return svgPropertiesAndEvents(input);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/container/Surface.js
var _excluded$36 = [
	"children",
	"width",
	"height",
	"viewBox",
	"className",
	"style",
	"title",
	"desc"
];
function _extends$48() {
	return _extends$48 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$48.apply(null, arguments);
}
function _objectWithoutProperties$36(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$36(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$36(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var Surface = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { children, width, height, viewBox, className, style, title, desc } = props, others = _objectWithoutProperties$36(props, _excluded$36);
	var svgView = viewBox || {
		width,
		height,
		x: 0,
		y: 0
	};
	var layerClass = clsx("recharts-surface", className);
	return /* @__PURE__ */ import_react.createElement("svg", _extends$48({}, svgPropertiesAndEvents(others), {
		className: layerClass,
		width,
		height,
		style,
		viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height),
		ref
	}), /* @__PURE__ */ import_react.createElement("title", null, title), /* @__PURE__ */ import_react.createElement("desc", null, desc), children);
});

//#endregion
//#region node_modules/recharts/es6/container/Layer.js
var _excluded$35 = ["children", "className"];
function _extends$47() {
	return _extends$47 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$47.apply(null, arguments);
}
function _objectWithoutProperties$35(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$35(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$35(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var Layer = /* @__PURE__ */ import_react.forwardRef((props, ref) => {
	var { children, className } = props, others = _objectWithoutProperties$35(props, _excluded$35);
	var layerClass = clsx("recharts-layer", className);
	return /* @__PURE__ */ import_react.createElement("g", _extends$47({ className: layerClass }, svgPropertiesAndEvents(others), { ref }), children);
});

//#endregion
//#region node_modules/recharts/es6/context/legendPortalContext.js
var import_react_dom$1 = /* @__PURE__ */ __toESM(require_react_dom());
var LegendPortalContext = /* @__PURE__ */ (0, import_react.createContext)(null);
var useLegendPortal = () => (0, import_react.useContext)(LegendPortalContext);

//#endregion
//#region node_modules/d3-shape/src/constant.js
function constant_default$1(x$1) {
	return function constant() {
		return x$1;
	};
}

//#endregion
//#region node_modules/d3-shape/src/math.js
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

//#endregion
//#region node_modules/d3-path/src/path.js
var pi$1 = Math.PI, tau$1 = 2 * pi$1, epsilon = 1e-6, tauEpsilon = tau$1 - epsilon;
function append(strings) {
	this._ += strings[0];
	for (let i = 1, n = strings.length; i < n; ++i) this._ += arguments[i] + strings[i];
}
function appendRound(digits) {
	let d = Math.floor(digits);
	if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
	if (d > 15) return append;
	const k$1 = 10 ** d;
	return function(strings) {
		this._ += strings[0];
		for (let i = 1, n = strings.length; i < n; ++i) this._ += Math.round(arguments[i] * k$1) / k$1 + strings[i];
	};
}
var Path = class {
	constructor(digits) {
		this._x0 = this._y0 = this._x1 = this._y1 = null;
		this._ = "";
		this._append = digits == null ? append : appendRound(digits);
	}
	moveTo(x$1, y$1) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}`;
	}
	closePath() {
		if (this._x1 !== null) {
			this._x1 = this._x0, this._y1 = this._y0;
			this._append`Z`;
		}
	}
	lineTo(x$1, y$1) {
		this._append`L${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	quadraticCurveTo(x1, y1, x$1, y$1) {
		this._append`Q${+x1},${+y1},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	bezierCurveTo(x1, y1, x2, y2, x$1, y$1) {
		this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x$1},${this._y1 = +y$1}`;
	}
	arcTo(x1, y1, x2, y2, r$1) {
		x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r$1 = +r$1;
		if (r$1 < 0) throw new Error(`negative radius: ${r$1}`);
		let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
		if (this._x1 === null) this._append`M${this._x1 = x1},${this._y1 = y1}`;
		else if (!(l01_2 > epsilon));
		else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r$1) this._append`L${this._x1 = x1},${this._y1 = y1}`;
		else {
			let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r$1 * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
			if (Math.abs(t01 - 1) > epsilon) this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
			this._append`A${r$1},${r$1},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
		}
	}
	arc(x$1, y$1, r$1, a0, a1, ccw) {
		x$1 = +x$1, y$1 = +y$1, r$1 = +r$1, ccw = !!ccw;
		if (r$1 < 0) throw new Error(`negative radius: ${r$1}`);
		let dx = r$1 * Math.cos(a0), dy = r$1 * Math.sin(a0), x0 = x$1 + dx, y0 = y$1 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
		if (this._x1 === null) this._append`M${x0},${y0}`;
		else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) this._append`L${x0},${y0}`;
		if (!r$1) return;
		if (da < 0) da = da % tau$1 + tau$1;
		if (da > tauEpsilon) this._append`A${r$1},${r$1},0,1,${cw},${x$1 - dx},${y$1 - dy}A${r$1},${r$1},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
		else if (da > epsilon) this._append`A${r$1},${r$1},0,${+(da >= pi$1)},${cw},${this._x1 = x$1 + r$1 * Math.cos(a1)},${this._y1 = y$1 + r$1 * Math.sin(a1)}`;
	}
	rect(x$1, y$1, w, h) {
		this._append`M${this._x0 = this._x1 = +x$1},${this._y0 = this._y1 = +y$1}h${w = +w}v${+h}h${-w}Z`;
	}
	toString() {
		return this._;
	}
};
function path() {
	return new Path();
}
path.prototype = Path.prototype;

//#endregion
//#region node_modules/d3-shape/src/path.js
function withPath(shape) {
	let digits = 3;
	shape.digits = function(_) {
		if (!arguments.length) return digits;
		if (_ == null) digits = null;
		else {
			const d = Math.floor(_);
			if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
			digits = d;
		}
		return shape;
	};
	return () => new Path(digits);
}

//#endregion
//#region node_modules/d3-shape/src/array.js
var slice = Array.prototype.slice;
function array_default(x$1) {
	return typeof x$1 === "object" && "length" in x$1 ? x$1 : Array.from(x$1);
}

//#endregion
//#region node_modules/d3-shape/src/curve/linear.js
function Linear(context) {
	this._context = context;
}
Linear.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				this._context.lineTo(x$1, y$1);
				break;
		}
	}
};
function linear_default(context) {
	return new Linear(context);
}

//#endregion
//#region node_modules/d3-shape/src/point.js
function x(p) {
	return p[0];
}
function y(p) {
	return p[1];
}

//#endregion
//#region node_modules/d3-shape/src/line.js
function line_default(x$1, y$1) {
	var defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(line);
	x$1 = typeof x$1 === "function" ? x$1 : x$1 === void 0 ? x : constant_default$1(x$1);
	y$1 = typeof y$1 === "function" ? y$1 : y$1 === void 0 ? y : constant_default$1(y$1);
	function line(data) {
		var i, n = (data = array_default(data)).length, d, defined0 = false, buffer;
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined$1(d = data[i], i, data)) === defined0) if (defined0 = !defined0) output.lineStart();
			else output.lineEnd();
			if (defined0) output.point(+x$1(d, i, data), +y$1(d, i, data));
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	line.x = function(_) {
		return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : x$1;
	};
	line.y = function(_) {
		return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant_default$1(+_), line) : y$1;
	};
	line.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), line) : defined$1;
	};
	line.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	};
	line.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	};
	return line;
}

//#endregion
//#region node_modules/d3-shape/src/area.js
function area_default(x0, y0, y1) {
	var x1 = null, defined$1 = constant_default$1(true), context = null, curve = linear_default, output = null, path$1 = withPath(area);
	x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant_default$1(+x0);
	y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant_default$1(0) : constant_default$1(+y0);
	y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant_default$1(+y1);
	function area(data) {
		var i, j, k$1, n = (data = array_default(data)).length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
		if (context == null) output = curve(buffer = path$1());
		for (i = 0; i <= n; ++i) {
			if (!(i < n && defined$1(d = data[i], i, data)) === defined0) if (defined0 = !defined0) {
				j = i;
				output.areaStart();
				output.lineStart();
			} else {
				output.lineEnd();
				output.lineStart();
				for (k$1 = i - 1; k$1 >= j; --k$1) output.point(x0z[k$1], y0z[k$1]);
				output.lineEnd();
				output.areaEnd();
			}
			if (defined0) {
				x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
				output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
			}
		}
		if (buffer) return output = null, buffer + "" || null;
	}
	function arealine() {
		return line_default().defined(defined$1).curve(curve).context(context);
	}
	area.x = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), x1 = null, area) : x0;
	};
	area.x0 = function(_) {
		return arguments.length ? (x0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : x0;
	};
	area.x1 = function(_) {
		return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : x1;
	};
	area.y = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), y1 = null, area) : y0;
	};
	area.y0 = function(_) {
		return arguments.length ? (y0 = typeof _ === "function" ? _ : constant_default$1(+_), area) : y0;
	};
	area.y1 = function(_) {
		return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant_default$1(+_), area) : y1;
	};
	area.lineX0 = area.lineY0 = function() {
		return arealine().x(x0).y(y0);
	};
	area.lineY1 = function() {
		return arealine().x(x0).y(y1);
	};
	area.lineX1 = function() {
		return arealine().x(x1).y(y0);
	};
	area.defined = function(_) {
		return arguments.length ? (defined$1 = typeof _ === "function" ? _ : constant_default$1(!!_), area) : defined$1;
	};
	area.curve = function(_) {
		return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	};
	area.context = function(_) {
		return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	};
	return area;
}

//#endregion
//#region node_modules/d3-shape/src/curve/bump.js
var Bump = class {
	constructor(context, x$1) {
		this._context = context;
		this._x = x$1;
	}
	areaStart() {
		this._line = 0;
	}
	areaEnd() {
		this._line = NaN;
	}
	lineStart() {
		this._point = 0;
	}
	lineEnd() {
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	}
	point(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				if (this._line) this._context.lineTo(x$1, y$1);
				else this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x$1) / 2, this._y0, this._x0, y$1, x$1, y$1);
				else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y$1) / 2, x$1, this._y0, x$1, y$1);
				break;
		}
		this._x0 = x$1, this._y0 = y$1;
	}
};
function bumpX(context) {
	return new Bump(context, true);
}
function bumpY(context) {
	return new Bump(context, false);
}

//#endregion
//#region node_modules/d3-shape/src/symbol/circle.js
var circle_default = { draw(context, size) {
	const r$1 = sqrt$1(size / pi);
	context.moveTo(r$1, 0);
	context.arc(0, 0, r$1, 0, tau);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/cross.js
var cross_default = { draw(context, size) {
	const r$1 = sqrt$1(size / 5) / 2;
	context.moveTo(-3 * r$1, -r$1);
	context.lineTo(-r$1, -r$1);
	context.lineTo(-r$1, -3 * r$1);
	context.lineTo(r$1, -3 * r$1);
	context.lineTo(r$1, -r$1);
	context.lineTo(3 * r$1, -r$1);
	context.lineTo(3 * r$1, r$1);
	context.lineTo(r$1, r$1);
	context.lineTo(r$1, 3 * r$1);
	context.lineTo(-r$1, 3 * r$1);
	context.lineTo(-r$1, r$1);
	context.lineTo(-3 * r$1, r$1);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/diamond.js
var tan30 = sqrt$1(1 / 3);
var tan30_2 = tan30 * 2;
var diamond_default = { draw(context, size) {
	const y$1 = sqrt$1(size / tan30_2);
	const x$1 = y$1 * tan30;
	context.moveTo(0, -y$1);
	context.lineTo(x$1, 0);
	context.lineTo(0, y$1);
	context.lineTo(-x$1, 0);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/square.js
var square_default = { draw(context, size) {
	const w = sqrt$1(size);
	const x$1 = -w / 2;
	context.rect(x$1, x$1, w, w);
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/star.js
var ka = .8908130915292852;
var kr = sin(pi / 10) / sin(7 * pi / 10);
var kx = sin(tau / 10) * kr;
var ky = -cos(tau / 10) * kr;
var star_default = { draw(context, size) {
	const r$1 = sqrt$1(size * ka);
	const x$1 = kx * r$1;
	const y$1 = ky * r$1;
	context.moveTo(0, -r$1);
	context.lineTo(x$1, y$1);
	for (let i = 1; i < 5; ++i) {
		const a$1 = tau * i / 5;
		const c$1 = cos(a$1);
		const s$1 = sin(a$1);
		context.lineTo(s$1 * r$1, -c$1 * r$1);
		context.lineTo(c$1 * x$1 - s$1 * y$1, s$1 * x$1 + c$1 * y$1);
	}
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/triangle.js
var sqrt3 = sqrt$1(3);
var triangle_default = { draw(context, size) {
	const y$1 = -sqrt$1(size / (sqrt3 * 3));
	context.moveTo(0, y$1 * 2);
	context.lineTo(-sqrt3 * y$1, -y$1);
	context.lineTo(sqrt3 * y$1, -y$1);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol/wye.js
var c = -.5;
var s = sqrt$1(3) / 2;
var k = 1 / sqrt$1(12);
var a = (k / 2 + 1) * 3;
var wye_default = { draw(context, size) {
	const r$1 = sqrt$1(size / a);
	const x0 = r$1 / 2, y0 = r$1 * k;
	const x1 = x0, y1 = r$1 * k + r$1;
	const x2 = -x1, y2 = y1;
	context.moveTo(x0, y0);
	context.lineTo(x1, y1);
	context.lineTo(x2, y2);
	context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	context.closePath();
} };

//#endregion
//#region node_modules/d3-shape/src/symbol.js
function Symbol$1(type, size) {
	let context = null, path$1 = withPath(symbol);
	type = typeof type === "function" ? type : constant_default$1(type || circle_default);
	size = typeof size === "function" ? size : constant_default$1(size === void 0 ? 64 : +size);
	function symbol() {
		let buffer;
		if (!context) context = buffer = path$1();
		type.apply(this, arguments).draw(context, +size.apply(this, arguments));
		if (buffer) return context = null, buffer + "" || null;
	}
	symbol.type = function(_) {
		return arguments.length ? (type = typeof _ === "function" ? _ : constant_default$1(_), symbol) : type;
	};
	symbol.size = function(_) {
		return arguments.length ? (size = typeof _ === "function" ? _ : constant_default$1(+_), symbol) : size;
	};
	symbol.context = function(_) {
		return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	};
	return symbol;
}

//#endregion
//#region node_modules/d3-shape/src/noop.js
function noop_default() {}

//#endregion
//#region node_modules/d3-shape/src/curve/basis.js
function point$2(that, x$1, y$1) {
	that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x$1) / 6, (that._y0 + 4 * that._y1 + y$1) / 6);
}
function Basis(context) {
	this._context = context;
}
Basis.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 3: point$2(this, this._x1, this._y1);
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basis_default$1(context) {
	return new Basis(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/basisClosed.js
function BasisClosed(context) {
	this._context = context;
}
BasisClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 1:
				this._context.moveTo(this._x2, this._y2);
				this._context.closePath();
				break;
			case 2:
				this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
				this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
				this._context.closePath();
				break;
			case 3:
				this.point(this._x2, this._y2);
				this.point(this._x3, this._y3);
				this.point(this._x4, this._y4);
				break;
		}
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._x2 = x$1, this._y2 = y$1;
				break;
			case 1:
				this._point = 2;
				this._x3 = x$1, this._y3 = y$1;
				break;
			case 2:
				this._point = 3;
				this._x4 = x$1, this._y4 = y$1;
				this._context.moveTo((this._x0 + 4 * this._x1 + x$1) / 6, (this._y0 + 4 * this._y1 + y$1) / 6);
				break;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisClosed_default$1(context) {
	return new BasisClosed(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/basisOpen.js
function BasisOpen(context) {
	this._context = context;
}
BasisOpen.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				var x0 = (this._x0 + 4 * this._x1 + x$1) / 6, y0 = (this._y0 + 4 * this._y1 + y$1) / 6;
				this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
				break;
			case 3: this._point = 4;
			default:
				point$2(this, x$1, y$1);
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
	}
};
function basisOpen_default(context) {
	return new BasisOpen(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/linearClosed.js
function LinearClosed(context) {
	this._context = context;
}
LinearClosed.prototype = {
	areaStart: noop_default,
	areaEnd: noop_default,
	lineStart: function() {
		this._point = 0;
	},
	lineEnd: function() {
		if (this._point) this._context.closePath();
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		if (this._point) this._context.lineTo(x$1, y$1);
		else this._point = 1, this._context.moveTo(x$1, y$1);
	}
};
function linearClosed_default(context) {
	return new LinearClosed(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/monotone.js
function sign(x$1) {
	return x$1 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
	var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
	return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
	var h = that._x1 - that._x0;
	return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point$1(that, t0$1, t1$1) {
	var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
	that._context.bezierCurveTo(x0 + dx, y0 + dx * t0$1, x1 - dx, y1 - dx * t1$1, x1, y1);
}
function MonotoneX(context) {
	this._context = context;
}
MonotoneX.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		switch (this._point) {
			case 2:
				this._context.lineTo(this._x1, this._y1);
				break;
			case 3:
				point$1(this, this._t0, slope2(this, this._t0));
				break;
		}
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		var t1$1 = NaN;
		x$1 = +x$1, y$1 = +y$1;
		if (x$1 === this._x1 && y$1 === this._y1) return;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1:
				this._point = 2;
				break;
			case 2:
				this._point = 3;
				point$1(this, slope2(this, t1$1 = slope3(this, x$1, y$1)), t1$1);
				break;
			default:
				point$1(this, this._t0, t1$1 = slope3(this, x$1, y$1));
				break;
		}
		this._x0 = this._x1, this._x1 = x$1;
		this._y0 = this._y1, this._y1 = y$1;
		this._t0 = t1$1;
	}
};
function MonotoneY(context) {
	this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x$1, y$1) {
	MonotoneX.prototype.point.call(this, y$1, x$1);
};
function ReflectContext(context) {
	this._context = context;
}
ReflectContext.prototype = {
	moveTo: function(x$1, y$1) {
		this._context.moveTo(y$1, x$1);
	},
	closePath: function() {
		this._context.closePath();
	},
	lineTo: function(x$1, y$1) {
		this._context.lineTo(y$1, x$1);
	},
	bezierCurveTo: function(x1, y1, x2, y2, x$1, y$1) {
		this._context.bezierCurveTo(y1, x1, y2, x2, y$1, x$1);
	}
};
function monotoneX(context) {
	return new MonotoneX(context);
}
function monotoneY(context) {
	return new MonotoneY(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/natural.js
function Natural(context) {
	this._context = context;
}
Natural.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = [];
		this._y = [];
	},
	lineEnd: function() {
		var x$1 = this._x, y$1 = this._y, n = x$1.length;
		if (n) {
			this._line ? this._context.lineTo(x$1[0], y$1[0]) : this._context.moveTo(x$1[0], y$1[0]);
			if (n === 2) this._context.lineTo(x$1[1], y$1[1]);
			else {
				var px = controlPoints(x$1), py = controlPoints(y$1);
				for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x$1[i1], y$1[i1]);
			}
		}
		if (this._line || this._line !== 0 && n === 1) this._context.closePath();
		this._line = 1 - this._line;
		this._x = this._y = null;
	},
	point: function(x$1, y$1) {
		this._x.push(+x$1);
		this._y.push(+y$1);
	}
};
function controlPoints(x$1) {
	var i, n = x$1.length - 1, m, a$1 = new Array(n), b = new Array(n), r$1 = new Array(n);
	a$1[0] = 0, b[0] = 2, r$1[0] = x$1[0] + 2 * x$1[1];
	for (i = 1; i < n - 1; ++i) a$1[i] = 1, b[i] = 4, r$1[i] = 4 * x$1[i] + 2 * x$1[i + 1];
	a$1[n - 1] = 2, b[n - 1] = 7, r$1[n - 1] = 8 * x$1[n - 1] + x$1[n];
	for (i = 1; i < n; ++i) m = a$1[i] / b[i - 1], b[i] -= m, r$1[i] -= m * r$1[i - 1];
	a$1[n - 1] = r$1[n - 1] / b[n - 1];
	for (i = n - 2; i >= 0; --i) a$1[i] = (r$1[i] - a$1[i + 1]) / b[i];
	b[n - 1] = (x$1[n] + a$1[n - 1]) / 2;
	for (i = 0; i < n - 1; ++i) b[i] = 2 * x$1[i + 1] - a$1[i + 1];
	return [a$1, b];
}
function natural_default(context) {
	return new Natural(context);
}

//#endregion
//#region node_modules/d3-shape/src/curve/step.js
function Step(context, t) {
	this._context = context;
	this._t = t;
}
Step.prototype = {
	areaStart: function() {
		this._line = 0;
	},
	areaEnd: function() {
		this._line = NaN;
	},
	lineStart: function() {
		this._x = this._y = NaN;
		this._point = 0;
	},
	lineEnd: function() {
		if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
		if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
		if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	},
	point: function(x$1, y$1) {
		x$1 = +x$1, y$1 = +y$1;
		switch (this._point) {
			case 0:
				this._point = 1;
				this._line ? this._context.lineTo(x$1, y$1) : this._context.moveTo(x$1, y$1);
				break;
			case 1: this._point = 2;
			default:
				if (this._t <= 0) {
					this._context.lineTo(this._x, y$1);
					this._context.lineTo(x$1, y$1);
				} else {
					var x1 = this._x * (1 - this._t) + x$1 * this._t;
					this._context.lineTo(x1, this._y);
					this._context.lineTo(x1, y$1);
				}
				break;
		}
		this._x = x$1, this._y = y$1;
	}
};
function step_default(context) {
	return new Step(context, .5);
}
function stepBefore(context) {
	return new Step(context, 0);
}
function stepAfter(context) {
	return new Step(context, 1);
}

//#endregion
//#region node_modules/d3-shape/src/offset/none.js
function none_default(series, order) {
	if (!((n = series.length) > 1)) return;
	for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
		s0 = s1, s1 = series[order[i]];
		for (j = 0; j < m; ++j) s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	}
}

//#endregion
//#region node_modules/d3-shape/src/order/none.js
function none_default$1(series) {
	var n = series.length, o = new Array(n);
	while (--n >= 0) o[n] = n;
	return o;
}

//#endregion
//#region node_modules/d3-shape/src/stack.js
function stackValue(d, key) {
	return d[key];
}
function stackSeries(key) {
	const series = [];
	series.key = key;
	return series;
}
function stack_default() {
	var keys = constant_default$1([]), order = none_default$1, offset = none_default, value = stackValue;
	function stack(data) {
		var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
		for (const d of data) for (i = 0, ++j; i < n; ++i) (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
		for (i = 0, oz = array_default(order(sz)); i < n; ++i) sz[oz[i]].index = i;
		offset(sz, oz);
		return sz;
	}
	stack.keys = function(_) {
		return arguments.length ? (keys = typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : keys;
	};
	stack.value = function(_) {
		return arguments.length ? (value = typeof _ === "function" ? _ : constant_default$1(+_), stack) : value;
	};
	stack.order = function(_) {
		return arguments.length ? (order = _ == null ? none_default$1 : typeof _ === "function" ? _ : constant_default$1(Array.from(_)), stack) : order;
	};
	stack.offset = function(_) {
		return arguments.length ? (offset = _ == null ? none_default : _, stack) : offset;
	};
	return stack;
}

//#endregion
//#region node_modules/d3-shape/src/offset/expand.js
function expand_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var i, n, j = 0, m = series[0].length, y$1; j < m; ++j) {
		for (y$1 = i = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		if (y$1) for (i = 0; i < n; ++i) series[i][j][1] /= y$1;
	}
	none_default(series, order);
}

//#endregion
//#region node_modules/d3-shape/src/offset/silhouette.js
function silhouette_default(series, order) {
	if (!((n = series.length) > 0)) return;
	for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
		for (var i = 0, y$1 = 0; i < n; ++i) y$1 += series[i][j][1] || 0;
		s0[j][1] += s0[j][0] = -y$1 / 2;
	}
	none_default(series, order);
}

//#endregion
//#region node_modules/d3-shape/src/offset/wiggle.js
function wiggle_default(series, order) {
	if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	for (var y$1 = 0, j = 1, s0, m, n; j < m; ++j) {
		for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
			var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
			for (var k$1 = 0; k$1 < i; ++k$1) {
				var sk = series[order[k$1]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
				s3 += skj0 - skj1;
			}
			s1 += sij0, s2 += s3 * sij0;
		}
		s0[j - 1][1] += s0[j - 1][0] = y$1;
		if (s1) y$1 -= s2 / s1;
	}
	s0[j - 1][1] += s0[j - 1][0] = y$1;
	none_default(series, order);
}

//#endregion
//#region node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js
var require_isUnsafeProperty = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/_internal/isUnsafeProperty.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isUnsafeProperty$2(key) {
		return key === "__proto__";
	}
	exports.isUnsafeProperty = isUnsafeProperty$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js
var require_isDeepKey = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/isDeepKey.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isDeepKey$4(key) {
		switch (typeof key) {
			case "number":
			case "symbol": return false;
			case "string": return key.includes(".") || key.includes("[") || key.includes("]");
		}
	}
	exports.isDeepKey = isDeepKey$4;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/toKey.js
var require_toKey = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/toKey.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function toKey$4(value) {
		if (typeof value === "string" || typeof value === "symbol") return value;
		if (Object.is(value?.valueOf?.(), -0)) return "-0";
		return String(value);
	}
	exports.toKey = toKey$4;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/toString.js
var require_toString = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/toString.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function toString$1(value) {
		if (value == null) return "";
		if (typeof value === "string") return value;
		if (Array.isArray(value)) return value.map(toString$1).join(",");
		const result = String(value);
		if (result === "0" && Object.is(Number(value), -0)) return "-0";
		return result;
	}
	exports.toString = toString$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/toPath.js
var require_toPath = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/toPath.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var toString = require_toString();
	var toKey$3 = require_toKey();
	function toPath$4(deepKey) {
		if (Array.isArray(deepKey)) return deepKey.map(toKey$3.toKey);
		if (typeof deepKey === "symbol") return [deepKey];
		deepKey = toString.toString(deepKey);
		const result = [];
		const length = deepKey.length;
		if (length === 0) return result;
		let index = 0;
		let key = "";
		let quoteChar = "";
		let bracket = false;
		if (deepKey.charCodeAt(0) === 46) {
			result.push("");
			index++;
		}
		while (index < length) {
			const char = deepKey[index];
			if (quoteChar) if (char === "\\" && index + 1 < length) {
				index++;
				key += deepKey[index];
			} else if (char === quoteChar) quoteChar = "";
			else key += char;
			else if (bracket) if (char === "\"" || char === "'") quoteChar = char;
			else if (char === "]") {
				bracket = false;
				result.push(key);
				key = "";
			} else key += char;
			else if (char === "[") {
				bracket = true;
				if (key) {
					result.push(key);
					key = "";
				}
			} else if (char === ".") {
				if (key) {
					result.push(key);
					key = "";
				}
			} else key += char;
			index++;
		}
		if (key) result.push(key);
		return result;
	}
	exports.toPath = toPath$4;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/get.js
var require_get$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/get.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isUnsafeProperty$1 = require_isUnsafeProperty();
	var isDeepKey$3 = require_isDeepKey();
	var toKey$2 = require_toKey();
	var toPath$3 = require_toPath();
	function get$11(object, path$1, defaultValue) {
		if (object == null) return defaultValue;
		switch (typeof path$1) {
			case "string": {
				if (isUnsafeProperty$1.isUnsafeProperty(path$1)) return defaultValue;
				const result = object[path$1];
				if (result === void 0) if (isDeepKey$3.isDeepKey(path$1)) return get$11(object, toPath$3.toPath(path$1), defaultValue);
				else return defaultValue;
				return result;
			}
			case "number":
			case "symbol": {
				if (typeof path$1 === "number") path$1 = toKey$2.toKey(path$1);
				const result = object[path$1];
				if (result === void 0) return defaultValue;
				return result;
			}
			default: {
				if (Array.isArray(path$1)) return getWithPath(object, path$1, defaultValue);
				if (Object.is(path$1?.valueOf(), -0)) path$1 = "-0";
				else path$1 = String(path$1);
				if (isUnsafeProperty$1.isUnsafeProperty(path$1)) return defaultValue;
				const result = object[path$1];
				if (result === void 0) return defaultValue;
				return result;
			}
		}
	}
	function getWithPath(object, path$1, defaultValue) {
		if (path$1.length === 0) return defaultValue;
		let current$1 = object;
		for (let index = 0; index < path$1.length; index++) {
			if (current$1 == null) return defaultValue;
			if (isUnsafeProperty$1.isUnsafeProperty(path$1[index])) return defaultValue;
			current$1 = current$1[path$1[index]];
		}
		if (current$1 === void 0) return defaultValue;
		return current$1;
	}
	exports.get = get$11;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/get.js
var require_get = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/get.js": ((exports, module) => {
	module.exports = require_get$1().get;
}) });

//#endregion
//#region node_modules/recharts/es6/util/DataUtils.js
var import_get$7 = /* @__PURE__ */ __toESM(require_get());
var mathSign = (value) => {
	if (value === 0) return 0;
	if (value > 0) return 1;
	return -1;
};
var isNan = (value) => {
	return typeof value == "number" && value != +value;
};
var isPercent = (value) => typeof value === "string" && value.indexOf("%") === value.length - 1;
var isNumber = (value) => (typeof value === "number" || value instanceof Number) && !isNan(value);
var isNumOrStr = (value) => isNumber(value) || typeof value === "string";
var idCounter = 0;
var uniqueId = (prefix$2) => {
	var id = ++idCounter;
	return "".concat(prefix$2 || "").concat(id);
};
/**
* Get percent value of a total value
* @param {number|string} percent A percent
* @param {number} totalValue     Total value
* @param {number} defaultValue   The value returned when percent is undefined or invalid
* @param {boolean} validate      If set to be true, the result will be validated
* @return {number} value
*/
var getPercentValue = function getPercentValue$1(percent, totalValue) {
	var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
	var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
	if (!isNumber(percent) && typeof percent !== "string") return defaultValue;
	var value;
	if (isPercent(percent)) {
		if (totalValue == null) return defaultValue;
		var index = percent.indexOf("%");
		value = totalValue * parseFloat(percent.slice(0, index)) / 100;
	} else value = +percent;
	if (isNan(value)) value = defaultValue;
	if (validate && totalValue != null && value > totalValue) value = totalValue;
	return value;
};
var hasDuplicate = (ary) => {
	if (!Array.isArray(ary)) return false;
	var len = ary.length;
	var cache = {};
	for (var i = 0; i < len; i++) if (!cache[ary[i]]) cache[ary[i]] = true;
	else return true;
	return false;
};
/**
* @deprecated instead use {@link interpolate}
*  this function returns a function that is called immediately in all use-cases.
*  Instead, use interpolate which returns a number and skips the anonymous function step.
*  @param numberA The first number
*  @param numberB The second number
*  @return A function that returns the interpolated number
*/
var interpolateNumber = (numberA, numberB) => {
	if (isNumber(numberA) && isNumber(numberB)) return (t) => numberA + t * (numberB - numberA);
	return () => numberB;
};
function interpolate(start, end, t) {
	if (isNumber(start) && isNumber(end)) return start + t * (end - start);
	return end;
}
function findEntryInArray(ary, specifiedKey, specifiedValue) {
	if (!ary || !ary.length) return;
	return ary.find((entry) => entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : (0, import_get$7.default)(entry, specifiedKey)) === specifiedValue);
}
/**
* The least square linear regression
* @param {Array} data The array of points
* @returns {Object} The domain of x, and the parameter of linear function
*/
var getLinearRegression = (data) => {
	if (!data || !data.length) return null;
	var len = data.length;
	var xsum = 0;
	var ysum = 0;
	var xysum = 0;
	var xxsum = 0;
	var xmin = Infinity;
	var xmax = -Infinity;
	var xcurrent = 0;
	var ycurrent = 0;
	for (var i = 0; i < len; i++) {
		xcurrent = data[i].cx || 0;
		ycurrent = data[i].cy || 0;
		xsum += xcurrent;
		ysum += ycurrent;
		xysum += xcurrent * ycurrent;
		xxsum += xcurrent * xcurrent;
		xmin = Math.min(xmin, xcurrent);
		xmax = Math.max(xmax, xcurrent);
	}
	var a$1 = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;
	return {
		xmin,
		xmax,
		a: a$1,
		b: (ysum - a$1 * xsum) / len
	};
};
/**
* Checks if the value is null or undefined
* @param value The value to check
* @returns true if the value is null or undefined
*/
var isNullish = (value) => {
	return value === null || typeof value === "undefined";
};
/**
*Uppercase the first letter of a string
* @param {string} value The string to uppercase
* @returns {string} The uppercased string
*/
var upperFirst = (value) => {
	if (isNullish(value)) return value;
	return "".concat(value.charAt(0).toUpperCase()).concat(value.slice(1));
};

//#endregion
//#region node_modules/recharts/es6/shape/Symbols.js
var _excluded$34 = [
	"type",
	"size",
	"sizeType"
];
function _extends$46() {
	return _extends$46 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$46.apply(null, arguments);
}
function ownKeys$60(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$60(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$60(Object(t), !0).forEach(function(r$2) {
			_defineProperty$62(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$60(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$62(e, r$1, t) {
	return (r$1 = _toPropertyKey$62(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$62(t) {
	var i = _toPrimitive$62(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$62(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$34(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$34(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$34(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var symbolFactories = {
	symbolCircle: circle_default,
	symbolCross: cross_default,
	symbolDiamond: diamond_default,
	symbolSquare: square_default,
	symbolStar: star_default,
	symbolTriangle: triangle_default,
	symbolWye: wye_default
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = (type) => {
	var name = "symbol".concat(upperFirst(type));
	return symbolFactories[name] || circle_default;
};
var calculateAreaSize = (size, sizeType, type) => {
	if (sizeType === "area") return size;
	switch (type) {
		case "cross": return 5 * size * size / 9;
		case "diamond": return .5 * size * size / Math.sqrt(3);
		case "square": return size * size;
		case "star":
			var angle = 18 * RADIAN$1;
			return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.tan(angle) ** 2);
		case "triangle": return Math.sqrt(3) * size * size / 4;
		case "wye": return (21 - 10 * Math.sqrt(3)) * size * size / 8;
		default: return Math.PI * size * size / 4;
	}
};
var registerSymbol = (key, factory) => {
	symbolFactories["symbol".concat(upperFirst(key))] = factory;
};
var Symbols = (_ref$1) => {
	var { type = "circle", size = 64, sizeType = "area" } = _ref$1, rest = _objectWithoutProperties$34(_ref$1, _excluded$34);
	var props = _objectSpread$60(_objectSpread$60({}, rest), {}, {
		type,
		size,
		sizeType
	});
	var realType = "circle";
	if (typeof type === "string") realType = type;
	/**
	* Calculate the path of curve
	* @return {String} path
	*/
	var getPath$2 = () => {
		var symbolFactory = getSymbolFactory(realType);
		var s$1 = Symbol$1().type(symbolFactory).size(calculateAreaSize(size, sizeType, realType))();
		if (s$1 === null) return;
		return s$1;
	};
	var { className, cx, cy } = props;
	var filteredProps = svgPropertiesAndEvents(props);
	if (cx === +cx && cy === +cy && size === +size) return /* @__PURE__ */ import_react.createElement("path", _extends$46({}, filteredProps, {
		className: clsx("recharts-symbols", className),
		transform: "translate(".concat(cx, ", ").concat(cy, ")"),
		d: getPath$2()
	}));
	return null;
};
Symbols.registerSymbol = registerSymbol;

//#endregion
//#region node_modules/recharts/es6/util/types.js
/**
* Determines how values are stacked:
*
* - `none` is the default, it adds values on top of each other. No smarts. Negative values will overlap.
* - `expand` make it so that the values always add up to 1 - so the chart will look like a rectangle.
* - `wiggle` and `silhouette` tries to keep the chart centered.
* - `sign` stacks positive values above zero and negative values below zero. Similar to `none` but handles negatives.
* - `positive` ignores all negative values, and then behaves like \`none\`.
*
* Also see https://d3js.org/d3-shape/stack#stack-offsets
* (note that the `diverging` offset in d3 is named `sign` in recharts)
*/
/**
* @deprecated use either `CartesianLayout` or `PolarLayout` instead.
* Mixing both charts families leads to ambiguity in the type system.
* These two layouts share very few properties, so it is best to keep them separate.
*/
/**
* @deprecated do not use: too many properties, mixing too many concepts, cartesian and polar together, everything optional.
*/
/** The type of easing function to use for animations */
/** Specifies the duration of animation, the unit of this option is ms. */
/**
* This object defines the offset of the chart area and width and height and brush and ... it's a bit too much information all in one.
* We use it internally but let's not expose it to the outside world.
* If you are looking for this information, instead import `ChartOffset` or `PlotArea` from `recharts`.
*/
/**
* The domain of axis.
* This is the definition
*
* Numeric domain is always defined by an array of exactly two values, for the min and the max of the axis.
* Categorical domain is defined as array of all possible values.
*
* Can be specified in many ways:
* - array of numbers
* - with special strings like 'dataMin' and 'dataMax'
* - with special string math like 'dataMin - 100'
* - with keyword 'auto'
* - or a function
* - array of functions
* - or a combination of the above
*/
/**
* NumberDomain is an evaluated {@link AxisDomain}.
* Unlike {@link AxisDomain}, it has no variety - it's a tuple of two number.
* This is after all the keywords and functions were evaluated and what is left is [min, max].
*
* Know that the min, max values are not guaranteed to be nice numbers - values like -Infinity or NaN are possible.
*
* There are also `category` axes that have different things than numbers in their domain.
*/
/** The props definition of base axis */
/** Defines how ticks are placed and whether / how tick collisions are handled.
* 'preserveStart' keeps the left tick on collision and ensures that the first tick is always shown.
* 'preserveEnd' keeps the right tick on collision and ensures that the last tick is always shown.
* 'preserveStartEnd' keeps the left tick on collision and ensures that the first and last ticks always show.
* 'equidistantPreserveStart' selects a number N such that every nTh tick will be shown without collision.
*/
/**
* Ticks can be any type when the axis is the type of category.
*
* Ticks must be numbers when the axis is the type of number.
*/
var adaptEventHandlers = (props, newHandler) => {
	if (!props || typeof props === "function" || typeof props === "boolean") return null;
	var inputProps = props;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(props)) inputProps = props.props;
	if (typeof inputProps !== "object" && typeof inputProps !== "function") return null;
	var out = {};
	Object.keys(inputProps).forEach((key) => {
		if (isEventKey(key)) out[key] = newHandler || ((e) => inputProps[key](inputProps, e));
	});
	return out;
};
var getEventHandlerOfChild = (originalHandler, data, index) => (e) => {
	originalHandler(data, index, e);
	return null;
};
var adaptEventsOfChild = (props, data, index) => {
	if (props === null || typeof props !== "object" && typeof props !== "function") return null;
	var out = null;
	Object.keys(props).forEach((key) => {
		var item = props[key];
		if (isEventKey(key) && typeof item === "function") {
			if (!out) out = {};
			out[key] = getEventHandlerOfChild(item, data, index);
		}
	});
	return out;
};
/**
* 'axis' means that all graphical items belonging to this axis tick will be highlighted,
* and all will be present in the tooltip.
* Tooltip with 'axis' will display when hovering on the chart background.
*
* 'item' means only the one graphical item being hovered will show in the tooltip.
* Tooltip with 'item' will display when hovering over individual graphical items.
*
* This is calculated internally;
* charts have a `defaultTooltipEventType` and `validateTooltipEventTypes` options.
*
* Users then use <Tooltip shared={true} /> or <Tooltip shared={false} /> to control their preference,
* and charts will then see what is allowed and what is not.
*/
/**
* These are the props we are going to pass to an `activeDot` if it is a function or a custom Component
*/
/**
* This is the type of `activeDot` prop on:
* - Area
* - Line
* - Radar
*/
/**
* Simplified version of the MouseEvent so that we don't have to mock the whole thing in tests.
*
* This is meant to represent the React.MouseEvent
* which is a wrapper on top of https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent
*/
/**
* Coordinates relative to the top-left corner of the chart.
* Also include scale which means that a chart that's scaled will return the same coordinates as a chart that's not scaled.
*/
//#endregion
//#region node_modules/recharts/es6/component/DefaultLegendContent.js
function _extends$45() {
	return _extends$45 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$45.apply(null, arguments);
}
function ownKeys$59(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$59(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$59(Object(t), !0).forEach(function(r$2) {
			_defineProperty$61(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$59(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$61(e, r$1, t) {
	return (r$1 = _toPropertyKey$61(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$61(t) {
	var i = _toPrimitive$61(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$61(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var SIZE = 32;
var DefaultLegendContent = class extends import_react.PureComponent {
	/**
	* Render the path of icon
	* @param data Data of each legend item
	* @param iconType if defined, it will always render this icon. If undefined then it uses icon from data.type
	* @return Path element
	*/
	renderIcon(data, iconType) {
		var { inactiveColor } = this.props;
		var halfSize = SIZE / 2;
		var sixthSize = SIZE / 6;
		var thirdSize = SIZE / 3;
		var color$1 = data.inactive ? inactiveColor : data.color;
		var preferredIcon = iconType !== null && iconType !== void 0 ? iconType : data.type;
		if (preferredIcon === "none") return null;
		if (preferredIcon === "plainline") return /* @__PURE__ */ import_react.createElement("line", {
			strokeWidth: 4,
			fill: "none",
			stroke: color$1,
			strokeDasharray: data.payload.strokeDasharray,
			x1: 0,
			y1: halfSize,
			x2: SIZE,
			y2: halfSize,
			className: "recharts-legend-icon"
		});
		if (preferredIcon === "line") return /* @__PURE__ */ import_react.createElement("path", {
			strokeWidth: 4,
			fill: "none",
			stroke: color$1,
			d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
			className: "recharts-legend-icon"
		});
		if (preferredIcon === "rect") return /* @__PURE__ */ import_react.createElement("path", {
			stroke: "none",
			fill: color$1,
			d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
			className: "recharts-legend-icon"
		});
		if (/* @__PURE__ */ import_react.isValidElement(data.legendIcon)) {
			var iconProps = _objectSpread$59({}, data);
			delete iconProps.legendIcon;
			return /* @__PURE__ */ import_react.cloneElement(data.legendIcon, iconProps);
		}
		return /* @__PURE__ */ import_react.createElement(Symbols, {
			fill: color$1,
			cx: halfSize,
			cy: halfSize,
			size: SIZE,
			sizeType: "diameter",
			type: preferredIcon
		});
	}
	/**
	* Draw items of legend
	* @return Items
	*/
	renderItems() {
		var { payload, iconSize, layout, formatter, inactiveColor, iconType } = this.props;
		var viewBox = {
			x: 0,
			y: 0,
			width: SIZE,
			height: SIZE
		};
		var itemStyle = {
			display: layout === "horizontal" ? "inline-block" : "block",
			marginRight: 10
		};
		var svgStyle = {
			display: "inline-block",
			verticalAlign: "middle",
			marginRight: 4
		};
		return payload.map((entry, i) => {
			var finalFormatter = entry.formatter || formatter;
			var className = clsx({
				"recharts-legend-item": true,
				["legend-item-".concat(i)]: true,
				inactive: entry.inactive
			});
			if (entry.type === "none") return null;
			var color$1 = entry.inactive ? inactiveColor : entry.color;
			var finalValue = finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value;
			return /* @__PURE__ */ import_react.createElement("li", _extends$45({
				className,
				style: itemStyle,
				key: "legend-item-".concat(i)
			}, adaptEventsOfChild(this.props, entry, i)), /* @__PURE__ */ import_react.createElement(Surface, {
				width: iconSize,
				height: iconSize,
				viewBox,
				style: svgStyle,
				"aria-label": "".concat(finalValue, " legend icon")
			}, this.renderIcon(entry, iconType)), /* @__PURE__ */ import_react.createElement("span", {
				className: "recharts-legend-item-text",
				style: { color: color$1 }
			}, finalValue));
		});
	}
	render() {
		var { payload, layout, align } = this.props;
		if (!payload || !payload.length) return null;
		var finalStyle = {
			padding: 0,
			margin: 0,
			textAlign: layout === "horizontal" ? align : "left"
		};
		return /* @__PURE__ */ import_react.createElement("ul", {
			className: "recharts-default-legend",
			style: finalStyle
		}, this.renderItems());
	}
};
_defineProperty$61(DefaultLegendContent, "displayName", "Legend");
_defineProperty$61(DefaultLegendContent, "defaultProps", {
	align: "center",
	iconSize: 14,
	inactiveColor: "#ccc",
	layout: "horizontal",
	verticalAlign: "middle"
});

//#endregion
//#region node_modules/es-toolkit/dist/array/uniqBy.js
var require_uniqBy$2 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/array/uniqBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function uniqBy$3(arr, mapper) {
		const map$2 = /* @__PURE__ */ new Map();
		for (let i = 0; i < arr.length; i++) {
			const item = arr[i];
			const key = mapper(item);
			if (!map$2.has(key)) map$2.set(key, item);
		}
		return Array.from(map$2.values());
	}
	exports.uniqBy = uniqBy$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/function/identity.js
var require_identity = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/function/identity.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function identity$7(x$1) {
		return x$1;
	}
	exports.identity = identity$7;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/predicate/isLength.js
var require_isLength = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/predicate/isLength.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isLength$1(value) {
		return Number.isSafeInteger(value) && value >= 0;
	}
	exports.isLength = isLength$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js
var require_isArrayLike = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isArrayLike.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isLength = require_isLength();
	function isArrayLike$5(value) {
		return value != null && typeof value !== "function" && isLength.isLength(value.length);
	}
	exports.isArrayLike = isArrayLike$5;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js
var require_isObjectLike = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isObjectLike.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isObjectLike$1(value) {
		return typeof value === "object" && value !== null;
	}
	exports.isObjectLike = isObjectLike$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js
var require_isArrayLikeObject = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isArrayLikeObject.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isArrayLike$4 = require_isArrayLike();
	var isObjectLike = require_isObjectLike();
	function isArrayLikeObject$1(value) {
		return isObjectLike.isObjectLike(value) && isArrayLike$4.isArrayLike(value);
	}
	exports.isArrayLikeObject = isArrayLikeObject$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/property.js
var require_property = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/property.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var get$9 = require_get$1();
	function property$1(path$1) {
		return function(object) {
			return get$9.get(object, path$1);
		};
	}
	exports.property = property$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isObject.js
var require_isObject = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isObject.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isObject$2(value) {
		return value !== null && (typeof value === "object" || typeof value === "function");
	}
	exports.isObject = isObject$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/predicate/isPrimitive.js
var require_isPrimitive = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/predicate/isPrimitive.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isPrimitive$2(value) {
		return value == null || typeof value !== "object" && typeof value !== "function";
	}
	exports.isPrimitive = isPrimitive$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/eq.js
var require_eq = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/eq.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function eq$2(value, other) {
		return value === other || Number.isNaN(value) && Number.isNaN(other);
	}
	exports.eq = eq$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js
var require_isMatchWith = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isMatchWith.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isMatch$3 = require_isMatch();
	var isObject$1 = require_isObject();
	var isPrimitive$1 = require_isPrimitive();
	var eq$1 = require_eq();
	function isMatchWith$1(target, source, compare) {
		if (typeof compare !== "function") return isMatch$3.isMatch(target, source);
		return isMatchWithInternal(target, source, function doesMatch(objValue, srcValue, key, object, source$1, stack) {
			const isEqual = compare(objValue, srcValue, key, object, source$1, stack);
			if (isEqual !== void 0) return Boolean(isEqual);
			return isMatchWithInternal(objValue, srcValue, doesMatch, stack);
		}, /* @__PURE__ */ new Map());
	}
	function isMatchWithInternal(target, source, compare, stack) {
		if (source === target) return true;
		switch (typeof source) {
			case "object": return isObjectMatch(target, source, compare, stack);
			case "function":
				if (Object.keys(source).length > 0) return isMatchWithInternal(target, { ...source }, compare, stack);
				return eq$1.eq(target, source);
			default:
				if (!isObject$1.isObject(target)) return eq$1.eq(target, source);
				if (typeof source === "string") return source === "";
				return true;
		}
	}
	function isObjectMatch(target, source, compare, stack) {
		if (source == null) return true;
		if (Array.isArray(source)) return isArrayMatch(target, source, compare, stack);
		if (source instanceof Map) return isMapMatch(target, source, compare, stack);
		if (source instanceof Set) return isSetMatch(target, source, compare, stack);
		const keys = Object.keys(source);
		if (target == null) return keys.length === 0;
		if (keys.length === 0) return true;
		if (stack && stack.has(source)) return stack.get(source) === target;
		if (stack) stack.set(source, target);
		try {
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				if (!isPrimitive$1.isPrimitive(target) && !(key in target)) return false;
				if (source[key] === void 0 && target[key] !== void 0) return false;
				if (source[key] === null && target[key] !== null) return false;
				if (!compare(target[key], source[key], key, target, source, stack)) return false;
			}
			return true;
		} finally {
			if (stack) stack.delete(source);
		}
	}
	function isMapMatch(target, source, compare, stack) {
		if (source.size === 0) return true;
		if (!(target instanceof Map)) return false;
		for (const [key, sourceValue] of source.entries()) {
			const targetValue = target.get(key);
			if (compare(targetValue, sourceValue, key, target, source, stack) === false) return false;
		}
		return true;
	}
	function isArrayMatch(target, source, compare, stack) {
		if (source.length === 0) return true;
		if (!Array.isArray(target)) return false;
		const countedIndex = /* @__PURE__ */ new Set();
		for (let i = 0; i < source.length; i++) {
			const sourceItem = source[i];
			let found = false;
			for (let j = 0; j < target.length; j++) {
				if (countedIndex.has(j)) continue;
				const targetItem = target[j];
				let matches$3 = false;
				if (compare(targetItem, sourceItem, i, target, source, stack)) matches$3 = true;
				if (matches$3) {
					countedIndex.add(j);
					found = true;
					break;
				}
			}
			if (!found) return false;
		}
		return true;
	}
	function isSetMatch(target, source, compare, stack) {
		if (source.size === 0) return true;
		if (!(target instanceof Set)) return false;
		return isArrayMatch([...target], [...source], compare, stack);
	}
	exports.isMatchWith = isMatchWith$1;
	exports.isSetMatch = isSetMatch;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isMatch.js
var require_isMatch = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isMatch.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isMatchWith = require_isMatchWith();
	function isMatch$2(target, source) {
		return isMatchWith.isMatchWith(target, source, () => void 0);
	}
	exports.isMatch = isMatch$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/getSymbols.js
var require_getSymbols = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/getSymbols.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function getSymbols$2(object) {
		return Object.getOwnPropertySymbols(object).filter((symbol) => Object.prototype.propertyIsEnumerable.call(object, symbol));
	}
	exports.getSymbols = getSymbols$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/getTag.js
var require_getTag = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/getTag.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function getTag$2(value) {
		if (value == null) return value === void 0 ? "[object Undefined]" : "[object Null]";
		return Object.prototype.toString.call(value);
	}
	exports.getTag = getTag$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/tags.js
var require_tags = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/tags.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var regexpTag = "[object RegExp]";
	var stringTag = "[object String]";
	var numberTag = "[object Number]";
	var booleanTag = "[object Boolean]";
	var argumentsTag = "[object Arguments]";
	var symbolTag = "[object Symbol]";
	var dateTag = "[object Date]";
	var mapTag = "[object Map]";
	var setTag = "[object Set]";
	var arrayTag = "[object Array]";
	var functionTag = "[object Function]";
	var arrayBufferTag = "[object ArrayBuffer]";
	var objectTag = "[object Object]";
	var errorTag = "[object Error]";
	var dataViewTag = "[object DataView]";
	var uint8ArrayTag = "[object Uint8Array]";
	var uint8ClampedArrayTag = "[object Uint8ClampedArray]";
	var uint16ArrayTag = "[object Uint16Array]";
	var uint32ArrayTag = "[object Uint32Array]";
	var bigUint64ArrayTag = "[object BigUint64Array]";
	var int8ArrayTag = "[object Int8Array]";
	var int16ArrayTag = "[object Int16Array]";
	var int32ArrayTag = "[object Int32Array]";
	var bigInt64ArrayTag = "[object BigInt64Array]";
	var float32ArrayTag = "[object Float32Array]";
	var float64ArrayTag = "[object Float64Array]";
	exports.argumentsTag = argumentsTag;
	exports.arrayBufferTag = arrayBufferTag;
	exports.arrayTag = arrayTag;
	exports.bigInt64ArrayTag = bigInt64ArrayTag;
	exports.bigUint64ArrayTag = bigUint64ArrayTag;
	exports.booleanTag = booleanTag;
	exports.dataViewTag = dataViewTag;
	exports.dateTag = dateTag;
	exports.errorTag = errorTag;
	exports.float32ArrayTag = float32ArrayTag;
	exports.float64ArrayTag = float64ArrayTag;
	exports.functionTag = functionTag;
	exports.int16ArrayTag = int16ArrayTag;
	exports.int32ArrayTag = int32ArrayTag;
	exports.int8ArrayTag = int8ArrayTag;
	exports.mapTag = mapTag;
	exports.numberTag = numberTag;
	exports.objectTag = objectTag;
	exports.regexpTag = regexpTag;
	exports.setTag = setTag;
	exports.stringTag = stringTag;
	exports.symbolTag = symbolTag;
	exports.uint16ArrayTag = uint16ArrayTag;
	exports.uint32ArrayTag = uint32ArrayTag;
	exports.uint8ArrayTag = uint8ArrayTag;
	exports.uint8ClampedArrayTag = uint8ClampedArrayTag;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/predicate/isTypedArray.js
var require_isTypedArray$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/predicate/isTypedArray.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isTypedArray$4(x$1) {
		return ArrayBuffer.isView(x$1) && !(x$1 instanceof DataView);
	}
	exports.isTypedArray = isTypedArray$4;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/object/cloneDeepWith.js
var require_cloneDeepWith$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/object/cloneDeepWith.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var getSymbols$1 = require_getSymbols();
	var getTag$1 = require_getTag();
	var tags$1 = require_tags();
	var isPrimitive = require_isPrimitive();
	var isTypedArray$3 = require_isTypedArray$1();
	function cloneDeepWith$4(obj, cloneValue) {
		return cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), cloneValue);
	}
	function cloneDeepWithImpl(valueToClone, keyToClone, objectToClone, stack = /* @__PURE__ */ new Map(), cloneValue = void 0) {
		const cloned = cloneValue?.(valueToClone, keyToClone, objectToClone, stack);
		if (cloned !== void 0) return cloned;
		if (isPrimitive.isPrimitive(valueToClone)) return valueToClone;
		if (stack.has(valueToClone)) return stack.get(valueToClone);
		if (Array.isArray(valueToClone)) {
			const result = new Array(valueToClone.length);
			stack.set(valueToClone, result);
			for (let i = 0; i < valueToClone.length; i++) result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
			if (Object.hasOwn(valueToClone, "index")) result.index = valueToClone.index;
			if (Object.hasOwn(valueToClone, "input")) result.input = valueToClone.input;
			return result;
		}
		if (valueToClone instanceof Date) return new Date(valueToClone.getTime());
		if (valueToClone instanceof RegExp) {
			const result = new RegExp(valueToClone.source, valueToClone.flags);
			result.lastIndex = valueToClone.lastIndex;
			return result;
		}
		if (valueToClone instanceof Map) {
			const result = /* @__PURE__ */ new Map();
			stack.set(valueToClone, result);
			for (const [key, value] of valueToClone) result.set(key, cloneDeepWithImpl(value, key, objectToClone, stack, cloneValue));
			return result;
		}
		if (valueToClone instanceof Set) {
			const result = /* @__PURE__ */ new Set();
			stack.set(valueToClone, result);
			for (const value of valueToClone) result.add(cloneDeepWithImpl(value, void 0, objectToClone, stack, cloneValue));
			return result;
		}
		if (typeof Buffer !== "undefined" && Buffer.isBuffer(valueToClone)) return valueToClone.subarray();
		if (isTypedArray$3.isTypedArray(valueToClone)) {
			const result = new (Object.getPrototypeOf(valueToClone)).constructor(valueToClone.length);
			stack.set(valueToClone, result);
			for (let i = 0; i < valueToClone.length; i++) result[i] = cloneDeepWithImpl(valueToClone[i], i, objectToClone, stack, cloneValue);
			return result;
		}
		if (valueToClone instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && valueToClone instanceof SharedArrayBuffer) return valueToClone.slice(0);
		if (valueToClone instanceof DataView) {
			const result = new DataView(valueToClone.buffer.slice(0), valueToClone.byteOffset, valueToClone.byteLength);
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (typeof File !== "undefined" && valueToClone instanceof File) {
			const result = new File([valueToClone], valueToClone.name, { type: valueToClone.type });
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (typeof Blob !== "undefined" && valueToClone instanceof Blob) {
			const result = new Blob([valueToClone], { type: valueToClone.type });
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (valueToClone instanceof Error) {
			const result = new valueToClone.constructor();
			stack.set(valueToClone, result);
			result.message = valueToClone.message;
			result.name = valueToClone.name;
			result.stack = valueToClone.stack;
			result.cause = valueToClone.cause;
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (valueToClone instanceof Boolean) {
			const result = new Boolean(valueToClone.valueOf());
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (valueToClone instanceof Number) {
			const result = new Number(valueToClone.valueOf());
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (valueToClone instanceof String) {
			const result = new String(valueToClone.valueOf());
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		if (typeof valueToClone === "object" && isCloneableObject(valueToClone)) {
			const result = Object.create(Object.getPrototypeOf(valueToClone));
			stack.set(valueToClone, result);
			copyProperties(result, valueToClone, objectToClone, stack, cloneValue);
			return result;
		}
		return valueToClone;
	}
	function copyProperties(target, source, objectToClone = target, stack, cloneValue) {
		const keys = [...Object.keys(source), ...getSymbols$1.getSymbols(source)];
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			const descriptor = Object.getOwnPropertyDescriptor(target, key);
			if (descriptor == null || descriptor.writable) target[key] = cloneDeepWithImpl(source[key], key, objectToClone, stack, cloneValue);
		}
	}
	function isCloneableObject(object) {
		switch (getTag$1.getTag(object)) {
			case tags$1.argumentsTag:
			case tags$1.arrayTag:
			case tags$1.arrayBufferTag:
			case tags$1.dataViewTag:
			case tags$1.booleanTag:
			case tags$1.dateTag:
			case tags$1.float32ArrayTag:
			case tags$1.float64ArrayTag:
			case tags$1.int8ArrayTag:
			case tags$1.int16ArrayTag:
			case tags$1.int32ArrayTag:
			case tags$1.mapTag:
			case tags$1.numberTag:
			case tags$1.objectTag:
			case tags$1.regexpTag:
			case tags$1.setTag:
			case tags$1.stringTag:
			case tags$1.symbolTag:
			case tags$1.uint8ArrayTag:
			case tags$1.uint8ClampedArrayTag:
			case tags$1.uint16ArrayTag:
			case tags$1.uint32ArrayTag: return true;
			default: return false;
		}
	}
	exports.cloneDeepWith = cloneDeepWith$4;
	exports.cloneDeepWithImpl = cloneDeepWithImpl;
	exports.copyProperties = copyProperties;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/object/cloneDeep.js
var require_cloneDeep$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/object/cloneDeep.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var cloneDeepWith$3 = require_cloneDeepWith$1();
	function cloneDeep$3(obj) {
		return cloneDeepWith$3.cloneDeepWithImpl(obj, void 0, obj, /* @__PURE__ */ new Map(), void 0);
	}
	exports.cloneDeep = cloneDeep$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/matches.js
var require_matches = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/matches.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isMatch$1 = require_isMatch();
	var cloneDeep$2 = require_cloneDeep$1();
	function matches$2(source) {
		source = cloneDeep$2.cloneDeep(source);
		return (target) => {
			return isMatch$1.isMatch(target, source);
		};
	}
	exports.matches = matches$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js
var require_cloneDeepWith = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/cloneDeepWith.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var cloneDeepWith$1$1 = require_cloneDeepWith$1();
	var tags = require_tags();
	function cloneDeepWith$2(obj, customizer) {
		return cloneDeepWith$1$1.cloneDeepWith(obj, (value, key, object, stack) => {
			const cloned = customizer?.(value, key, object, stack);
			if (cloned !== void 0) return cloned;
			if (typeof obj !== "object") return;
			switch (Object.prototype.toString.call(obj)) {
				case tags.numberTag:
				case tags.stringTag:
				case tags.booleanTag: {
					const result = new obj.constructor(obj?.valueOf());
					cloneDeepWith$1$1.copyProperties(result, obj);
					return result;
				}
				case tags.argumentsTag: {
					const result = {};
					cloneDeepWith$1$1.copyProperties(result, obj);
					result.length = obj.length;
					result[Symbol.iterator] = obj[Symbol.iterator];
					return result;
				}
				default: return;
			}
		});
	}
	exports.cloneDeepWith = cloneDeepWith$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/cloneDeep.js
var require_cloneDeep = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/cloneDeep.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var cloneDeepWith$1 = require_cloneDeepWith();
	function cloneDeep$1(obj) {
		return cloneDeepWith$1.cloneDeepWith(obj);
	}
	exports.cloneDeep = cloneDeep$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/isIndex.js
var require_isIndex = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/isIndex.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var IS_UNSIGNED_INTEGER = /^(?:0|[1-9]\d*)$/;
	function isIndex$2(value, length = Number.MAX_SAFE_INTEGER) {
		switch (typeof value) {
			case "number": return Number.isInteger(value) && value >= 0 && value < length;
			case "symbol": return false;
			case "string": return IS_UNSIGNED_INTEGER.test(value);
		}
	}
	exports.isIndex = isIndex$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isArguments.js
var require_isArguments = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isArguments.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var getTag = require_getTag();
	function isArguments$1(value) {
		return value !== null && typeof value === "object" && getTag.getTag(value) === "[object Arguments]";
	}
	exports.isArguments = isArguments$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/has.js
var require_has = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/has.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isDeepKey$2 = require_isDeepKey();
	var isIndex$1 = require_isIndex();
	var isArguments = require_isArguments();
	var toPath$2 = require_toPath();
	function has$3(object, path$1) {
		let resolvedPath;
		if (Array.isArray(path$1)) resolvedPath = path$1;
		else if (typeof path$1 === "string" && isDeepKey$2.isDeepKey(path$1) && object?.[path$1] == null) resolvedPath = toPath$2.toPath(path$1);
		else resolvedPath = [path$1];
		if (resolvedPath.length === 0) return false;
		let current$1 = object;
		for (let i = 0; i < resolvedPath.length; i++) {
			const key = resolvedPath[i];
			if (current$1 == null || !Object.hasOwn(current$1, key)) {
				if (!((Array.isArray(current$1) || isArguments.isArguments(current$1)) && isIndex$1.isIndex(key) && key < current$1.length)) return false;
			}
			current$1 = current$1[key];
		}
		return true;
	}
	exports.has = has$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js
var require_matchesProperty = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/matchesProperty.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isMatch = require_isMatch();
	var toKey$1 = require_toKey();
	var cloneDeep = require_cloneDeep();
	var get$8 = require_get$1();
	var has$2 = require_has();
	function matchesProperty$1(property$2, source) {
		switch (typeof property$2) {
			case "object":
				if (Object.is(property$2?.valueOf(), -0)) property$2 = "-0";
				break;
			case "number":
				property$2 = toKey$1.toKey(property$2);
				break;
		}
		source = cloneDeep.cloneDeep(source);
		return function(target) {
			const result = get$8.get(target, property$2);
			if (result === void 0) return has$2.has(target, property$2);
			if (source === void 0) return result === void 0;
			return isMatch.isMatch(result, source);
		};
	}
	exports.matchesProperty = matchesProperty$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/iteratee.js
var require_iteratee = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/iteratee.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var identity$6 = require_identity();
	var property = require_property();
	var matches$1 = require_matches();
	var matchesProperty = require_matchesProperty();
	function iteratee$4(value) {
		if (value == null) return identity$6.identity;
		switch (typeof value) {
			case "function": return value;
			case "object":
				if (Array.isArray(value) && value.length === 2) return matchesProperty.matchesProperty(value[0], value[1]);
				return matches$1.matches(value);
			case "string":
			case "symbol":
			case "number": return property.property(value);
		}
	}
	exports.iteratee = iteratee$4;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/array/uniqBy.js
var require_uniqBy$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/array/uniqBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var uniqBy$1 = require_uniqBy$2();
	var identity$5 = require_identity();
	var isArrayLikeObject = require_isArrayLikeObject();
	var iteratee$3 = require_iteratee();
	function uniqBy$2(array, iteratee$1$1 = identity$5.identity) {
		if (!isArrayLikeObject.isArrayLikeObject(array)) return [];
		return uniqBy$1.uniqBy(Array.from(array), iteratee$3.iteratee(iteratee$1$1));
	}
	exports.uniqBy = uniqBy$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/uniqBy.js
var require_uniqBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/uniqBy.js": ((exports, module) => {
	module.exports = require_uniqBy$1().uniqBy;
}) });

//#endregion
//#region node_modules/recharts/es6/util/payload/getUniqPayload.js
var import_uniqBy = /* @__PURE__ */ __toESM(require_uniqBy());
/**
* This is configuration option that decides how to filter for unique values only:
*
* - `false` means "no filter"
* - `true` means "use recharts default filter"
* - function means "use return of this function as the default key"
*/
function getUniqPayload(payload, option, defaultUniqBy$2) {
	if (option === true) return (0, import_uniqBy.default)(payload, defaultUniqBy$2);
	if (typeof option === "function") return (0, import_uniqBy.default)(payload, option);
	return payload;
}

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js": ((exports) => {
	(function() {
		function is$1(x$1, y$1) {
			return x$1 === y$1 && (0 !== x$1 || 1 / x$1 === 1 / y$1) || x$1 !== x$1 && y$1 !== y$1;
		}
		function useSyncExternalStore$2(subscribe, getSnapshot) {
			didWarnOld18Alpha || void 0 === React.startTransition || (didWarnOld18Alpha = !0, console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
			var value = getSnapshot();
			if (!didWarnUncachedGetSnapshot) {
				var cachedValue = getSnapshot();
				objectIs(value, cachedValue) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
			}
			cachedValue = useState$21({ inst: {
				value,
				getSnapshot
			} });
			var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
			useLayoutEffect$5(function() {
				inst.value = value;
				inst.getSnapshot = getSnapshot;
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
			}, [
				subscribe,
				value,
				getSnapshot
			]);
			useEffect$23(function() {
				checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				return subscribe(function() {
					checkIfSnapshotChanged(inst) && forceUpdate({ inst });
				});
			}, [subscribe]);
			useDebugValue(value);
			return value;
		}
		function checkIfSnapshotChanged(inst) {
			var latestGetSnapshot = inst.getSnapshot;
			inst = inst.value;
			try {
				var nextValue = latestGetSnapshot();
				return !objectIs(inst, nextValue);
			} catch (error) {
				return !0;
			}
		}
		function useSyncExternalStore$1(subscribe, getSnapshot) {
			return getSnapshot();
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is$1, useState$21 = React.useState, useEffect$23 = React.useEffect, useLayoutEffect$5 = React.useLayoutEffect, useDebugValue = React.useDebugValue, didWarnOld18Alpha = !1, didWarnUncachedGetSnapshot = !1, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
		exports.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/index.js
var require_shim = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/index.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_shim_development();
}) });

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js": ((exports) => {
	(function() {
		function is$1(x$1, y$1) {
			return x$1 === y$1 && (0 !== x$1 || 1 / x$1 === 1 / y$1) || x$1 !== x$1 && y$1 !== y$1;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is$1, useSyncExternalStore = shim.useSyncExternalStore, useRef$20 = React.useRef, useEffect$23 = React.useEffect, useMemo$11 = React.useMemo, useDebugValue = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef$20(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo$11(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
			useEffect$23(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector$1 = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/shim/with-selector.js": ((exports, module) => {
	module.exports = require_with_selector_development();
}) });

//#endregion
//#region node_modules/recharts/es6/state/RechartsReduxContext.js
var import_with_selector$1 = /* @__PURE__ */ __toESM(require_with_selector$1());
/**
* We need to use our own independent Redux context because we need to avoid interfering with other people's Redux stores
* in case they decide to install and use Recharts in another Redux app which is likely to happen.
*
* https://react-redux.js.org/using-react-redux/accessing-store#providing-custom-context
*/
var RechartsReduxContext = /* @__PURE__ */ (0, import_react.createContext)(null);

//#endregion
//#region node_modules/recharts/es6/state/hooks.js
var noopDispatch = (a$1) => a$1;
var useAppDispatch = () => {
	var context = (0, import_react.useContext)(RechartsReduxContext);
	if (context) return context.store.dispatch;
	return noopDispatch;
};
var noop$4 = () => {};
var addNestedSubNoop = () => noop$4;
var refEquality = (a$1, b) => a$1 === b;
/**
* This is a recharts variant of `useSelector` from 'react-redux' package.
*
* The difference is that react-redux version will throw an Error when used outside of Redux context.
*
* This, recharts version, will return undefined instead.
*
* This is because we want to allow using our components outside the Chart wrapper,
* and have people provide all props explicitly.
*
* If however they use the component inside a chart wrapper then those props become optional,
* and we read them from Redux state instead.
*
* @param selector for pulling things out of Redux store; will not be called if the store is not accessible
* @return whatever the selector returned; or undefined when outside of Redux store
*/
function useAppSelector(selector) {
	var context = (0, import_react.useContext)(RechartsReduxContext);
	return (0, import_with_selector$1.useSyncExternalStoreWithSelector)(context ? context.subscription.addNestedSub : addNestedSubNoop, context ? context.store.getState : noop$4, context ? context.store.getState : noop$4, context ? selector : noop$4, refEquality);
}

//#endregion
//#region node_modules/reselect/dist/reselect.mjs
var runIdentityFunctionCheck = (resultFunc, inputSelectorsResults, outputSelectorResult) => {
	if (inputSelectorsResults.length === 1 && inputSelectorsResults[0] === outputSelectorResult) {
		let isInputSameAsOutput = false;
		try {
			const emptyObject = {};
			if (resultFunc(emptyObject) === emptyObject) isInputSameAsOutput = true;
		} catch {}
		if (isInputSameAsOutput) {
			let stack = void 0;
			try {
				throw new Error();
			} catch (e) {
				({stack} = e);
			}
			console.warn("The result function returned its own inputs without modification. e.g\n`createSelector([state => state.todos], todos => todos)`\nThis could lead to inefficient memoization and unnecessary re-renders.\nEnsure transformation logic is in the result function, and extraction logic is in the input selectors.", { stack });
		}
	}
};
var runInputStabilityCheck = (inputSelectorResultsObject, options$2, inputSelectorArgs) => {
	const { memoize: memoize$1, memoizeOptions } = options$2;
	const { inputSelectorResults, inputSelectorResultsCopy } = inputSelectorResultsObject;
	const createAnEmptyObject = memoize$1(() => ({}), ...memoizeOptions);
	if (!(createAnEmptyObject.apply(null, inputSelectorResults) === createAnEmptyObject.apply(null, inputSelectorResultsCopy))) {
		let stack = void 0;
		try {
			throw new Error();
		} catch (e) {
			({stack} = e);
		}
		console.warn("An input selector returned a different result when passed same arguments.\nThis means your output selector will likely run more frequently than intended.\nAvoid returning a new reference inside your input selector, e.g.\n`createSelector([state => state.todos.map(todo => todo.id)], todoIds => todoIds.length)`", {
			arguments: inputSelectorArgs,
			firstInputs: inputSelectorResults,
			secondInputs: inputSelectorResultsCopy,
			stack
		});
	}
};
var globalDevModeChecks = {
	inputStabilityCheck: "once",
	identityFunctionCheck: "once"
};
function assertIsFunction(func, errorMessage = `expected a function, instead received ${typeof func}`) {
	if (typeof func !== "function") throw new TypeError(errorMessage);
}
function assertIsObject(object, errorMessage = `expected an object, instead received ${typeof object}`) {
	if (typeof object !== "object") throw new TypeError(errorMessage);
}
function assertIsArrayOfFunctions(array, errorMessage = `expected all items to be functions, instead received the following types: `) {
	if (!array.every((item) => typeof item === "function")) {
		const itemTypes = array.map((item) => typeof item === "function" ? `function ${item.name || "unnamed"}()` : typeof item).join(", ");
		throw new TypeError(`${errorMessage}[${itemTypes}]`);
	}
}
var ensureIsArray = (item) => {
	return Array.isArray(item) ? item : [item];
};
function getDependencies(createSelectorArgs) {
	const dependencies = Array.isArray(createSelectorArgs[0]) ? createSelectorArgs[0] : createSelectorArgs;
	assertIsArrayOfFunctions(dependencies, `createSelector expects all input-selectors to be functions, but received the following types: `);
	return dependencies;
}
function collectInputSelectorResults(dependencies, inputSelectorArgs) {
	const inputSelectorResults = [];
	const { length } = dependencies;
	for (let i = 0; i < length; i++) inputSelectorResults.push(dependencies[i].apply(null, inputSelectorArgs));
	return inputSelectorResults;
}
var getDevModeChecksExecutionInfo = (firstRun, devModeChecks) => {
	const { identityFunctionCheck, inputStabilityCheck } = {
		...globalDevModeChecks,
		...devModeChecks
	};
	return {
		identityFunctionCheck: {
			shouldRun: identityFunctionCheck === "always" || identityFunctionCheck === "once" && firstRun,
			run: runIdentityFunctionCheck
		},
		inputStabilityCheck: {
			shouldRun: inputStabilityCheck === "always" || inputStabilityCheck === "once" && firstRun,
			run: runInputStabilityCheck
		}
	};
};
var proto = Object.getPrototypeOf({});
var StrongRef = class {
	constructor(value) {
		this.value = value;
	}
	deref() {
		return this.value;
	}
};
var Ref = typeof WeakRef !== "undefined" ? WeakRef : StrongRef;
var UNTERMINATED = 0;
var TERMINATED = 1;
function createCacheNode() {
	return {
		s: UNTERMINATED,
		v: void 0,
		o: null,
		p: null
	};
}
function weakMapMemoize(func, options$2 = {}) {
	let fnNode = createCacheNode();
	const { resultEqualityCheck } = options$2;
	let lastResult$1;
	let resultsCount = 0;
	function memoized() {
		let cacheNode = fnNode;
		const { length } = arguments;
		for (let i = 0, l = length; i < l; i++) {
			const arg = arguments[i];
			if (typeof arg === "function" || typeof arg === "object" && arg !== null) {
				let objectCache = cacheNode.o;
				if (objectCache === null) cacheNode.o = objectCache = /* @__PURE__ */ new WeakMap();
				const objectNode = objectCache.get(arg);
				if (objectNode === void 0) {
					cacheNode = createCacheNode();
					objectCache.set(arg, cacheNode);
				} else cacheNode = objectNode;
			} else {
				let primitiveCache = cacheNode.p;
				if (primitiveCache === null) cacheNode.p = primitiveCache = /* @__PURE__ */ new Map();
				const primitiveNode = primitiveCache.get(arg);
				if (primitiveNode === void 0) {
					cacheNode = createCacheNode();
					primitiveCache.set(arg, cacheNode);
				} else cacheNode = primitiveNode;
			}
		}
		const terminatedNode = cacheNode;
		let result;
		if (cacheNode.s === TERMINATED) result = cacheNode.v;
		else {
			result = func.apply(null, arguments);
			resultsCount++;
			if (resultEqualityCheck) {
				const lastResultValue = lastResult$1?.deref?.() ?? lastResult$1;
				if (lastResultValue != null && resultEqualityCheck(lastResultValue, result)) {
					result = lastResultValue;
					resultsCount !== 0 && resultsCount--;
				}
				lastResult$1 = typeof result === "object" && result !== null || typeof result === "function" ? new Ref(result) : result;
			}
		}
		terminatedNode.s = TERMINATED;
		terminatedNode.v = result;
		return result;
	}
	memoized.clearCache = () => {
		fnNode = createCacheNode();
		memoized.resetResultsCount();
	};
	memoized.resultsCount = () => resultsCount;
	memoized.resetResultsCount = () => {
		resultsCount = 0;
	};
	return memoized;
}
function createSelectorCreator(memoizeOrOptions, ...memoizeOptionsFromArgs) {
	const createSelectorCreatorOptions = typeof memoizeOrOptions === "function" ? {
		memoize: memoizeOrOptions,
		memoizeOptions: memoizeOptionsFromArgs
	} : memoizeOrOptions;
	const createSelector2 = (...createSelectorArgs) => {
		let recomputations = 0;
		let dependencyRecomputations = 0;
		let lastResult$1;
		let directlyPassedOptions = {};
		let resultFunc = createSelectorArgs.pop();
		if (typeof resultFunc === "object") {
			directlyPassedOptions = resultFunc;
			resultFunc = createSelectorArgs.pop();
		}
		assertIsFunction(resultFunc, `createSelector expects an output function after the inputs, but received: [${typeof resultFunc}]`);
		const { memoize: memoize$1, memoizeOptions = [], argsMemoize = weakMapMemoize, argsMemoizeOptions = [], devModeChecks = {} } = {
			...createSelectorCreatorOptions,
			...directlyPassedOptions
		};
		const finalMemoizeOptions = ensureIsArray(memoizeOptions);
		const finalArgsMemoizeOptions = ensureIsArray(argsMemoizeOptions);
		const dependencies = getDependencies(createSelectorArgs);
		const memoizedResultFunc = memoize$1(function recomputationWrapper() {
			recomputations++;
			return resultFunc.apply(null, arguments);
		}, ...finalMemoizeOptions);
		let firstRun = true;
		const selector = argsMemoize(function dependenciesChecker() {
			dependencyRecomputations++;
			const inputSelectorResults = collectInputSelectorResults(dependencies, arguments);
			lastResult$1 = memoizedResultFunc.apply(null, inputSelectorResults);
			{
				const { identityFunctionCheck, inputStabilityCheck } = getDevModeChecksExecutionInfo(firstRun, devModeChecks);
				if (identityFunctionCheck.shouldRun) identityFunctionCheck.run(resultFunc, inputSelectorResults, lastResult$1);
				if (inputStabilityCheck.shouldRun) {
					const inputSelectorResultsCopy = collectInputSelectorResults(dependencies, arguments);
					inputStabilityCheck.run({
						inputSelectorResults,
						inputSelectorResultsCopy
					}, {
						memoize: memoize$1,
						memoizeOptions: finalMemoizeOptions
					}, arguments);
				}
				if (firstRun) firstRun = false;
			}
			return lastResult$1;
		}, ...finalArgsMemoizeOptions);
		return Object.assign(selector, {
			resultFunc,
			memoizedResultFunc,
			dependencies,
			dependencyRecomputations: () => dependencyRecomputations,
			resetDependencyRecomputations: () => {
				dependencyRecomputations = 0;
			},
			lastResult: () => lastResult$1,
			recomputations: () => recomputations,
			resetRecomputations: () => {
				recomputations = 0;
			},
			memoize: memoize$1,
			argsMemoize
		});
	};
	Object.assign(createSelector2, { withTypes: () => createSelector2 });
	return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(weakMapMemoize);
var createStructuredSelector = Object.assign((inputSelectorsObject, selectorCreator = createSelector) => {
	assertIsObject(inputSelectorsObject, `createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ${typeof inputSelectorsObject}`);
	const inputSelectorKeys = Object.keys(inputSelectorsObject);
	const dependencies = inputSelectorKeys.map((key) => inputSelectorsObject[key]);
	return selectorCreator(dependencies, (...inputSelectorResults) => {
		return inputSelectorResults.reduce((composition, value, index) => {
			composition[inputSelectorKeys[index]] = value;
			return composition;
		}, {});
	});
}, { withTypes: () => createStructuredSelector });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/compareValues.js
var require_compareValues = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/compareValues.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function getPriority(a$1) {
		if (typeof a$1 === "symbol") return 1;
		if (a$1 === null) return 2;
		if (a$1 === void 0) return 3;
		if (a$1 !== a$1) return 4;
		return 0;
	}
	var compareValues$1 = (a$1, b, order) => {
		if (a$1 !== b) {
			const aPriority = getPriority(a$1);
			const bPriority = getPriority(b);
			if (aPriority === bPriority && aPriority === 0) {
				if (a$1 < b) return order === "desc" ? 1 : -1;
				if (a$1 > b) return order === "desc" ? -1 : 1;
			}
			return order === "desc" ? bPriority - aPriority : aPriority - bPriority;
		}
		return 0;
	};
	exports.compareValues = compareValues$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isSymbol.js
var require_isSymbol = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isSymbol.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isSymbol$2(value) {
		return typeof value === "symbol" || value instanceof Symbol;
	}
	exports.isSymbol = isSymbol$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/isKey.js
var require_isKey = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/isKey.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isSymbol$1 = require_isSymbol();
	var regexIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
	var regexIsPlainProp = /^\w*$/;
	function isKey$1(value, object) {
		if (Array.isArray(value)) return false;
		if (typeof value === "number" || typeof value === "boolean" || value == null || isSymbol$1.isSymbol(value)) return true;
		return typeof value === "string" && (regexIsPlainProp.test(value) || !regexIsDeepProp.test(value)) || object != null && Object.hasOwn(object, value);
	}
	exports.isKey = isKey$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/array/orderBy.js
var require_orderBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/array/orderBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var compareValues = require_compareValues();
	var isKey = require_isKey();
	var toPath$1 = require_toPath();
	function orderBy$1(collection, criteria, orders, guard) {
		if (collection == null) return [];
		orders = guard ? void 0 : orders;
		if (!Array.isArray(collection)) collection = Object.values(collection);
		if (!Array.isArray(criteria)) criteria = criteria == null ? [null] : [criteria];
		if (criteria.length === 0) criteria = [null];
		if (!Array.isArray(orders)) orders = orders == null ? [] : [orders];
		orders = orders.map((order) => String(order));
		const getValueByNestedPath = (object, path$1) => {
			let target = object;
			for (let i = 0; i < path$1.length && target != null; ++i) target = target[path$1[i]];
			return target;
		};
		const getValueByCriterion = (criterion, object) => {
			if (object == null || criterion == null) return object;
			if (typeof criterion === "object" && "key" in criterion) {
				if (Object.hasOwn(object, criterion.key)) return object[criterion.key];
				return getValueByNestedPath(object, criterion.path);
			}
			if (typeof criterion === "function") return criterion(object);
			if (Array.isArray(criterion)) return getValueByNestedPath(object, criterion);
			if (typeof object === "object") return object[criterion];
			return object;
		};
		const preparedCriteria = criteria.map((criterion) => {
			if (Array.isArray(criterion) && criterion.length === 1) criterion = criterion[0];
			if (criterion == null || typeof criterion === "function" || Array.isArray(criterion) || isKey.isKey(criterion)) return criterion;
			return {
				key: criterion,
				path: toPath$1.toPath(criterion)
			};
		});
		return collection.map((item) => ({
			original: item,
			criteria: preparedCriteria.map((criterion) => getValueByCriterion(criterion, item))
		})).slice().sort((a$1, b) => {
			for (let i = 0; i < preparedCriteria.length; i++) {
				const comparedResult = compareValues.compareValues(a$1.criteria[i], b.criteria[i], orders[i]);
				if (comparedResult !== 0) return comparedResult;
			}
			return 0;
		}).map((item) => item.original);
	}
	exports.orderBy = orderBy$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/array/flatten.js
var require_flatten$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/array/flatten.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function flatten$3(arr, depth = 1) {
		const result = [];
		const flooredDepth = Math.floor(depth);
		const recursive = (arr$1, currentDepth) => {
			for (let i = 0; i < arr$1.length; i++) {
				const item = arr$1[i];
				if (Array.isArray(item) && currentDepth < flooredDepth) recursive(item, currentDepth + 1);
				else result.push(item);
			}
		};
		recursive(arr, 0);
		return result;
	}
	exports.flatten = flatten$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js
var require_isIterateeCall = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/isIterateeCall.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isIndex = require_isIndex();
	var isArrayLike$3 = require_isArrayLike();
	var isObject = require_isObject();
	var eq = require_eq();
	function isIterateeCall$2(value, index, object) {
		if (!isObject.isObject(object)) return false;
		if (typeof index === "number" && isArrayLike$3.isArrayLike(object) && isIndex.isIndex(index) && index < object.length || typeof index === "string" && index in object) return eq.eq(object[index], value);
		return false;
	}
	exports.isIterateeCall = isIterateeCall$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/array/sortBy.js
var require_sortBy$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/array/sortBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var orderBy = require_orderBy();
	var flatten$2 = require_flatten$1();
	var isIterateeCall$1 = require_isIterateeCall();
	function sortBy$4(collection, ...criteria) {
		const length = criteria.length;
		if (length > 1 && isIterateeCall$1.isIterateeCall(collection, criteria[0], criteria[1])) criteria = [];
		else if (length > 2 && isIterateeCall$1.isIterateeCall(criteria[0], criteria[1], criteria[2])) criteria = [criteria[0]];
		return orderBy.orderBy(collection, flatten$2.flatten(criteria), ["asc"]);
	}
	exports.sortBy = sortBy$4;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/sortBy.js
var require_sortBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/sortBy.js": ((exports, module) => {
	module.exports = require_sortBy$1().sortBy;
}) });

//#endregion
//#region node_modules/recharts/es6/state/selectors/legendSelectors.js
var import_sortBy$3 = /* @__PURE__ */ __toESM(require_sortBy());
var selectLegendSettings = (state) => state.legend.settings;
var selectLegendSize = (state) => state.legend.size;
var selectAllLegendPayload2DArray = (state) => state.legend.payload;
var selectLegendPayload = createSelector([selectAllLegendPayload2DArray, selectLegendSettings], (payloads, _ref$1) => {
	var { itemSorter } = _ref$1;
	var flat = payloads.flat(1);
	return itemSorter ? (0, import_sortBy$3.default)(flat, itemSorter) : flat;
});

//#endregion
//#region node_modules/recharts/es6/context/legendPayloadContext.js
/**
* Use this hook in Legend, or anywhere else where you want to read the current Legend items.
* @return all Legend items ready to be rendered
*/
function useLegendPayload() {
	return useAppSelector(selectLegendPayload);
}

//#endregion
//#region node_modules/recharts/es6/util/useElementOffset.js
var EPS$1 = 1;
/**
* TODO this documentation does not reflect what this hook is doing, update it.
* Stores the `offsetHeight`, `offsetLeft`, `offsetTop`, and `offsetWidth` of a DOM element.
*/
/**
* Use this to listen to element layout changes.
*
* Very useful for reading actual sizes of DOM elements relative to the viewport.
*
* @param extraDependencies use this to trigger new DOM dimensions read when any of these change. Good for things like payload and label, that will re-render something down in the children array, but you want to read the layout box of a parent.
* @returns [lastElementOffset, updateElementOffset] most recent value, and setter. Pass the setter to a DOM element ref like this: `<div ref={updateElementOffset}>`
*/
function useElementOffset() {
	var extraDependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var [lastBoundingBox, setLastBoundingBox] = (0, import_react.useState)({
		height: 0,
		left: 0,
		top: 0,
		width: 0
	});
	var updateBoundingBox = (0, import_react.useCallback)((node) => {
		if (node != null) {
			var rect = node.getBoundingClientRect();
			var box = {
				height: rect.height,
				left: rect.left,
				top: rect.top,
				width: rect.width
			};
			if (Math.abs(box.height - lastBoundingBox.height) > EPS$1 || Math.abs(box.left - lastBoundingBox.left) > EPS$1 || Math.abs(box.top - lastBoundingBox.top) > EPS$1 || Math.abs(box.width - lastBoundingBox.width) > EPS$1) setLastBoundingBox({
				height: box.height,
				left: box.left,
				top: box.top,
				width: box.width
			});
		}
	}, [
		lastBoundingBox.width,
		lastBoundingBox.height,
		lastBoundingBox.top,
		lastBoundingBox.left,
		...extraDependencies
	]);
	return [lastBoundingBox, updateBoundingBox];
}

//#endregion
//#region node_modules/redux/dist/redux.mjs
var symbol_observable_default = /* @__PURE__ */ (() => typeof Symbol === "function" && Symbol.observable || "@@observable")();
var randomString = () => Math.random().toString(36).substring(7).split("").join(".");
var actionTypes_default = {
	INIT: `@@redux/INIT${/* @__PURE__ */ randomString()}`,
	REPLACE: `@@redux/REPLACE${/* @__PURE__ */ randomString()}`,
	PROBE_UNKNOWN_ACTION: () => `@@redux/PROBE_UNKNOWN_ACTION${randomString()}`
};
function isPlainObject$3(obj) {
	if (typeof obj !== "object" || obj === null) return false;
	let proto$1 = obj;
	while (Object.getPrototypeOf(proto$1) !== null) proto$1 = Object.getPrototypeOf(proto$1);
	return Object.getPrototypeOf(obj) === proto$1 || Object.getPrototypeOf(obj) === null;
}
function miniKindOf(val) {
	if (val === void 0) return "undefined";
	if (val === null) return "null";
	const type = typeof val;
	switch (type) {
		case "boolean":
		case "string":
		case "number":
		case "symbol":
		case "function": return type;
	}
	if (Array.isArray(val)) return "array";
	if (isDate(val)) return "date";
	if (isError(val)) return "error";
	const constructorName = ctorName(val);
	switch (constructorName) {
		case "Symbol":
		case "Promise":
		case "WeakMap":
		case "WeakSet":
		case "Map":
		case "Set": return constructorName;
	}
	return Object.prototype.toString.call(val).slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
	return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
	return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
	if (val instanceof Date) return true;
	return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
	let typeOfVal = typeof val;
	typeOfVal = miniKindOf(val);
	return typeOfVal;
}
function createStore(reducer, preloadedState$1, enhancer) {
	if (typeof reducer !== "function") throw new Error(`Expected the root reducer to be a function. Instead, received: '${kindOf(reducer)}'`);
	if (typeof preloadedState$1 === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") throw new Error("It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
	if (typeof preloadedState$1 === "function" && typeof enhancer === "undefined") {
		enhancer = preloadedState$1;
		preloadedState$1 = void 0;
	}
	if (typeof enhancer !== "undefined") {
		if (typeof enhancer !== "function") throw new Error(`Expected the enhancer to be a function. Instead, received: '${kindOf(enhancer)}'`);
		return enhancer(createStore)(reducer, preloadedState$1);
	}
	let currentReducer = reducer;
	let currentState = preloadedState$1;
	let currentListeners = /* @__PURE__ */ new Map();
	let nextListeners = currentListeners;
	let listenerIdCounter = 0;
	let isDispatching = false;
	function ensureCanMutateNextListeners() {
		if (nextListeners === currentListeners) {
			nextListeners = /* @__PURE__ */ new Map();
			currentListeners.forEach((listener$1, key) => {
				nextListeners.set(key, listener$1);
			});
		}
	}
	function getState() {
		if (isDispatching) throw new Error("You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
		return currentState;
	}
	function subscribe(listener$1) {
		if (typeof listener$1 !== "function") throw new Error(`Expected the listener to be a function. Instead, received: '${kindOf(listener$1)}'`);
		if (isDispatching) throw new Error("You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
		let isSubscribed = true;
		ensureCanMutateNextListeners();
		const listenerId = listenerIdCounter++;
		nextListeners.set(listenerId, listener$1);
		return function unsubscribe() {
			if (!isSubscribed) return;
			if (isDispatching) throw new Error("You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
			isSubscribed = false;
			ensureCanMutateNextListeners();
			nextListeners.delete(listenerId);
			currentListeners = null;
		};
	}
	function dispatch(action) {
		if (!isPlainObject$3(action)) throw new Error(`Actions must be plain objects. Instead, the actual type was: '${kindOf(action)}'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.`);
		if (typeof action.type === "undefined") throw new Error("Actions may not have an undefined \"type\" property. You may have misspelled an action type string constant.");
		if (typeof action.type !== "string") throw new Error(`Action "type" property must be a string. Instead, the actual type was: '${kindOf(action.type)}'. Value was: '${action.type}' (stringified)`);
		if (isDispatching) throw new Error("Reducers may not dispatch actions.");
		try {
			isDispatching = true;
			currentState = currentReducer(currentState, action);
		} finally {
			isDispatching = false;
		}
		(currentListeners = nextListeners).forEach((listener$1) => {
			listener$1();
		});
		return action;
	}
	function replaceReducer(nextReducer) {
		if (typeof nextReducer !== "function") throw new Error(`Expected the nextReducer to be a function. Instead, received: '${kindOf(nextReducer)}`);
		currentReducer = nextReducer;
		dispatch({ type: actionTypes_default.REPLACE });
	}
	function observable() {
		const outerSubscribe = subscribe;
		return {
			subscribe(observer) {
				if (typeof observer !== "object" || observer === null) throw new Error(`Expected the observer to be an object. Instead, received: '${kindOf(observer)}'`);
				function observeState() {
					const observerAsObserver = observer;
					if (observerAsObserver.next) observerAsObserver.next(getState());
				}
				observeState();
				return { unsubscribe: outerSubscribe(observeState) };
			},
			[symbol_observable_default]() {
				return this;
			}
		};
	}
	dispatch({ type: actionTypes_default.INIT });
	return {
		dispatch,
		subscribe,
		getState,
		replaceReducer,
		[symbol_observable_default]: observable
	};
}
function warning(message) {
	if (typeof console !== "undefined" && typeof console.error === "function") console.error(message);
	try {
		throw new Error(message);
	} catch (e) {}
}
function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
	const reducerKeys = Object.keys(reducers);
	const argumentName = action && action.type === actionTypes_default.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
	if (reducerKeys.length === 0) return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
	if (!isPlainObject$3(inputState)) return `The ${argumentName} has unexpected type of "${kindOf(inputState)}". Expected argument to be an object with the following keys: "${reducerKeys.join("\", \"")}"`;
	const unexpectedKeys = Object.keys(inputState).filter((key) => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key]);
	unexpectedKeys.forEach((key) => {
		unexpectedKeyCache[key] = true;
	});
	if (action && action.type === actionTypes_default.REPLACE) return;
	if (unexpectedKeys.length > 0) return `Unexpected ${unexpectedKeys.length > 1 ? "keys" : "key"} "${unexpectedKeys.join("\", \"")}" found in ${argumentName}. Expected to find one of the known reducer keys instead: "${reducerKeys.join("\", \"")}". Unexpected keys will be ignored.`;
}
function assertReducerShape(reducers) {
	Object.keys(reducers).forEach((key) => {
		const reducer = reducers[key];
		if (typeof reducer(void 0, { type: actionTypes_default.INIT }) === "undefined") throw new Error(`The slice reducer for key "${key}" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
		if (typeof reducer(void 0, { type: actionTypes_default.PROBE_UNKNOWN_ACTION() }) === "undefined") throw new Error(`The slice reducer for key "${key}" returned undefined when probed with a random type. Don't try to handle '${actionTypes_default.INIT}' or other actions in "redux/*" namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.`);
	});
}
function combineReducers(reducers) {
	const reducerKeys = Object.keys(reducers);
	const finalReducers = {};
	for (let i = 0; i < reducerKeys.length; i++) {
		const key = reducerKeys[i];
		if (typeof reducers[key] === "undefined") warning(`No reducer provided for key "${key}"`);
		if (typeof reducers[key] === "function") finalReducers[key] = reducers[key];
	}
	const finalReducerKeys = Object.keys(finalReducers);
	let unexpectedKeyCache = {};
	let shapeAssertionError;
	try {
		assertReducerShape(finalReducers);
	} catch (e) {
		shapeAssertionError = e;
	}
	return function combination(state = {}, action) {
		if (shapeAssertionError) throw shapeAssertionError;
		{
			const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
			if (warningMessage) warning(warningMessage);
		}
		let hasChanged = false;
		const nextState = {};
		for (let i = 0; i < finalReducerKeys.length; i++) {
			const key = finalReducerKeys[i];
			const reducer = finalReducers[key];
			const previousStateForKey = state[key];
			const nextStateForKey = reducer(previousStateForKey, action);
			if (typeof nextStateForKey === "undefined") {
				const actionType = action && action.type;
				throw new Error(`When called with an action of type ${actionType ? `"${String(actionType)}"` : "(unknown type)"}, the slice reducer for key "${key}" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.`);
			}
			nextState[key] = nextStateForKey;
			hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
		}
		hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
		return hasChanged ? nextState : state;
	};
}
function compose$1(...funcs) {
	if (funcs.length === 0) return (arg) => arg;
	if (funcs.length === 1) return funcs[0];
	return funcs.reduce((a$1, b) => (...args) => a$1(b(...args)));
}
function applyMiddleware(...middlewares) {
	return (createStore2) => (reducer, preloadedState$1) => {
		const store = createStore2(reducer, preloadedState$1);
		let dispatch = () => {
			throw new Error("Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
		};
		const middlewareAPI = {
			getState: store.getState,
			dispatch: (action, ...args) => dispatch(action, ...args)
		};
		const chain = middlewares.map((middleware) => middleware(middlewareAPI));
		dispatch = compose$1(...chain)(store.dispatch);
		return {
			...store,
			dispatch
		};
	};
}
function isAction(action) {
	return isPlainObject$3(action) && "type" in action && typeof action.type === "string";
}

//#endregion
//#region node_modules/immer/dist/immer.mjs
var NOTHING = Symbol.for("immer-nothing");
var DRAFTABLE = Symbol.for("immer-draftable");
var DRAFT_STATE = Symbol.for("immer-state");
var errors = [
	function(plugin) {
		return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \`enable${plugin}()\` when initializing your application.`;
	},
	function(thing) {
		return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;
	},
	"This object has been frozen and should not be mutated",
	function(data) {
		return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + data;
	},
	"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
	"Immer forbids circular references",
	"The first or second argument to `produce` must be a function",
	"The third argument to `produce` must be a function or undefined",
	"First argument to `createDraft` must be a plain object, an array, or an immerable object",
	"First argument to `finishDraft` must be a draft returned by `createDraft`",
	function(thing) {
		return `'current' expects a draft, got: ${thing}`;
	},
	"Object.defineProperty() cannot be used on an Immer draft",
	"Object.setPrototypeOf() cannot be used on an Immer draft",
	"Immer only supports deleting array indices",
	"Immer only supports setting array indices and the 'length' property",
	function(thing) {
		return `'original' expects a draft, got: ${thing}`;
	}
];
function die(error, ...args) {
	{
		const e = errors[error];
		const msg = typeof e === "function" ? e.apply(null, args) : e;
		throw new Error(`[Immer] ${msg}`);
	}
	throw new Error(`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`);
}
var getPrototypeOf = Object.getPrototypeOf;
function isDraft(value) {
	return !!value && !!value[DRAFT_STATE];
}
function isDraftable(value) {
	if (!value) return false;
	return isPlainObject$4(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);
}
var objectCtorString = Object.prototype.constructor.toString();
function isPlainObject$4(value) {
	if (!value || typeof value !== "object") return false;
	const proto$1 = getPrototypeOf(value);
	if (proto$1 === null) return true;
	const Ctor = Object.hasOwnProperty.call(proto$1, "constructor") && proto$1.constructor;
	if (Ctor === Object) return true;
	return typeof Ctor == "function" && Function.toString.call(Ctor) === objectCtorString;
}
function each(obj, iter) {
	if (getArchtype(obj) === 0) Reflect.ownKeys(obj).forEach((key) => {
		iter(key, obj[key], obj);
	});
	else obj.forEach((entry, index) => iter(index, entry, obj));
}
function getArchtype(thing) {
	const state = thing[DRAFT_STATE];
	return state ? state.type_ : Array.isArray(thing) ? 1 : isMap(thing) ? 2 : isSet(thing) ? 3 : 0;
}
function has$1(thing, prop) {
	return getArchtype(thing) === 2 ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);
}
function set(thing, propOrOldValue, value) {
	const t = getArchtype(thing);
	if (t === 2) thing.set(propOrOldValue, value);
	else if (t === 3) thing.add(value);
	else thing[propOrOldValue] = value;
}
function is(x$1, y$1) {
	if (x$1 === y$1) return x$1 !== 0 || 1 / x$1 === 1 / y$1;
	else return x$1 !== x$1 && y$1 !== y$1;
}
function isMap(target) {
	return target instanceof Map;
}
function isSet(target) {
	return target instanceof Set;
}
function latest(state) {
	return state.copy_ || state.base_;
}
function shallowCopy(base, strict) {
	if (isMap(base)) return new Map(base);
	if (isSet(base)) return new Set(base);
	if (Array.isArray(base)) return Array.prototype.slice.call(base);
	const isPlain$1 = isPlainObject$4(base);
	if (strict === true || strict === "class_only" && !isPlain$1) {
		const descriptors = Object.getOwnPropertyDescriptors(base);
		delete descriptors[DRAFT_STATE];
		let keys = Reflect.ownKeys(descriptors);
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			const desc = descriptors[key];
			if (desc.writable === false) {
				desc.writable = true;
				desc.configurable = true;
			}
			if (desc.get || desc.set) descriptors[key] = {
				configurable: true,
				writable: true,
				enumerable: desc.enumerable,
				value: base[key]
			};
		}
		return Object.create(getPrototypeOf(base), descriptors);
	} else {
		const proto$1 = getPrototypeOf(base);
		if (proto$1 !== null && isPlain$1) return { ...base };
		const obj = Object.create(proto$1);
		return Object.assign(obj, base);
	}
}
function freeze(obj, deep = false) {
	if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj;
	if (getArchtype(obj) > 1) Object.defineProperties(obj, {
		set: { value: dontMutateFrozenCollections },
		add: { value: dontMutateFrozenCollections },
		clear: { value: dontMutateFrozenCollections },
		delete: { value: dontMutateFrozenCollections }
	});
	Object.freeze(obj);
	if (deep) Object.values(obj).forEach((value) => freeze(value, true));
	return obj;
}
function dontMutateFrozenCollections() {
	die(2);
}
function isFrozen(obj) {
	return Object.isFrozen(obj);
}
var plugins = {};
function getPlugin(pluginKey) {
	const plugin = plugins[pluginKey];
	if (!plugin) die(0, pluginKey);
	return plugin;
}
var currentScope;
function getCurrentScope() {
	return currentScope;
}
function createScope(parent_, immer_) {
	return {
		drafts_: [],
		parent_,
		immer_,
		canAutoFreeze_: true,
		unfinalizedDrafts_: 0
	};
}
function usePatchesInScope(scope, patchListener) {
	if (patchListener) {
		getPlugin("Patches");
		scope.patches_ = [];
		scope.inversePatches_ = [];
		scope.patchListener_ = patchListener;
	}
}
function revokeScope(scope) {
	leaveScope(scope);
	scope.drafts_.forEach(revokeDraft);
	scope.drafts_ = null;
}
function leaveScope(scope) {
	if (scope === currentScope) currentScope = scope.parent_;
}
function enterScope(immer2) {
	return currentScope = createScope(currentScope, immer2);
}
function revokeDraft(draft) {
	const state = draft[DRAFT_STATE];
	if (state.type_ === 0 || state.type_ === 1) state.revoke_();
	else state.revoked_ = true;
}
function processResult(result, scope) {
	scope.unfinalizedDrafts_ = scope.drafts_.length;
	const baseDraft = scope.drafts_[0];
	if (result !== void 0 && result !== baseDraft) {
		if (baseDraft[DRAFT_STATE].modified_) {
			revokeScope(scope);
			die(4);
		}
		if (isDraftable(result)) {
			result = finalize(scope, result);
			if (!scope.parent_) maybeFreeze(scope, result);
		}
		if (scope.patches_) getPlugin("Patches").generateReplacementPatches_(baseDraft[DRAFT_STATE].base_, result, scope.patches_, scope.inversePatches_);
	} else result = finalize(scope, baseDraft, []);
	revokeScope(scope);
	if (scope.patches_) scope.patchListener_(scope.patches_, scope.inversePatches_);
	return result !== NOTHING ? result : void 0;
}
function finalize(rootScope, value, path$1) {
	if (isFrozen(value)) return value;
	const state = value[DRAFT_STATE];
	if (!state) {
		each(value, (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path$1));
		return value;
	}
	if (state.scope_ !== rootScope) return value;
	if (!state.modified_) {
		maybeFreeze(rootScope, state.base_, true);
		return state.base_;
	}
	if (!state.finalized_) {
		state.finalized_ = true;
		state.scope_.unfinalizedDrafts_--;
		const result = state.copy_;
		let resultEach = result;
		let isSet2 = false;
		if (state.type_ === 3) {
			resultEach = new Set(result);
			result.clear();
			isSet2 = true;
		}
		each(resultEach, (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path$1, isSet2));
		maybeFreeze(rootScope, result, false);
		if (path$1 && rootScope.patches_) getPlugin("Patches").generatePatches_(state, path$1, rootScope.patches_, rootScope.inversePatches_);
	}
	return state.copy_;
}
function finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {
	if (childValue === targetObject) die(5);
	if (isDraft(childValue)) {
		const path$1 = rootPath && parentState && parentState.type_ !== 3 && !has$1(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;
		const res = finalize(rootScope, childValue, path$1);
		set(targetObject, prop, res);
		if (isDraft(res)) rootScope.canAutoFreeze_ = false;
		else return;
	} else if (targetIsSet) targetObject.add(childValue);
	if (isDraftable(childValue) && !isFrozen(childValue)) {
		if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) return;
		finalize(rootScope, childValue);
		if ((!parentState || !parentState.scope_.parent_) && typeof prop !== "symbol" && (isMap(targetObject) ? targetObject.has(prop) : Object.prototype.propertyIsEnumerable.call(targetObject, prop))) maybeFreeze(rootScope, childValue);
	}
}
function maybeFreeze(scope, value, deep = false) {
	if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) freeze(value, deep);
}
function createProxyProxy(base, parent) {
	const isArray = Array.isArray(base);
	const state = {
		type_: isArray ? 1 : 0,
		scope_: parent ? parent.scope_ : getCurrentScope(),
		modified_: false,
		finalized_: false,
		assigned_: {},
		parent_: parent,
		base_: base,
		draft_: null,
		copy_: null,
		revoke_: null,
		isManual_: false
	};
	let target = state;
	let traps = objectTraps;
	if (isArray) {
		target = [state];
		traps = arrayTraps;
	}
	const { revoke, proxy } = Proxy.revocable(target, traps);
	state.draft_ = proxy;
	state.revoke_ = revoke;
	return proxy;
}
var objectTraps = {
	get(state, prop) {
		if (prop === DRAFT_STATE) return state;
		const source = latest(state);
		if (!has$1(source, prop)) return readPropFromProto(state, source, prop);
		const value = source[prop];
		if (state.finalized_ || !isDraftable(value)) return value;
		if (value === peek(state.base_, prop)) {
			prepareCopy(state);
			return state.copy_[prop] = createProxy(value, state);
		}
		return value;
	},
	has(state, prop) {
		return prop in latest(state);
	},
	ownKeys(state) {
		return Reflect.ownKeys(latest(state));
	},
	set(state, prop, value) {
		const desc = getDescriptorFromProto(latest(state), prop);
		if (desc?.set) {
			desc.set.call(state.draft_, value);
			return true;
		}
		if (!state.modified_) {
			const current2 = peek(latest(state), prop);
			const currentState = current2?.[DRAFT_STATE];
			if (currentState && currentState.base_ === value) {
				state.copy_[prop] = value;
				state.assigned_[prop] = false;
				return true;
			}
			if (is(value, current2) && (value !== void 0 || has$1(state.base_, prop))) return true;
			prepareCopy(state);
			markChanged(state);
		}
		if (state.copy_[prop] === value && (value !== void 0 || prop in state.copy_) || Number.isNaN(value) && Number.isNaN(state.copy_[prop])) return true;
		state.copy_[prop] = value;
		state.assigned_[prop] = true;
		return true;
	},
	deleteProperty(state, prop) {
		if (peek(state.base_, prop) !== void 0 || prop in state.base_) {
			state.assigned_[prop] = false;
			prepareCopy(state);
			markChanged(state);
		} else delete state.assigned_[prop];
		if (state.copy_) delete state.copy_[prop];
		return true;
	},
	getOwnPropertyDescriptor(state, prop) {
		const owner = latest(state);
		const desc = Reflect.getOwnPropertyDescriptor(owner, prop);
		if (!desc) return desc;
		return {
			writable: true,
			configurable: state.type_ !== 1 || prop !== "length",
			enumerable: desc.enumerable,
			value: owner[prop]
		};
	},
	defineProperty() {
		die(11);
	},
	getPrototypeOf(state) {
		return getPrototypeOf(state.base_);
	},
	setPrototypeOf() {
		die(12);
	}
};
var arrayTraps = {};
each(objectTraps, (key, fn) => {
	arrayTraps[key] = function() {
		arguments[0] = arguments[0][0];
		return fn.apply(this, arguments);
	};
});
arrayTraps.deleteProperty = function(state, prop) {
	if (isNaN(parseInt(prop))) die(13);
	return arrayTraps.set.call(this, state, prop, void 0);
};
arrayTraps.set = function(state, prop, value) {
	if (prop !== "length" && isNaN(parseInt(prop))) die(14);
	return objectTraps.set.call(this, state[0], prop, value, state[0]);
};
function peek(draft, prop) {
	const state = draft[DRAFT_STATE];
	return (state ? latest(state) : draft)[prop];
}
function readPropFromProto(state, source, prop) {
	const desc = getDescriptorFromProto(source, prop);
	return desc ? `value` in desc ? desc.value : desc.get?.call(state.draft_) : void 0;
}
function getDescriptorFromProto(source, prop) {
	if (!(prop in source)) return void 0;
	let proto$1 = getPrototypeOf(source);
	while (proto$1) {
		const desc = Object.getOwnPropertyDescriptor(proto$1, prop);
		if (desc) return desc;
		proto$1 = getPrototypeOf(proto$1);
	}
}
function markChanged(state) {
	if (!state.modified_) {
		state.modified_ = true;
		if (state.parent_) markChanged(state.parent_);
	}
}
function prepareCopy(state) {
	if (!state.copy_) state.copy_ = shallowCopy(state.base_, state.scope_.immer_.useStrictShallowCopy_);
}
var Immer2 = class {
	constructor(config) {
		this.autoFreeze_ = true;
		this.useStrictShallowCopy_ = false;
		/**
		* The `produce` function takes a value and a "recipe function" (whose
		* return value often depends on the base state). The recipe function is
		* free to mutate its first argument however it wants. All mutations are
		* only ever applied to a __copy__ of the base state.
		*
		* Pass only a function to create a "curried producer" which relieves you
		* from passing the recipe function every time.
		*
		* Only plain objects and arrays are made mutable. All other objects are
		* considered uncopyable.
		*
		* Note: This function is __bound__ to its `Immer` instance.
		*
		* @param {any} base - the initial state
		* @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified
		* @param {Function} patchListener - optional function that will be called with all the patches produced here
		* @returns {any} a new state, or the initial state if nothing was modified
		*/
		this.produce = (base, recipe, patchListener) => {
			if (typeof base === "function" && typeof recipe !== "function") {
				const defaultBase = recipe;
				recipe = base;
				const self$1 = this;
				return function curriedProduce(base2 = defaultBase, ...args) {
					return self$1.produce(base2, (draft) => recipe.call(this, draft, ...args));
				};
			}
			if (typeof recipe !== "function") die(6);
			if (patchListener !== void 0 && typeof patchListener !== "function") die(7);
			let result;
			if (isDraftable(base)) {
				const scope = enterScope(this);
				const proxy = createProxy(base, void 0);
				let hasError = true;
				try {
					result = recipe(proxy);
					hasError = false;
				} finally {
					if (hasError) revokeScope(scope);
					else leaveScope(scope);
				}
				usePatchesInScope(scope, patchListener);
				return processResult(result, scope);
			} else if (!base || typeof base !== "object") {
				result = recipe(base);
				if (result === void 0) result = base;
				if (result === NOTHING) result = void 0;
				if (this.autoFreeze_) freeze(result, true);
				if (patchListener) {
					const p = [];
					const ip = [];
					getPlugin("Patches").generateReplacementPatches_(base, result, p, ip);
					patchListener(p, ip);
				}
				return result;
			} else die(1, base);
		};
		this.produceWithPatches = (base, recipe) => {
			if (typeof base === "function") return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));
			let patches, inversePatches;
			return [
				this.produce(base, recipe, (p, ip) => {
					patches = p;
					inversePatches = ip;
				}),
				patches,
				inversePatches
			];
		};
		if (typeof config?.autoFreeze === "boolean") this.setAutoFreeze(config.autoFreeze);
		if (typeof config?.useStrictShallowCopy === "boolean") this.setUseStrictShallowCopy(config.useStrictShallowCopy);
	}
	createDraft(base) {
		if (!isDraftable(base)) die(8);
		if (isDraft(base)) base = current(base);
		const scope = enterScope(this);
		const proxy = createProxy(base, void 0);
		proxy[DRAFT_STATE].isManual_ = true;
		leaveScope(scope);
		return proxy;
	}
	finishDraft(draft, patchListener) {
		const state = draft && draft[DRAFT_STATE];
		if (!state || !state.isManual_) die(9);
		const { scope_: scope } = state;
		usePatchesInScope(scope, patchListener);
		return processResult(void 0, scope);
	}
	/**
	* Pass true to automatically freeze all copies created by Immer.
	*
	* By default, auto-freezing is enabled.
	*/
	setAutoFreeze(value) {
		this.autoFreeze_ = value;
	}
	/**
	* Pass true to enable strict shallow copy.
	*
	* By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
	*/
	setUseStrictShallowCopy(value) {
		this.useStrictShallowCopy_ = value;
	}
	applyPatches(base, patches) {
		let i;
		for (i = patches.length - 1; i >= 0; i--) {
			const patch = patches[i];
			if (patch.path.length === 0 && patch.op === "replace") {
				base = patch.value;
				break;
			}
		}
		if (i > -1) patches = patches.slice(i + 1);
		const applyPatchesImpl = getPlugin("Patches").applyPatches_;
		if (isDraft(base)) return applyPatchesImpl(base, patches);
		return this.produce(base, (draft) => applyPatchesImpl(draft, patches));
	}
};
function createProxy(value, parent) {
	const draft = isMap(value) ? getPlugin("MapSet").proxyMap_(value, parent) : isSet(value) ? getPlugin("MapSet").proxySet_(value, parent) : createProxyProxy(value, parent);
	(parent ? parent.scope_ : getCurrentScope()).drafts_.push(draft);
	return draft;
}
function current(value) {
	if (!isDraft(value)) die(10, value);
	return currentImpl(value);
}
function currentImpl(value) {
	if (!isDraftable(value) || isFrozen(value)) return value;
	const state = value[DRAFT_STATE];
	let copy$2;
	if (state) {
		if (!state.modified_) return state.base_;
		state.finalized_ = true;
		copy$2 = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);
	} else copy$2 = shallowCopy(value, true);
	each(copy$2, (key, childValue) => {
		set(copy$2, key, currentImpl(childValue));
	});
	if (state) state.finalized_ = false;
	return copy$2;
}
var immer = new Immer2();
var produce = immer.produce;
function castDraft(value) {
	return value;
}

//#endregion
//#region node_modules/redux-thunk/dist/redux-thunk.mjs
function createThunkMiddleware(extraArgument) {
	const middleware = ({ dispatch, getState }) => (next) => (action) => {
		if (typeof action === "function") return action(dispatch, getState, extraArgument);
		return next(action);
	};
	return middleware;
}
var thunk = createThunkMiddleware();
var withExtraArgument = createThunkMiddleware;

//#endregion
//#region node_modules/@reduxjs/toolkit/dist/redux-toolkit.modern.mjs
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
	if (arguments.length === 0) return void 0;
	if (typeof arguments[0] === "object") return compose$1;
	return compose$1.apply(null, arguments);
};
typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__;
var hasMatchFunction = (v) => {
	return v && typeof v.match === "function";
};
function createAction(type, prepareAction) {
	function actionCreator(...args) {
		if (prepareAction) {
			let prepared = prepareAction(...args);
			if (!prepared) throw new Error("prepareAction did not return an object");
			return {
				type,
				payload: prepared.payload,
				..."meta" in prepared && { meta: prepared.meta },
				..."error" in prepared && { error: prepared.error }
			};
		}
		return {
			type,
			payload: args[0]
		};
	}
	actionCreator.toString = () => `${type}`;
	actionCreator.type = type;
	actionCreator.match = (action) => isAction(action) && action.type === type;
	return actionCreator;
}
function isActionCreator(action) {
	return typeof action === "function" && "type" in action && hasMatchFunction(action);
}
function getMessage(type) {
	const splitType = type ? `${type}`.split("/") : [];
	const actionName = splitType[splitType.length - 1] || "actionCreator";
	return `Detected an action creator with type "${type || "unknown"}" being dispatched. 
Make sure you're calling the action creator before dispatching, i.e. \`dispatch(${actionName}())\` instead of \`dispatch(${actionName})\`. This is necessary even if the action has no payload.`;
}
function createActionCreatorInvariantMiddleware(options$2 = {}) {
	const { isActionCreator: isActionCreator2 = isActionCreator } = options$2;
	return () => (next) => (action) => {
		if (isActionCreator2(action)) console.warn(getMessage(action.type));
		return next(action);
	};
}
function getTimeMeasureUtils(maxDelay, fnName) {
	let elapsed = 0;
	return {
		measureTime(fn) {
			const started = Date.now();
			try {
				return fn();
			} finally {
				elapsed += Date.now() - started;
			}
		},
		warnIfExceeded() {
			if (elapsed > maxDelay) console.warn(`${fnName} took ${elapsed}ms, which is more than the warning threshold of ${maxDelay}ms. 
If your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.
It is disabled in production builds, so you don't need to worry about that.`);
		}
	};
}
var Tuple = class _Tuple extends Array {
	constructor(...items) {
		super(...items);
		Object.setPrototypeOf(this, _Tuple.prototype);
	}
	static get [Symbol.species]() {
		return _Tuple;
	}
	concat(...arr) {
		return super.concat.apply(this, arr);
	}
	prepend(...arr) {
		if (arr.length === 1 && Array.isArray(arr[0])) return new _Tuple(...arr[0].concat(this));
		return new _Tuple(...arr.concat(this));
	}
};
function freezeDraftable(val) {
	return isDraftable(val) ? produce(val, () => {}) : val;
}
function getOrInsertComputed(map$2, key, compute) {
	if (map$2.has(key)) return map$2.get(key);
	return map$2.set(key, compute(key)).get(key);
}
function isImmutableDefault(value) {
	return typeof value !== "object" || value == null || Object.isFrozen(value);
}
function trackForMutations(isImmutable, ignorePaths, obj) {
	const trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
	return { detectMutations() {
		return detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
	} };
}
function trackProperties(isImmutable, ignorePaths = [], obj, path$1 = "", checkedObjects = /* @__PURE__ */ new Set()) {
	const tracked = { value: obj };
	if (!isImmutable(obj) && !checkedObjects.has(obj)) {
		checkedObjects.add(obj);
		tracked.children = {};
		for (const key in obj) {
			const childPath = path$1 ? path$1 + "." + key : key;
			if (ignorePaths.length && ignorePaths.indexOf(childPath) !== -1) continue;
			tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
		}
	}
	return tracked;
}
function detectMutations(isImmutable, ignoredPaths = [], trackedProperty, obj, sameParentRef = false, path$1 = "") {
	const prevObj = trackedProperty ? trackedProperty.value : void 0;
	const sameRef = prevObj === obj;
	if (sameParentRef && !sameRef && !Number.isNaN(obj)) return {
		wasMutated: true,
		path: path$1
	};
	if (isImmutable(prevObj) || isImmutable(obj)) return { wasMutated: false };
	const keysToDetect = {};
	for (let key in trackedProperty.children) keysToDetect[key] = true;
	for (let key in obj) keysToDetect[key] = true;
	const hasIgnoredPaths = ignoredPaths.length > 0;
	for (let key in keysToDetect) {
		const nestedPath = path$1 ? path$1 + "." + key : key;
		if (hasIgnoredPaths) {
			if (ignoredPaths.some((ignored) => {
				if (ignored instanceof RegExp) return ignored.test(nestedPath);
				return nestedPath === ignored;
			})) continue;
		}
		const result = detectMutations(isImmutable, ignoredPaths, trackedProperty.children[key], obj[key], sameRef, nestedPath);
		if (result.wasMutated) return result;
	}
	return { wasMutated: false };
}
function createImmutableStateInvariantMiddleware(options$2 = {}) {
	{
		let stringify2 = function(obj, serializer, indent, decycler) {
			return JSON.stringify(obj, getSerialize2(serializer, decycler), indent);
		}, getSerialize2 = function(serializer, decycler) {
			let stack = [], keys = [];
			if (!decycler) decycler = function(_, value) {
				if (stack[0] === value) return "[Circular ~]";
				return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]";
			};
			return function(key, value) {
				if (stack.length > 0) {
					var thisPos = stack.indexOf(this);
					~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
					~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
					if (~stack.indexOf(value)) value = decycler.call(this, key, value);
				} else stack.push(value);
				return serializer == null ? value : serializer.call(this, key, value);
			};
		};
		let { isImmutable = isImmutableDefault, ignoredPaths, warnAfter = 32 } = options$2;
		const track = trackForMutations.bind(null, isImmutable, ignoredPaths);
		return ({ getState }) => {
			let state = getState();
			let tracker = track(state);
			let result;
			return (next) => (action) => {
				const measureUtils = getTimeMeasureUtils(warnAfter, "ImmutableStateInvariantMiddleware");
				measureUtils.measureTime(() => {
					state = getState();
					result = tracker.detectMutations();
					tracker = track(state);
					if (result.wasMutated) throw new Error(`A state mutation was detected between dispatches, in the path '${result.path || ""}'.  This may cause incorrect behavior. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
				});
				const dispatchedAction = next(action);
				measureUtils.measureTime(() => {
					state = getState();
					result = tracker.detectMutations();
					tracker = track(state);
					if (result.wasMutated) throw new Error(`A state mutation was detected inside a dispatch, in the path: ${result.path || ""}. Take a look at the reducer(s) handling the action ${stringify2(action)}. (https://redux.js.org/style-guide/style-guide#do-not-mutate-state)`);
				});
				measureUtils.warnIfExceeded();
				return dispatchedAction;
			};
		};
	}
}
function isPlain(val) {
	const type = typeof val;
	return val == null || type === "string" || type === "boolean" || type === "number" || Array.isArray(val) || isPlainObject$3(val);
}
function findNonSerializableValue(value, path$1 = "", isSerializable = isPlain, getEntries, ignoredPaths = [], cache) {
	let foundNestedSerializable;
	if (!isSerializable(value)) return {
		keyPath: path$1 || "<root>",
		value
	};
	if (typeof value !== "object" || value === null) return false;
	if (cache?.has(value)) return false;
	const entries = getEntries != null ? getEntries(value) : Object.entries(value);
	const hasIgnoredPaths = ignoredPaths.length > 0;
	for (const [key, nestedValue] of entries) {
		const nestedPath = path$1 ? path$1 + "." + key : key;
		if (hasIgnoredPaths) {
			if (ignoredPaths.some((ignored) => {
				if (ignored instanceof RegExp) return ignored.test(nestedPath);
				return nestedPath === ignored;
			})) continue;
		}
		if (!isSerializable(nestedValue)) return {
			keyPath: nestedPath,
			value: nestedValue
		};
		if (typeof nestedValue === "object") {
			foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths, cache);
			if (foundNestedSerializable) return foundNestedSerializable;
		}
	}
	if (cache && isNestedFrozen(value)) cache.add(value);
	return false;
}
function isNestedFrozen(value) {
	if (!Object.isFrozen(value)) return false;
	for (const nestedValue of Object.values(value)) {
		if (typeof nestedValue !== "object" || nestedValue === null) continue;
		if (!isNestedFrozen(nestedValue)) return false;
	}
	return true;
}
function createSerializableStateInvariantMiddleware(options$2 = {}) {
	{
		const { isSerializable = isPlain, getEntries, ignoredActions = [], ignoredActionPaths = ["meta.arg", "meta.baseQueryMeta"], ignoredPaths = [], warnAfter = 32, ignoreState = false, ignoreActions = false, disableCache = false } = options$2;
		const cache = !disableCache && WeakSet ? /* @__PURE__ */ new WeakSet() : void 0;
		return (storeAPI) => (next) => (action) => {
			if (!isAction(action)) return next(action);
			const result = next(action);
			const measureUtils = getTimeMeasureUtils(warnAfter, "SerializableStateInvariantMiddleware");
			if (!ignoreActions && !(ignoredActions.length && ignoredActions.indexOf(action.type) !== -1)) measureUtils.measureTime(() => {
				const foundActionNonSerializableValue = findNonSerializableValue(action, "", isSerializable, getEntries, ignoredActionPaths, cache);
				if (foundActionNonSerializableValue) {
					const { keyPath, value } = foundActionNonSerializableValue;
					console.error(`A non-serializable value was detected in an action, in the path: \`${keyPath}\`. Value:`, value, "\nTake a look at the logic that dispatched this action: ", action, "\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)", "\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)");
				}
			});
			if (!ignoreState) {
				measureUtils.measureTime(() => {
					const state = storeAPI.getState();
					const foundStateNonSerializableValue = findNonSerializableValue(state, "", isSerializable, getEntries, ignoredPaths, cache);
					if (foundStateNonSerializableValue) {
						const { keyPath, value } = foundStateNonSerializableValue;
						console.error(`A non-serializable value was detected in the state, in the path: \`${keyPath}\`. Value:`, value, `
Take a look at the reducer(s) handling this action type: ${action.type}.
(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)`);
					}
				});
				measureUtils.warnIfExceeded();
			}
			return result;
		};
	}
}
function isBoolean(x$1) {
	return typeof x$1 === "boolean";
}
var buildGetDefaultMiddleware = () => function getDefaultMiddleware(options$2) {
	const { thunk: thunk$1 = true, immutableCheck = true, serializableCheck = true, actionCreatorCheck = true } = options$2 ?? {};
	let middlewareArray = new Tuple();
	if (thunk$1) if (isBoolean(thunk$1)) middlewareArray.push(thunk);
	else middlewareArray.push(withExtraArgument(thunk$1.extraArgument));
	if (immutableCheck) {
		let immutableOptions = {};
		if (!isBoolean(immutableCheck)) immutableOptions = immutableCheck;
		middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
	}
	if (serializableCheck) {
		let serializableOptions = {};
		if (!isBoolean(serializableCheck)) serializableOptions = serializableCheck;
		middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
	}
	if (actionCreatorCheck) {
		let actionCreatorOptions = {};
		if (!isBoolean(actionCreatorCheck)) actionCreatorOptions = actionCreatorCheck;
		middlewareArray.unshift(createActionCreatorInvariantMiddleware(actionCreatorOptions));
	}
	return middlewareArray;
};
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = () => (payload) => ({
	payload,
	meta: { [SHOULD_AUTOBATCH]: true }
});
var createQueueWithTimer = (timeout) => {
	return (notify) => {
		setTimeout(notify, timeout);
	};
};
var autoBatchEnhancer = (options$2 = { type: "raf" }) => (next) => (...args) => {
	const store = next(...args);
	let notifying = true;
	let shouldNotifyAtEndOfTick = false;
	let notificationQueued = false;
	const listeners = /* @__PURE__ */ new Set();
	const queueCallback = options$2.type === "tick" ? queueMicrotask : options$2.type === "raf" ? typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame : createQueueWithTimer(10) : options$2.type === "callback" ? options$2.queueNotification : createQueueWithTimer(options$2.timeout);
	const notifyListeners = () => {
		notificationQueued = false;
		if (shouldNotifyAtEndOfTick) {
			shouldNotifyAtEndOfTick = false;
			listeners.forEach((l) => l());
		}
	};
	return Object.assign({}, store, {
		subscribe(listener2) {
			const wrappedListener = () => notifying && listener2();
			const unsubscribe = store.subscribe(wrappedListener);
			listeners.add(listener2);
			return () => {
				unsubscribe();
				listeners.delete(listener2);
			};
		},
		dispatch(action) {
			try {
				notifying = !action?.meta?.[SHOULD_AUTOBATCH];
				shouldNotifyAtEndOfTick = !notifying;
				if (shouldNotifyAtEndOfTick) {
					if (!notificationQueued) {
						notificationQueued = true;
						queueCallback(notifyListeners);
					}
				}
				return store.dispatch(action);
			} finally {
				notifying = true;
			}
		}
	});
};
var buildGetDefaultEnhancers = (middlewareEnhancer) => function getDefaultEnhancers(options$2) {
	const { autoBatch = true } = options$2 ?? {};
	let enhancerArray = new Tuple(middlewareEnhancer);
	if (autoBatch) enhancerArray.push(autoBatchEnhancer(typeof autoBatch === "object" ? autoBatch : void 0));
	return enhancerArray;
};
function configureStore(options$2) {
	const getDefaultMiddleware = buildGetDefaultMiddleware();
	const { reducer = void 0, middleware, devTools = true, duplicateMiddlewareCheck = true, preloadedState: preloadedState$1 = void 0, enhancers = void 0 } = options$2 || {};
	let rootReducer$1;
	if (typeof reducer === "function") rootReducer$1 = reducer;
	else if (isPlainObject$3(reducer)) rootReducer$1 = combineReducers(reducer);
	else throw new Error("`reducer` is a required argument, and must be a function or an object of functions that can be passed to combineReducers");
	if (middleware && typeof middleware !== "function") throw new Error("`middleware` field must be a callback");
	let finalMiddleware;
	if (typeof middleware === "function") {
		finalMiddleware = middleware(getDefaultMiddleware);
		if (!Array.isArray(finalMiddleware)) throw new Error("when using a middleware builder function, an array of middleware must be returned");
	} else finalMiddleware = getDefaultMiddleware();
	if (finalMiddleware.some((item) => typeof item !== "function")) throw new Error("each middleware provided to configureStore must be a function");
	if (duplicateMiddlewareCheck) {
		let middlewareReferences = /* @__PURE__ */ new Set();
		finalMiddleware.forEach((middleware2) => {
			if (middlewareReferences.has(middleware2)) throw new Error("Duplicate middleware references found when creating the store. Ensure that each middleware is only included once.");
			middlewareReferences.add(middleware2);
		});
	}
	let finalCompose = compose$1;
	if (devTools) finalCompose = composeWithDevTools({
		trace: true,
		...typeof devTools === "object" && devTools
	});
	const middlewareEnhancer = applyMiddleware(...finalMiddleware);
	const getDefaultEnhancers = buildGetDefaultEnhancers(middlewareEnhancer);
	if (enhancers && typeof enhancers !== "function") throw new Error("`enhancers` field must be a callback");
	let storeEnhancers = typeof enhancers === "function" ? enhancers(getDefaultEnhancers) : getDefaultEnhancers();
	if (!Array.isArray(storeEnhancers)) throw new Error("`enhancers` callback must return an array");
	if (storeEnhancers.some((item) => typeof item !== "function")) throw new Error("each enhancer provided to configureStore must be a function");
	if (finalMiddleware.length && !storeEnhancers.includes(middlewareEnhancer)) console.error("middlewares were provided, but middleware enhancer was not included in final enhancers - make sure to call `getDefaultEnhancers`");
	const composedEnhancer = finalCompose(...storeEnhancers);
	return createStore(rootReducer$1, preloadedState$1, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
	const actionsMap = {};
	const actionMatchers = [];
	let defaultCaseReducer;
	const builder = {
		addCase(typeOrActionCreator, reducer) {
			if (actionMatchers.length > 0) throw new Error("`builder.addCase` should only be called before calling `builder.addMatcher`");
			if (defaultCaseReducer) throw new Error("`builder.addCase` should only be called before calling `builder.addDefaultCase`");
			const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
			if (!type) throw new Error("`builder.addCase` cannot be called with an empty action type");
			if (type in actionsMap) throw new Error(`\`builder.addCase\` cannot be called with two reducers for the same action type '${type}'`);
			actionsMap[type] = reducer;
			return builder;
		},
		addAsyncThunk(asyncThunk, reducers) {
			if (defaultCaseReducer) throw new Error("`builder.addAsyncThunk` should only be called before calling `builder.addDefaultCase`");
			if (reducers.pending) actionsMap[asyncThunk.pending.type] = reducers.pending;
			if (reducers.rejected) actionsMap[asyncThunk.rejected.type] = reducers.rejected;
			if (reducers.fulfilled) actionsMap[asyncThunk.fulfilled.type] = reducers.fulfilled;
			if (reducers.settled) actionMatchers.push({
				matcher: asyncThunk.settled,
				reducer: reducers.settled
			});
			return builder;
		},
		addMatcher(matcher, reducer) {
			if (defaultCaseReducer) throw new Error("`builder.addMatcher` should only be called before calling `builder.addDefaultCase`");
			actionMatchers.push({
				matcher,
				reducer
			});
			return builder;
		},
		addDefaultCase(reducer) {
			if (defaultCaseReducer) throw new Error("`builder.addDefaultCase` can only be called once");
			defaultCaseReducer = reducer;
			return builder;
		}
	};
	builderCallback(builder);
	return [
		actionsMap,
		actionMatchers,
		defaultCaseReducer
	];
}
function isStateFunction(x$1) {
	return typeof x$1 === "function";
}
function createReducer(initialState$4, mapOrBuilderCallback) {
	if (typeof mapOrBuilderCallback === "object") throw new Error("The object notation for `createReducer` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createReducer");
	let [actionsMap, finalActionMatchers, finalDefaultCaseReducer] = executeReducerBuilderCallback(mapOrBuilderCallback);
	let getInitialState;
	if (isStateFunction(initialState$4)) getInitialState = () => freezeDraftable(initialState$4());
	else {
		const frozenInitialState = freezeDraftable(initialState$4);
		getInitialState = () => frozenInitialState;
	}
	function reducer(state = getInitialState(), action) {
		let caseReducers = [actionsMap[action.type], ...finalActionMatchers.filter(({ matcher }) => matcher(action)).map(({ reducer: reducer2 }) => reducer2)];
		if (caseReducers.filter((cr) => !!cr).length === 0) caseReducers = [finalDefaultCaseReducer];
		return caseReducers.reduce((previousState, caseReducer) => {
			if (caseReducer) if (isDraft(previousState)) {
				const result = caseReducer(previousState, action);
				if (result === void 0) return previousState;
				return result;
			} else if (!isDraftable(previousState)) {
				const result = caseReducer(previousState, action);
				if (result === void 0) {
					if (previousState === null) return previousState;
					throw Error("A case reducer on a non-draftable value must not return undefined");
				}
				return result;
			} else return produce(previousState, (draft) => {
				return caseReducer(draft, action);
			});
			return previousState;
		}, state);
	}
	reducer.getInitialState = getInitialState;
	return reducer;
}
var matches = (matcher, action) => {
	if (hasMatchFunction(matcher)) return matcher.match(action);
	else return matcher(action);
};
function isAnyOf(...matchers) {
	return (action) => {
		return matchers.some((matcher) => matches(matcher, action));
	};
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = (size = 21) => {
	let id = "";
	let i = size;
	while (i--) id += urlAlphabet[Math.random() * 64 | 0];
	return id;
};
var commonProperties = [
	"name",
	"message",
	"stack",
	"code"
];
var RejectWithValue = class {
	constructor(payload, meta) {
		this.payload = payload;
		this.meta = meta;
	}
	_type;
};
var FulfillWithMeta = class {
	constructor(payload, meta) {
		this.payload = payload;
		this.meta = meta;
	}
	_type;
};
var miniSerializeError = (value) => {
	if (typeof value === "object" && value !== null) {
		const simpleError = {};
		for (const property$2 of commonProperties) if (typeof value[property$2] === "string") simpleError[property$2] = value[property$2];
		return simpleError;
	}
	return { message: String(value) };
};
var externalAbortMessage = "External signal was aborted";
var createAsyncThunk = /* @__PURE__ */ (() => {
	function createAsyncThunk2(typePrefix, payloadCreator, options$2) {
		const fulfilled = createAction(typePrefix + "/fulfilled", (payload, requestId, arg, meta) => ({
			payload,
			meta: {
				...meta || {},
				arg,
				requestId,
				requestStatus: "fulfilled"
			}
		}));
		const pending = createAction(typePrefix + "/pending", (requestId, arg, meta) => ({
			payload: void 0,
			meta: {
				...meta || {},
				arg,
				requestId,
				requestStatus: "pending"
			}
		}));
		const rejected = createAction(typePrefix + "/rejected", (error, requestId, arg, payload, meta) => ({
			payload,
			error: (options$2 && options$2.serializeError || miniSerializeError)(error || "Rejected"),
			meta: {
				...meta || {},
				arg,
				requestId,
				rejectedWithValue: !!payload,
				requestStatus: "rejected",
				aborted: error?.name === "AbortError",
				condition: error?.name === "ConditionError"
			}
		}));
		function actionCreator(arg, { signal } = {}) {
			return (dispatch, getState, extra) => {
				const requestId = options$2?.idGenerator ? options$2.idGenerator(arg) : nanoid();
				const abortController = new AbortController();
				let abortHandler;
				let abortReason;
				function abort(reason) {
					abortReason = reason;
					abortController.abort();
				}
				if (signal) if (signal.aborted) abort(externalAbortMessage);
				else signal.addEventListener("abort", () => abort(externalAbortMessage), { once: true });
				const promise = async function() {
					let finalAction;
					try {
						let conditionResult = options$2?.condition?.(arg, {
							getState,
							extra
						});
						if (isThenable(conditionResult)) conditionResult = await conditionResult;
						if (conditionResult === false || abortController.signal.aborted) throw {
							name: "ConditionError",
							message: "Aborted due to condition callback returning false."
						};
						const abortedPromise = new Promise((_, reject) => {
							abortHandler = () => {
								reject({
									name: "AbortError",
									message: abortReason || "Aborted"
								});
							};
							abortController.signal.addEventListener("abort", abortHandler);
						});
						dispatch(pending(requestId, arg, options$2?.getPendingMeta?.({
							requestId,
							arg
						}, {
							getState,
							extra
						})));
						finalAction = await Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
							dispatch,
							getState,
							extra,
							requestId,
							signal: abortController.signal,
							abort,
							rejectWithValue: (value, meta) => {
								return new RejectWithValue(value, meta);
							},
							fulfillWithValue: (value, meta) => {
								return new FulfillWithMeta(value, meta);
							}
						})).then((result) => {
							if (result instanceof RejectWithValue) throw result;
							if (result instanceof FulfillWithMeta) return fulfilled(result.payload, requestId, arg, result.meta);
							return fulfilled(result, requestId, arg);
						})]);
					} catch (err) {
						finalAction = err instanceof RejectWithValue ? rejected(null, requestId, arg, err.payload, err.meta) : rejected(err, requestId, arg);
					} finally {
						if (abortHandler) abortController.signal.removeEventListener("abort", abortHandler);
					}
					if (!(options$2 && !options$2.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition)) dispatch(finalAction);
					return finalAction;
				}();
				return Object.assign(promise, {
					abort,
					requestId,
					arg,
					unwrap() {
						return promise.then(unwrapResult);
					}
				});
			};
		}
		return Object.assign(actionCreator, {
			pending,
			rejected,
			fulfilled,
			settled: isAnyOf(rejected, fulfilled),
			typePrefix
		});
	}
	createAsyncThunk2.withTypes = () => createAsyncThunk2;
	return createAsyncThunk2;
})();
function unwrapResult(action) {
	if (action.meta && action.meta.rejectedWithValue) throw action.payload;
	if (action.error) throw action.error;
	return action.payload;
}
function isThenable(value) {
	return value !== null && typeof value === "object" && typeof value.then === "function";
}
var asyncThunkSymbol = /* @__PURE__ */ Symbol.for("rtk-slice-createasyncthunk");
var asyncThunkCreator = { [asyncThunkSymbol]: createAsyncThunk };
function getType(slice$1, actionKey) {
	return `${slice$1}/${actionKey}`;
}
function buildCreateSlice({ creators } = {}) {
	const cAT = creators?.asyncThunk?.[asyncThunkSymbol];
	return function createSlice2(options$2) {
		const { name, reducerPath = name } = options$2;
		if (!name) throw new Error("`name` is a required option for createSlice");
		if (typeof process !== "undefined" && true) {
			if (options$2.initialState === void 0) console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
		}
		const reducers = (typeof options$2.reducers === "function" ? options$2.reducers(buildReducerCreators()) : options$2.reducers) || {};
		const reducerNames = Object.keys(reducers);
		const context = {
			sliceCaseReducersByName: {},
			sliceCaseReducersByType: {},
			actionCreators: {},
			sliceMatchers: []
		};
		const contextMethods = {
			addCase(typeOrActionCreator, reducer2) {
				const type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
				if (!type) throw new Error("`context.addCase` cannot be called with an empty action type");
				if (type in context.sliceCaseReducersByType) throw new Error("`context.addCase` cannot be called with two reducers for the same action type: " + type);
				context.sliceCaseReducersByType[type] = reducer2;
				return contextMethods;
			},
			addMatcher(matcher, reducer2) {
				context.sliceMatchers.push({
					matcher,
					reducer: reducer2
				});
				return contextMethods;
			},
			exposeAction(name2, actionCreator) {
				context.actionCreators[name2] = actionCreator;
				return contextMethods;
			},
			exposeCaseReducer(name2, reducer2) {
				context.sliceCaseReducersByName[name2] = reducer2;
				return contextMethods;
			}
		};
		reducerNames.forEach((reducerName) => {
			const reducerDefinition = reducers[reducerName];
			const reducerDetails = {
				reducerName,
				type: getType(name, reducerName),
				createNotation: typeof options$2.reducers === "function"
			};
			if (isAsyncThunkSliceReducerDefinition(reducerDefinition)) handleThunkCaseReducerDefinition(reducerDetails, reducerDefinition, contextMethods, cAT);
			else handleNormalReducerDefinition(reducerDetails, reducerDefinition, contextMethods);
		});
		function buildReducer() {
			if (typeof options$2.extraReducers === "object") throw new Error("The object notation for `createSlice.extraReducers` has been removed. Please use the 'builder callback' notation instead: https://redux-toolkit.js.org/api/createSlice");
			const [extraReducers = {}, actionMatchers = [], defaultCaseReducer = void 0] = typeof options$2.extraReducers === "function" ? executeReducerBuilderCallback(options$2.extraReducers) : [options$2.extraReducers];
			const finalCaseReducers = {
				...extraReducers,
				...context.sliceCaseReducersByType
			};
			return createReducer(options$2.initialState, (builder) => {
				for (let key in finalCaseReducers) builder.addCase(key, finalCaseReducers[key]);
				for (let sM of context.sliceMatchers) builder.addMatcher(sM.matcher, sM.reducer);
				for (let m of actionMatchers) builder.addMatcher(m.matcher, m.reducer);
				if (defaultCaseReducer) builder.addDefaultCase(defaultCaseReducer);
			});
		}
		const selectSelf = (state) => state;
		const injectedSelectorCache = /* @__PURE__ */ new Map();
		const injectedStateCache = /* @__PURE__ */ new WeakMap();
		let _reducer;
		function reducer(state, action) {
			if (!_reducer) _reducer = buildReducer();
			return _reducer(state, action);
		}
		function getInitialState() {
			if (!_reducer) _reducer = buildReducer();
			return _reducer.getInitialState();
		}
		function makeSelectorProps(reducerPath2, injected = false) {
			function selectSlice(state) {
				let sliceState = state[reducerPath2];
				if (typeof sliceState === "undefined") if (injected) sliceState = getOrInsertComputed(injectedStateCache, selectSlice, getInitialState);
				else throw new Error("selectSlice returned undefined for an uninjected slice reducer");
				return sliceState;
			}
			function getSelectors(selectState = selectSelf) {
				const selectorCache = getOrInsertComputed(injectedSelectorCache, injected, () => /* @__PURE__ */ new WeakMap());
				return getOrInsertComputed(selectorCache, selectState, () => {
					const map$2 = {};
					for (const [name2, selector] of Object.entries(options$2.selectors ?? {})) map$2[name2] = wrapSelector(selector, selectState, () => getOrInsertComputed(injectedStateCache, selectState, getInitialState), injected);
					return map$2;
				});
			}
			return {
				reducerPath: reducerPath2,
				getSelectors,
				get selectors() {
					return getSelectors(selectSlice);
				},
				selectSlice
			};
		}
		const slice$1 = {
			name,
			reducer,
			actions: context.actionCreators,
			caseReducers: context.sliceCaseReducersByName,
			getInitialState,
			...makeSelectorProps(reducerPath),
			injectInto(injectable, { reducerPath: pathOpt,...config } = {}) {
				const newReducerPath = pathOpt ?? reducerPath;
				injectable.inject({
					reducerPath: newReducerPath,
					reducer
				}, config);
				return {
					...slice$1,
					...makeSelectorProps(newReducerPath, true)
				};
			}
		};
		return slice$1;
	};
}
function wrapSelector(selector, selectState, getInitialState, injected) {
	function wrapper(rootState, ...args) {
		let sliceState = selectState(rootState);
		if (typeof sliceState === "undefined") if (injected) sliceState = getInitialState();
		else throw new Error("selectState returned undefined for an uninjected slice reducer");
		return selector(sliceState, ...args);
	}
	wrapper.unwrapped = selector;
	return wrapper;
}
var createSlice = /* @__PURE__ */ buildCreateSlice();
function buildReducerCreators() {
	function asyncThunk(payloadCreator, config) {
		return {
			_reducerDefinitionType: "asyncThunk",
			payloadCreator,
			...config
		};
	}
	asyncThunk.withTypes = () => asyncThunk;
	return {
		reducer(caseReducer) {
			return Object.assign({ [caseReducer.name](...args) {
				return caseReducer(...args);
			} }[caseReducer.name], { _reducerDefinitionType: "reducer" });
		},
		preparedReducer(prepare, reducer) {
			return {
				_reducerDefinitionType: "reducerWithPrepare",
				prepare,
				reducer
			};
		},
		asyncThunk
	};
}
function handleNormalReducerDefinition({ type, reducerName, createNotation }, maybeReducerWithPrepare, context) {
	let caseReducer;
	let prepareCallback;
	if ("reducer" in maybeReducerWithPrepare) {
		if (createNotation && !isCaseReducerWithPrepareDefinition(maybeReducerWithPrepare)) throw new Error("Please use the `create.preparedReducer` notation for prepared action creators with the `create` notation.");
		caseReducer = maybeReducerWithPrepare.reducer;
		prepareCallback = maybeReducerWithPrepare.prepare;
	} else caseReducer = maybeReducerWithPrepare;
	context.addCase(type, caseReducer).exposeCaseReducer(reducerName, caseReducer).exposeAction(reducerName, prepareCallback ? createAction(type, prepareCallback) : createAction(type));
}
function isAsyncThunkSliceReducerDefinition(reducerDefinition) {
	return reducerDefinition._reducerDefinitionType === "asyncThunk";
}
function isCaseReducerWithPrepareDefinition(reducerDefinition) {
	return reducerDefinition._reducerDefinitionType === "reducerWithPrepare";
}
function handleThunkCaseReducerDefinition({ type, reducerName }, reducerDefinition, context, cAT) {
	if (!cAT) throw new Error("Cannot use `create.asyncThunk` in the built-in `createSlice`. Use `buildCreateSlice({ creators: { asyncThunk: asyncThunkCreator } })` to create a customised version of `createSlice`.");
	const { payloadCreator, fulfilled, pending, rejected, settled, options: options$2 } = reducerDefinition;
	const thunk$1 = cAT(type, payloadCreator, options$2);
	context.exposeAction(reducerName, thunk$1);
	if (fulfilled) context.addCase(thunk$1.fulfilled, fulfilled);
	if (pending) context.addCase(thunk$1.pending, pending);
	if (rejected) context.addCase(thunk$1.rejected, rejected);
	if (settled) context.addMatcher(thunk$1.settled, settled);
	context.exposeCaseReducer(reducerName, {
		fulfilled: fulfilled || noop$3,
		pending: pending || noop$3,
		rejected: rejected || noop$3,
		settled: settled || noop$3
	});
}
function noop$3() {}
var task = "task";
var listener = "listener";
var completed = "completed";
var cancelled = "cancelled";
var taskCancelled = `task-${cancelled}`;
var taskCompleted = `task-${completed}`;
var listenerCancelled = `${listener}-${cancelled}`;
var listenerCompleted = `${listener}-${completed}`;
var TaskAbortError = class {
	constructor(code) {
		this.code = code;
		this.message = `${task} ${cancelled} (reason: ${code})`;
	}
	name = "TaskAbortError";
	message;
};
var assertFunction = (func, expected) => {
	if (typeof func !== "function") throw new TypeError(`${expected} is not a function`);
};
var noop2 = () => {};
var catchRejection = (promise, onError = noop2) => {
	promise.catch(onError);
	return promise;
};
var addAbortSignalListener = (abortSignal, callback) => {
	abortSignal.addEventListener("abort", callback, { once: true });
	return () => abortSignal.removeEventListener("abort", callback);
};
var abortControllerWithReason = (abortController, reason) => {
	const signal = abortController.signal;
	if (signal.aborted) return;
	if (!("reason" in signal)) Object.defineProperty(signal, "reason", {
		enumerable: true,
		value: reason,
		configurable: true,
		writable: true
	});
	abortController.abort(reason);
};
var validateActive = (signal) => {
	if (signal.aborted) {
		const { reason } = signal;
		throw new TaskAbortError(reason);
	}
};
function raceWithSignal(signal, promise) {
	let cleanup = noop2;
	return new Promise((resolve, reject) => {
		const notifyRejection = () => reject(new TaskAbortError(signal.reason));
		if (signal.aborted) {
			notifyRejection();
			return;
		}
		cleanup = addAbortSignalListener(signal, notifyRejection);
		promise.finally(() => cleanup()).then(resolve, reject);
	}).finally(() => {
		cleanup = noop2;
	});
}
var runTask = async (task2, cleanUp) => {
	try {
		await Promise.resolve();
		return {
			status: "ok",
			value: await task2()
		};
	} catch (error) {
		return {
			status: error instanceof TaskAbortError ? "cancelled" : "rejected",
			error
		};
	} finally {
		cleanUp?.();
	}
};
var createPause = (signal) => {
	return (promise) => {
		return catchRejection(raceWithSignal(signal, promise).then((output) => {
			validateActive(signal);
			return output;
		}));
	};
};
var createDelay = (signal) => {
	const pause = createPause(signal);
	return (timeoutMs) => {
		return pause(new Promise((resolve) => setTimeout(resolve, timeoutMs)));
	};
};
var { assign } = Object;
var INTERNAL_NIL_TOKEN = {};
var alm = "listenerMiddleware";
var createFork = (parentAbortSignal, parentBlockingPromises) => {
	const linkControllers = (controller) => addAbortSignalListener(parentAbortSignal, () => abortControllerWithReason(controller, parentAbortSignal.reason));
	return (taskExecutor, opts) => {
		assertFunction(taskExecutor, "taskExecutor");
		const childAbortController = new AbortController();
		linkControllers(childAbortController);
		const result = runTask(async () => {
			validateActive(parentAbortSignal);
			validateActive(childAbortController.signal);
			const result2 = await taskExecutor({
				pause: createPause(childAbortController.signal),
				delay: createDelay(childAbortController.signal),
				signal: childAbortController.signal
			});
			validateActive(childAbortController.signal);
			return result2;
		}, () => abortControllerWithReason(childAbortController, taskCompleted));
		if (opts?.autoJoin) parentBlockingPromises.push(result.catch(noop2));
		return {
			result: createPause(parentAbortSignal)(result),
			cancel() {
				abortControllerWithReason(childAbortController, taskCancelled);
			}
		};
	};
};
var createTakePattern = (startListening, signal) => {
	const take = async (predicate, timeout) => {
		validateActive(signal);
		let unsubscribe = () => {};
		const promises = [new Promise((resolve, reject) => {
			let stopListening = startListening({
				predicate,
				effect: (action, listenerApi) => {
					listenerApi.unsubscribe();
					resolve([
						action,
						listenerApi.getState(),
						listenerApi.getOriginalState()
					]);
				}
			});
			unsubscribe = () => {
				stopListening();
				reject();
			};
		})];
		if (timeout != null) promises.push(new Promise((resolve) => setTimeout(resolve, timeout, null)));
		try {
			const output = await raceWithSignal(signal, Promise.race(promises));
			validateActive(signal);
			return output;
		} finally {
			unsubscribe();
		}
	};
	return (predicate, timeout) => catchRejection(take(predicate, timeout));
};
var getListenerEntryPropsFrom = (options$2) => {
	let { type, actionCreator, matcher, predicate, effect } = options$2;
	if (type) predicate = createAction(type).match;
	else if (actionCreator) {
		type = actionCreator.type;
		predicate = actionCreator.match;
	} else if (matcher) predicate = matcher;
	else if (predicate) {} else throw new Error("Creating or removing a listener requires one of the known fields for matching an action");
	assertFunction(effect, "options.listener");
	return {
		predicate,
		type,
		effect
	};
};
var createListenerEntry = /* @__PURE__ */ assign((options$2) => {
	const { type, predicate, effect } = getListenerEntryPropsFrom(options$2);
	return {
		id: nanoid(),
		effect,
		type,
		predicate,
		pending: /* @__PURE__ */ new Set(),
		unsubscribe: () => {
			throw new Error("Unsubscribe not initialized");
		}
	};
}, { withTypes: () => createListenerEntry });
var findListenerEntry = (listenerMap, options$2) => {
	const { type, effect, predicate } = getListenerEntryPropsFrom(options$2);
	return Array.from(listenerMap.values()).find((entry) => {
		return (typeof type === "string" ? entry.type === type : entry.predicate === predicate) && entry.effect === effect;
	});
};
var cancelActiveListeners = (entry) => {
	entry.pending.forEach((controller) => {
		abortControllerWithReason(controller, listenerCancelled);
	});
};
var createClearListenerMiddleware = (listenerMap, executingListeners) => {
	return () => {
		for (const listener2 of executingListeners.keys()) cancelActiveListeners(listener2);
		listenerMap.clear();
	};
};
var safelyNotifyError = (errorHandler, errorToNotify, errorInfo) => {
	try {
		errorHandler(errorToNotify, errorInfo);
	} catch (errorHandlerError) {
		setTimeout(() => {
			throw errorHandlerError;
		}, 0);
	}
};
var addListener$1 = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/add`), { withTypes: () => addListener$1 });
var clearAllListeners = /* @__PURE__ */ createAction(`${alm}/removeAll`);
var removeListener = /* @__PURE__ */ assign(/* @__PURE__ */ createAction(`${alm}/remove`), { withTypes: () => removeListener });
var defaultErrorHandler = (...args) => {
	console.error(`${alm}/error`, ...args);
};
var createListenerMiddleware = (middlewareOptions = {}) => {
	const listenerMap = /* @__PURE__ */ new Map();
	const executingListeners = /* @__PURE__ */ new Map();
	const trackExecutingListener = (entry) => {
		const count = executingListeners.get(entry) ?? 0;
		executingListeners.set(entry, count + 1);
	};
	const untrackExecutingListener = (entry) => {
		const count = executingListeners.get(entry) ?? 1;
		if (count === 1) executingListeners.delete(entry);
		else executingListeners.set(entry, count - 1);
	};
	const { extra, onError = defaultErrorHandler } = middlewareOptions;
	assertFunction(onError, "onError");
	const insertEntry = (entry) => {
		entry.unsubscribe = () => listenerMap.delete(entry.id);
		listenerMap.set(entry.id, entry);
		return (cancelOptions) => {
			entry.unsubscribe();
			if (cancelOptions?.cancelActive) cancelActiveListeners(entry);
		};
	};
	const startListening = (options$2) => {
		const entry = findListenerEntry(listenerMap, options$2) ?? createListenerEntry(options$2);
		return insertEntry(entry);
	};
	assign(startListening, { withTypes: () => startListening });
	const stopListening = (options$2) => {
		const entry = findListenerEntry(listenerMap, options$2);
		if (entry) {
			entry.unsubscribe();
			if (options$2.cancelActive) cancelActiveListeners(entry);
		}
		return !!entry;
	};
	assign(stopListening, { withTypes: () => stopListening });
	const notifyListener = async (entry, action, api, getOriginalState) => {
		const internalTaskController = new AbortController();
		const take = createTakePattern(startListening, internalTaskController.signal);
		const autoJoinPromises = [];
		try {
			entry.pending.add(internalTaskController);
			trackExecutingListener(entry);
			await Promise.resolve(entry.effect(action, assign({}, api, {
				getOriginalState,
				condition: (predicate, timeout) => take(predicate, timeout).then(Boolean),
				take,
				delay: createDelay(internalTaskController.signal),
				pause: createPause(internalTaskController.signal),
				extra,
				signal: internalTaskController.signal,
				fork: createFork(internalTaskController.signal, autoJoinPromises),
				unsubscribe: entry.unsubscribe,
				subscribe: () => {
					listenerMap.set(entry.id, entry);
				},
				cancelActiveListeners: () => {
					entry.pending.forEach((controller, _, set$1) => {
						if (controller !== internalTaskController) {
							abortControllerWithReason(controller, listenerCancelled);
							set$1.delete(controller);
						}
					});
				},
				cancel: () => {
					abortControllerWithReason(internalTaskController, listenerCancelled);
					entry.pending.delete(internalTaskController);
				},
				throwIfCancelled: () => {
					validateActive(internalTaskController.signal);
				}
			})));
		} catch (listenerError) {
			if (!(listenerError instanceof TaskAbortError)) safelyNotifyError(onError, listenerError, { raisedBy: "effect" });
		} finally {
			await Promise.all(autoJoinPromises);
			abortControllerWithReason(internalTaskController, listenerCompleted);
			untrackExecutingListener(entry);
			entry.pending.delete(internalTaskController);
		}
	};
	const clearListenerMiddleware = createClearListenerMiddleware(listenerMap, executingListeners);
	const middleware = (api) => (next) => (action) => {
		if (!isAction(action)) return next(action);
		if (addListener$1.match(action)) return startListening(action.payload);
		if (clearAllListeners.match(action)) {
			clearListenerMiddleware();
			return;
		}
		if (removeListener.match(action)) return stopListening(action.payload);
		let originalState = api.getState();
		const getOriginalState = () => {
			if (originalState === INTERNAL_NIL_TOKEN) throw new Error(`${alm}: getOriginalState can only be called synchronously`);
			return originalState;
		};
		let result;
		try {
			result = next(action);
			if (listenerMap.size > 0) {
				const currentState = api.getState();
				const listenerEntries = Array.from(listenerMap.values());
				for (const entry of listenerEntries) {
					let runListener = false;
					try {
						runListener = entry.predicate(action, currentState, originalState);
					} catch (predicateError) {
						runListener = false;
						safelyNotifyError(onError, predicateError, { raisedBy: "predicate" });
					}
					if (!runListener) continue;
					notifyListener(entry, action, api, getOriginalState);
				}
			}
		} finally {
			originalState = INTERNAL_NIL_TOKEN;
		}
		return result;
	};
	return {
		middleware,
		startListening,
		stopListening,
		clearListeners: clearListenerMiddleware
	};
};
var ORIGINAL_STATE = Symbol.for("rtk-state-proxy-original");

//#endregion
//#region node_modules/recharts/es6/state/layoutSlice.js
var chartLayoutSlice = createSlice({
	name: "chartLayout",
	initialState: {
		layoutType: "horizontal",
		width: 0,
		height: 0,
		margin: {
			top: 5,
			right: 5,
			bottom: 5,
			left: 5
		},
		scale: 1
	},
	reducers: {
		setLayout(state, action) {
			state.layoutType = action.payload;
		},
		setChartSize(state, action) {
			state.width = action.payload.width;
			state.height = action.payload.height;
		},
		setMargin(state, action) {
			var _action$payload$top, _action$payload$right, _action$payload$botto, _action$payload$left;
			state.margin.top = (_action$payload$top = action.payload.top) !== null && _action$payload$top !== void 0 ? _action$payload$top : 0;
			state.margin.right = (_action$payload$right = action.payload.right) !== null && _action$payload$right !== void 0 ? _action$payload$right : 0;
			state.margin.bottom = (_action$payload$botto = action.payload.bottom) !== null && _action$payload$botto !== void 0 ? _action$payload$botto : 0;
			state.margin.left = (_action$payload$left = action.payload.left) !== null && _action$payload$left !== void 0 ? _action$payload$left : 0;
		},
		setScale(state, action) {
			state.scale = action.payload;
		}
	}
});
var { setMargin, setLayout, setChartSize, setScale } = chartLayoutSlice.actions;
var chartLayoutReducer = chartLayoutSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/util/PolarUtils.js
function ownKeys$58(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$58(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$58(Object(t), !0).forEach(function(r$2) {
			_defineProperty$60(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$58(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$60(e, r$1, t) {
	return (r$1 = _toPropertyKey$60(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$60(t) {
	var i = _toPrimitive$60(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$60(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var RADIAN = Math.PI / 180;
var degreeToRadian = (angle) => angle * Math.PI / 180;
var radianToDegree = (angleInRadian) => angleInRadian * 180 / Math.PI;
var polarToCartesian = (cx, cy, radius, angle) => ({
	x: cx + Math.cos(-RADIAN * angle) * radius,
	y: cy + Math.sin(-RADIAN * angle) * radius
});
var getMaxRadius = function getMaxRadius$1(width, height) {
	var offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0,
		width: 0,
		height: 0,
		brushBottom: 0
	};
	return Math.min(Math.abs(width - (offset.left || 0) - (offset.right || 0)), Math.abs(height - (offset.top || 0) - (offset.bottom || 0))) / 2;
};
var distanceBetweenPoints = (point$3, anotherPoint) => {
	var { x: x1, y: y1 } = point$3;
	var { x: x2, y: y2 } = anotherPoint;
	return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
};
var getAngleOfPoint = (_ref$1, _ref2) => {
	var { x: x$1, y: y$1 } = _ref$1;
	var { cx, cy } = _ref2;
	var radius = distanceBetweenPoints({
		x: x$1,
		y: y$1
	}, {
		x: cx,
		y: cy
	});
	if (radius <= 0) return {
		radius,
		angle: 0
	};
	var cos$1 = (x$1 - cx) / radius;
	var angleInRadian = Math.acos(cos$1);
	if (y$1 > cy) angleInRadian = 2 * Math.PI - angleInRadian;
	return {
		radius,
		angle: radianToDegree(angleInRadian),
		angleInRadian
	};
};
var formatAngleOfSector = (_ref3) => {
	var { startAngle, endAngle } = _ref3;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	var min$1 = Math.min(startCnt, endCnt);
	return {
		startAngle: startAngle - min$1 * 360,
		endAngle: endAngle - min$1 * 360
	};
};
var reverseFormatAngleOfSector = (angle, _ref4) => {
	var { startAngle, endAngle } = _ref4;
	var startCnt = Math.floor(startAngle / 360);
	var endCnt = Math.floor(endAngle / 360);
	return angle + Math.min(startCnt, endCnt) * 360;
};
var inRangeOfSector = (_ref5, viewBox) => {
	var { x: x$1, y: y$1 } = _ref5;
	var { radius, angle } = getAngleOfPoint({
		x: x$1,
		y: y$1
	}, viewBox);
	var { innerRadius, outerRadius } = viewBox;
	if (radius < innerRadius || radius > outerRadius) return null;
	if (radius === 0) return null;
	var { startAngle, endAngle } = formatAngleOfSector(viewBox);
	var formatAngle = angle;
	var inRange$1;
	if (startAngle <= endAngle) {
		while (formatAngle > endAngle) formatAngle -= 360;
		while (formatAngle < startAngle) formatAngle += 360;
		inRange$1 = formatAngle >= startAngle && formatAngle <= endAngle;
	} else {
		while (formatAngle > startAngle) formatAngle -= 360;
		while (formatAngle < endAngle) formatAngle += 360;
		inRange$1 = formatAngle >= endAngle && formatAngle <= startAngle;
	}
	if (inRange$1) return _objectSpread$58(_objectSpread$58({}, viewBox), {}, {
		radius,
		angle: reverseFormatAngleOfSector(formatAngle, viewBox)
	});
	return null;
};
var getTickClassName = (tick) => !/* @__PURE__ */ (0, import_react.isValidElement)(tick) && typeof tick !== "function" && typeof tick !== "boolean" && tick != null ? tick.className : "";

//#endregion
//#region node_modules/recharts/es6/util/getSliced.js
function getSliced(arr, startIndex, endIndex) {
	if (!Array.isArray(arr)) return arr;
	if (arr && startIndex + endIndex !== 0) return arr.slice(startIndex, endIndex + 1);
	return arr;
}

//#endregion
//#region node_modules/recharts/es6/util/ChartUtils.js
var import_sortBy$2 = /* @__PURE__ */ __toESM(require_sortBy());
var import_get$6 = /* @__PURE__ */ __toESM(require_get());
function ownKeys$57(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$57(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$57(Object(t), !0).forEach(function(r$2) {
			_defineProperty$59(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$57(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$59(e, r$1, t) {
	return (r$1 = _toPropertyKey$59(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$59(t) {
	var i = _toPrimitive$59(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$59(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
	if (isNullish(obj) || isNullish(dataKey)) return defaultValue;
	if (isNumOrStr(dataKey)) return (0, import_get$6.default)(obj, dataKey, defaultValue);
	if (typeof dataKey === "function") return dataKey(obj);
	return defaultValue;
}
var calculateActiveTickIndex = (coordinate, ticks$1, unsortedTicks, axisType, range$5) => {
	var _ticks$length;
	var index = -1;
	var len = (_ticks$length = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
	if (len <= 1 || coordinate == null) return 0;
	if (axisType === "angleAxis" && range$5 != null && Math.abs(Math.abs(range$5[1] - range$5[0]) - 360) <= 1e-6) for (var i = 0; i < len; i++) {
		var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
		var cur = unsortedTicks[i].coordinate;
		var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
		var sameDirectionCoord = void 0;
		if (mathSign(cur - before) !== mathSign(after - cur)) {
			var diffInterval = [];
			if (mathSign(after - cur) === mathSign(range$5[1] - range$5[0])) {
				sameDirectionCoord = after;
				var curInRange = cur + range$5[1] - range$5[0];
				diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
				diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
			} else {
				sameDirectionCoord = before;
				var afterInRange = after + range$5[1] - range$5[0];
				diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
				diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
			}
			var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
			if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
				({index} = unsortedTicks[i]);
				break;
			}
		} else {
			var minValue = Math.min(before, after);
			var maxValue = Math.max(before, after);
			if (coordinate > (minValue + cur) / 2 && coordinate <= (maxValue + cur) / 2) {
				({index} = unsortedTicks[i]);
				break;
			}
		}
	}
	else if (ticks$1) {
		for (var _i = 0; _i < len; _i++) if (_i === 0 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2 && coordinate <= (ticks$1[_i].coordinate + ticks$1[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks$1[_i].coordinate + ticks$1[_i - 1].coordinate) / 2) {
			({index} = ticks$1[_i]);
			break;
		}
	}
	return index;
};
var appendOffsetOfLegend = (offset, legendSettings, legendSize) => {
	if (legendSettings && legendSize) {
		var { width: boxWidth, height: boxHeight } = legendSize;
		var { align, verticalAlign, layout } = legendSettings;
		if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && align !== "center" && isNumber(offset[align])) return _objectSpread$57(_objectSpread$57({}, offset), {}, { [align]: offset[align] + (boxWidth || 0) });
		if ((layout === "horizontal" || layout === "vertical" && align === "center") && verticalAlign !== "middle" && isNumber(offset[verticalAlign])) return _objectSpread$57(_objectSpread$57({}, offset), {}, { [verticalAlign]: offset[verticalAlign] + (boxHeight || 0) });
	}
	return offset;
};
var isCategoricalAxis = (layout, axisType) => layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
/**
* Calculate the Coordinates of grid
* @param  {Array} ticks           The ticks in axis
* @param {Number} minValue        The minimum value of axis
* @param {Number} maxValue        The maximum value of axis
* @param {boolean} syncWithTicks  Synchronize grid lines with ticks or not
* @return {Array}                 Coordinates
*/
var getCoordinatesOfGrid = (ticks$1, minValue, maxValue, syncWithTicks) => {
	if (syncWithTicks) return ticks$1.map((entry) => entry.coordinate);
	var hasMin, hasMax;
	var values = ticks$1.map((entry) => {
		if (entry.coordinate === minValue) hasMin = true;
		if (entry.coordinate === maxValue) hasMax = true;
		return entry.coordinate;
	});
	if (!hasMin) values.push(minValue);
	if (!hasMax) values.push(maxValue);
	return values;
};
/**
* A subset of d3-scale that Recharts is using
*/
/**
* Get the ticks of an axis
* @param  {Object}  axis The configuration of an axis
* @param {Boolean} isGrid Whether or not are the ticks in grid
* @param {Boolean} isAll Return the ticks of all the points or not
* @return {Array}  Ticks
*/
var getTicksOfAxis = (axis, isGrid, isAll) => {
	if (!axis) return null;
	var { duplicateDomain, type, range: range$5, scale, realScaleType, isCategorical, categoricalDomain, tickCount, ticks: ticks$1, niceTicks, axisType } = axis;
	if (!scale) return null;
	var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
	var offset = (isGrid || isAll) && type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
	offset = axisType === "angleAxis" && range$5 && range$5.length >= 2 ? mathSign(range$5[0] - range$5[1]) * 2 * offset : offset;
	if (isGrid && (ticks$1 || niceTicks)) return (ticks$1 || niceTicks || []).map((entry, index) => {
		var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
		return {
			coordinate: scale(scaleContent) + offset,
			value: entry,
			offset,
			index
		};
	}).filter((row) => !isNan(row.coordinate));
	if (isCategorical && categoricalDomain) return categoricalDomain.map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		index,
		offset
	}));
	if (scale.ticks && !isAll && tickCount != null) return scale.ticks(tickCount).map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		offset,
		index
	}));
	return scale.domain().map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: duplicateDomain ? duplicateDomain[entry] : entry,
		index,
		offset
	}));
};
var EPS = 1e-4;
var checkDomainOfScale = (scale) => {
	var domain = scale.domain();
	if (!domain || domain.length <= 2) return;
	var len = domain.length;
	var range$5 = scale.range();
	var minValue = Math.min(range$5[0], range$5[1]) - EPS;
	var maxValue = Math.max(range$5[0], range$5[1]) + EPS;
	var first = scale(domain[0]);
	var last$4 = scale(domain[len - 1]);
	if (first < minValue || first > maxValue || last$4 < minValue || last$4 > maxValue) scale.domain([domain[0], domain[len - 1]]);
};
/**
* Both value and domain are tuples of two numbers
* - but the type stays as array of numbers until we have better support in rest of the app
* @param value input that will be truncated
* @param domain boundaries
* @returns tuple of two numbers
*/
var truncateByDomain = (value, domain) => {
	if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) return value;
	var minValue = Math.min(domain[0], domain[1]);
	var maxValue = Math.max(domain[0], domain[1]);
	var result = [value[0], value[1]];
	if (!isNumber(value[0]) || value[0] < minValue) result[0] = minValue;
	if (!isNumber(value[1]) || value[1] > maxValue) result[1] = maxValue;
	if (result[0] > maxValue) result[0] = maxValue;
	if (result[1] < minValue) result[1] = minValue;
	return result;
};
/**
* Stacks all positive numbers above zero and all negative numbers below zero.
*
* If all values in the series are positive then this behaves the same as 'none' stacker.
*
* @param {Array} series from d3-shape Stack
* @return {Array} series with applied offset
*/
var offsetSign = (series) => {
	var n = series.length;
	if (n <= 0) return;
	for (var j = 0, m = series[0].length; j < m; ++j) {
		var positive = 0;
		var negative = 0;
		for (var i = 0; i < n; ++i) {
			var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
			if (value >= 0) {
				series[i][j][0] = positive;
				series[i][j][1] = positive + value;
				positive = series[i][j][1];
			} else {
				series[i][j][0] = negative;
				series[i][j][1] = negative + value;
				negative = series[i][j][1];
			}
		}
	}
};
/**
* Replaces all negative values with zero when stacking data.
*
* If all values in the series are positive then this behaves the same as 'none' stacker.
*
* @param {Array} series from d3-shape Stack
* @return {Array} series with applied offset
*/
var offsetPositive = (series) => {
	var n = series.length;
	if (n <= 0) return;
	for (var j = 0, m = series[0].length; j < m; ++j) {
		var positive = 0;
		for (var i = 0; i < n; ++i) {
			var value = isNan(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
			if (value >= 0) {
				series[i][j][0] = positive;
				series[i][j][1] = positive + value;
				positive = series[i][j][1];
			} else {
				series[i][j][0] = 0;
				series[i][j][1] = 0;
			}
		}
	}
};
/**
* Function type to compute offset for stacked data.
*
* d3-shape has something fishy going on with its types.
* In @definitelytyped/d3-shape, this function (the offset accessor) is typed as Series<> => void.
* However! When I actually open the storybook I can see that the offset accessor actually receives Array<Series<>>.
* The same I can see in the source code itself:
* https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042
* That one unfortunately has no types but we can tell it passes three-dimensional array.
*
* Which leads me to believe that definitelytyped is wrong on this one.
* There's open discussion on this topic without much attention:
* https://github.com/DefinitelyTyped/DefinitelyTyped/discussions/66042
*/
var STACK_OFFSET_MAP = {
	sign: offsetSign,
	expand: expand_default,
	none: none_default,
	silhouette: silhouette_default,
	wiggle: wiggle_default,
	positive: offsetPositive
};
var getStackedData = (data, dataKeys, offsetType) => {
	var offsetAccessor = STACK_OFFSET_MAP[offsetType];
	return stack_default().keys(dataKeys).value((d, key) => +getValueByDataKey(d, key, 0)).order(none_default$1).offset(offsetAccessor)(data);
};
/**
* Stack IDs in the external props allow numbers; but internally we use it as an object key
* and object keys are always strings. Also, it would be kinda confusing if stackId=8 and stackId='8' were different stacks
* so let's just force a string.
*/
function getNormalizedStackId(publicStackId) {
	return publicStackId == null ? void 0 : String(publicStackId);
}
function getCateCoordinateOfLine(_ref$1) {
	var { axis, ticks: ticks$1, bandSize, entry, index, dataKey } = _ref$1;
	if (axis.type === "category") {
		if (!axis.allowDuplicatedCategory && axis.dataKey && !isNullish(entry[axis.dataKey])) {
			var matchedTick = findEntryInArray(ticks$1, "value", entry[axis.dataKey]);
			if (matchedTick) return matchedTick.coordinate + bandSize / 2;
		}
		return ticks$1[index] ? ticks$1[index].coordinate + bandSize / 2 : null;
	}
	var value = getValueByDataKey(entry, !isNullish(dataKey) ? dataKey : axis.dataKey);
	return !isNullish(value) ? axis.scale(value) : null;
}
var getCateCoordinateOfBar = (_ref2) => {
	var { axis, ticks: ticks$1, offset, bandSize, entry, index } = _ref2;
	if (axis.type === "category") return ticks$1[index] ? ticks$1[index].coordinate + offset : null;
	var value = getValueByDataKey(entry, axis.dataKey, axis.scale.domain()[index]);
	return !isNullish(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
var getBaseValueOfBar = (_ref3) => {
	var { numericAxis } = _ref3;
	var domain = numericAxis.scale.domain();
	if (numericAxis.type === "number") {
		var minValue = Math.min(domain[0], domain[1]);
		var maxValue = Math.max(domain[0], domain[1]);
		if (minValue <= 0 && maxValue >= 0) return 0;
		if (maxValue < 0) return maxValue;
		return minValue;
	}
	return domain[0];
};
var getDomainOfSingle = (data) => {
	var flat = data.flat(2).filter(isNumber);
	return [Math.min(...flat), Math.max(...flat)];
};
var makeDomainFinite = (domain) => {
	return [domain[0] === Infinity ? 0 : domain[0], domain[1] === -Infinity ? 0 : domain[1]];
};
var getDomainOfStackGroups = (stackGroups, startIndex, endIndex) => {
	if (stackGroups == null) return;
	return makeDomainFinite(Object.keys(stackGroups).reduce((result, stackId) => {
		var { stackedData } = stackGroups[stackId];
		var domain = stackedData.reduce((res, entry) => {
			var sliced = getSliced(entry, startIndex, endIndex);
			var s$1 = getDomainOfSingle(sliced);
			return [Math.min(res[0], s$1[0]), Math.max(res[1], s$1[1])];
		}, [Infinity, -Infinity]);
		return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
	}, [Infinity, -Infinity]));
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
/**
* Calculate the size between two category
* @param  {Object} axis  The options of axis
* @param  {Array}  ticks The ticks of axis
* @param  {Boolean} isBar if items in axis are bars
* @return {Number} Size
*/
var getBandSizeOfAxis = (axis, ticks$1, isBar) => {
	if (axis && axis.scale && axis.scale.bandwidth) {
		var bandWidth = axis.scale.bandwidth();
		if (!isBar || bandWidth > 0) return bandWidth;
	}
	if (axis && ticks$1 && ticks$1.length >= 2) {
		var orderedTicks = (0, import_sortBy$2.default)(ticks$1, (o) => o.coordinate);
		var bandSize = Infinity;
		for (var i = 1, len = orderedTicks.length; i < len; i++) {
			var cur = orderedTicks[i];
			var prev = orderedTicks[i - 1];
			bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
		}
		return bandSize === Infinity ? 0 : bandSize;
	}
	return isBar ? void 0 : 0;
};
function getTooltipEntry(_ref4) {
	var { tooltipEntrySettings, dataKey, payload, value, name } = _ref4;
	return _objectSpread$57(_objectSpread$57({}, tooltipEntrySettings), {}, {
		dataKey,
		payload,
		value,
		name
	});
}
function getTooltipNameProp(nameFromItem, dataKey) {
	if (nameFromItem) return String(nameFromItem);
	if (typeof dataKey === "string") return dataKey;
}
function inRange(x$1, y$1, layout, polarViewBox, offset) {
	if (layout === "horizontal" || layout === "vertical") return x$1 >= offset.left && x$1 <= offset.left + offset.width && y$1 >= offset.top && y$1 <= offset.top + offset.height ? {
		x: x$1,
		y: y$1
	} : null;
	if (polarViewBox) return inRangeOfSector({
		x: x$1,
		y: y$1
	}, polarViewBox);
	return null;
}
var getActiveCoordinate = (layout, tooltipTicks, activeIndex, rangeObj) => {
	var entry = tooltipTicks.find((tick) => tick && tick.index === activeIndex);
	if (entry) {
		if (layout === "horizontal") return {
			x: entry.coordinate,
			y: rangeObj.y
		};
		if (layout === "vertical") return {
			x: rangeObj.x,
			y: entry.coordinate
		};
		if (layout === "centric") {
			var _angle = entry.coordinate;
			var { radius: _radius } = rangeObj;
			return _objectSpread$57(_objectSpread$57(_objectSpread$57({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
				angle: _angle,
				radius: _radius
			});
		}
		var radius = entry.coordinate;
		var { angle } = rangeObj;
		return _objectSpread$57(_objectSpread$57(_objectSpread$57({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
			angle,
			radius
		});
	}
	return {
		x: 0,
		y: 0
	};
};
var calculateTooltipPos = (rangeObj, layout) => {
	if (layout === "horizontal") return rangeObj.x;
	if (layout === "vertical") return rangeObj.y;
	if (layout === "centric") return rangeObj.angle;
	return rangeObj.radius;
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/containerSelectors.js
var selectChartWidth = (state) => state.layout.width;
var selectChartHeight = (state) => state.layout.height;
var selectContainerScale = (state) => state.layout.scale;
var selectMargin = (state) => state.layout.margin;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectAllAxes.js
var selectAllXAxes = createSelector((state) => state.cartesianAxis.xAxis, (xAxisMap) => {
	return Object.values(xAxisMap);
});
var selectAllYAxes = createSelector((state) => state.cartesianAxis.yAxis, (yAxisMap) => {
	return Object.values(yAxisMap);
});

//#endregion
//#region node_modules/recharts/es6/util/Constants.js
var COLOR_PANEL = [
	"#1890FF",
	"#66B5FF",
	"#41D9C7",
	"#2FC25B",
	"#6EDB8F",
	"#9AE65C",
	"#FACC14",
	"#E6965C",
	"#57AD71",
	"#223273",
	"#738AE6",
	"#7564CC",
	"#8543E0",
	"#A877ED",
	"#5C8EE6",
	"#13C2C2",
	"#70E0E0",
	"#5CA3E6",
	"#3436C7",
	"#8082FF",
	"#DD81E6",
	"#F04864",
	"#FA7D92",
	"#D598D9"
];
/**
* We use this attribute to identify which element is the one that the user is touching.
* The index is the position of the element in the data array.
* This can be either a number (for array-based charts) or a string (for the charts that have a matrix-shaped data).
*/
var DATA_ITEM_INDEX_ATTRIBUTE_NAME = "data-recharts-item-index";
/**
* We use this attribute to identify which element is the one that the user is touching.
* DataKey works here as a kind of identifier for the element. It's not a perfect identifier for ~two~ three reasons:
*
* 1. There can be two different elements with the same dataKey; we won't know which is it
* 2. DataKey can be a function, and that serialized will be a `[Function: anonymous]` string
* which means we will be able to identify that it was a function but can't tell which one.
* This will lead to some weird bugs. A proper fix would be to either:
* a) use a unique identifier for each element (passed from props, or generated)
* b) figure out how to compare the dataKey or graphical item by object reference
*
* a) is a fuss because we don't have the unique identifier in props,
* and b) is possible most of the time except for touchMove events which work differently from mouseEnter/mouseLeave:
* - while mouseEnter is fired for the element that the mouse is over,
* touchMove is fired for the element where user has started touching. As the finger moves,
* we can identify the element that the user is touching by using the elementFromPoint method,
* but it keeps calling the handler on the element where touchStart was fired.
*
* Okay and now I discovered a third reason: the dataKey can be undefined and that's still fine
* because if dataKey is undefined then graphical elements assume the dataKey of the axes.
* Which makes it a convenient way of using recharts to render a chart but horrible identifier.
*/
var DATA_ITEM_DATAKEY_ATTRIBUTE_NAME = "data-recharts-item-data-key";
var DEFAULT_Y_AXIS_WIDTH = 60;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectChartOffsetInternal.js
function ownKeys$56(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$56(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$56(Object(t), !0).forEach(function(r$2) {
			_defineProperty$58(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$56(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$58(e, r$1, t) {
	return (r$1 = _toPropertyKey$58(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$58(t) {
	var i = _toPrimitive$58(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$58(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var selectBrushHeight = (state) => state.brush.height;
function selectLeftAxesOffset(state) {
	return selectAllYAxes(state).reduce((result, entry) => {
		if (entry.orientation === "left" && !entry.mirror && !entry.hide) {
			var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
			return result + width;
		}
		return result;
	}, 0);
}
function selectRightAxesOffset(state) {
	return selectAllYAxes(state).reduce((result, entry) => {
		if (entry.orientation === "right" && !entry.mirror && !entry.hide) {
			var width = typeof entry.width === "number" ? entry.width : DEFAULT_Y_AXIS_WIDTH;
			return result + width;
		}
		return result;
	}, 0);
}
function selectTopAxesOffset(state) {
	return selectAllXAxes(state).reduce((result, entry) => {
		if (entry.orientation === "top" && !entry.mirror && !entry.hide) return result + entry.height;
		return result;
	}, 0);
}
function selectBottomAxesOffset(state) {
	return selectAllXAxes(state).reduce((result, entry) => {
		if (entry.orientation === "bottom" && !entry.mirror && !entry.hide) return result + entry.height;
		return result;
	}, 0);
}
/**
* For internal use only.
*
* @param root state
* @return ChartOffsetInternal
*/
var selectChartOffsetInternal = createSelector([
	selectChartWidth,
	selectChartHeight,
	selectMargin,
	selectBrushHeight,
	selectLeftAxesOffset,
	selectRightAxesOffset,
	selectTopAxesOffset,
	selectBottomAxesOffset,
	selectLegendSettings,
	selectLegendSize
], (chartWidth, chartHeight, margin, brushHeight, leftAxesOffset, rightAxesOffset, topAxesOffset, bottomAxesOffset, legendSettings, legendSize) => {
	var offsetH = {
		left: (margin.left || 0) + leftAxesOffset,
		right: (margin.right || 0) + rightAxesOffset
	};
	var offsetV = {
		top: (margin.top || 0) + topAxesOffset,
		bottom: (margin.bottom || 0) + bottomAxesOffset
	};
	var offset = _objectSpread$56(_objectSpread$56({}, offsetV), offsetH);
	var brushBottom = offset.bottom;
	offset.bottom += brushHeight;
	offset = appendOffsetOfLegend(offset, legendSettings, legendSize);
	var offsetWidth = chartWidth - offset.left - offset.right;
	var offsetHeight = chartHeight - offset.top - offset.bottom;
	return _objectSpread$56(_objectSpread$56({ brushBottom }, offset), {}, {
		width: Math.max(offsetWidth, 0),
		height: Math.max(offsetHeight, 0)
	});
});
var selectChartViewBox = createSelector(selectChartOffsetInternal, (offset) => ({
	x: offset.left,
	y: offset.top,
	width: offset.width,
	height: offset.height
}));
var selectAxisViewBox = createSelector(selectChartWidth, selectChartHeight, (width, height) => ({
	x: 0,
	y: 0,
	width,
	height
}));

//#endregion
//#region node_modules/recharts/es6/context/PanoramaContext.js
var PanoramaContext = /* @__PURE__ */ (0, import_react.createContext)(null);
var useIsPanorama = () => (0, import_react.useContext)(PanoramaContext) != null;
var PanoramaContextProvider = (_ref$1) => {
	var { children } = _ref$1;
	return /* @__PURE__ */ import_react.createElement(PanoramaContext.Provider, { value: true }, children);
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/brushSelectors.js
var selectBrushSettings = (state) => state.brush;
var selectBrushDimensions = createSelector([
	selectBrushSettings,
	selectChartOffsetInternal,
	selectMargin
], (brushSettings, offset, margin) => ({
	height: brushSettings.height,
	x: isNumber(brushSettings.x) ? brushSettings.x : offset.left,
	y: isNumber(brushSettings.y) ? brushSettings.y : offset.top + offset.height + offset.brushBottom - ((margin === null || margin === void 0 ? void 0 : margin.bottom) || 0),
	width: isNumber(brushSettings.width) ? brushSettings.width : offset.width
}));

//#endregion
//#region node_modules/es-toolkit/dist/function/debounce.js
var require_debounce$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/function/debounce.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function debounce$3(func, debounceMs, { signal, edges } = {}) {
		let pendingThis = void 0;
		let pendingArgs = null;
		const leading = edges != null && edges.includes("leading");
		const trailing = edges == null || edges.includes("trailing");
		const invoke = () => {
			if (pendingArgs !== null) {
				func.apply(pendingThis, pendingArgs);
				pendingThis = void 0;
				pendingArgs = null;
			}
		};
		const onTimerEnd = () => {
			if (trailing) invoke();
			cancel();
		};
		let timeoutId = null;
		const schedule = () => {
			if (timeoutId != null) clearTimeout(timeoutId);
			timeoutId = setTimeout(() => {
				timeoutId = null;
				onTimerEnd();
			}, debounceMs);
		};
		const cancelTimer = () => {
			if (timeoutId !== null) {
				clearTimeout(timeoutId);
				timeoutId = null;
			}
		};
		const cancel = () => {
			cancelTimer();
			pendingThis = void 0;
			pendingArgs = null;
		};
		const flush = () => {
			invoke();
		};
		const debounced = function(...args) {
			if (signal?.aborted) return;
			pendingThis = this;
			pendingArgs = args;
			const isFirstCall = timeoutId == null;
			schedule();
			if (leading && isFirstCall) invoke();
		};
		debounced.schedule = schedule;
		debounced.cancel = cancel;
		debounced.flush = flush;
		signal?.addEventListener("abort", cancel, { once: true });
		return debounced;
	}
	exports.debounce = debounce$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/function/debounce.js
var require_debounce = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/function/debounce.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var debounce$1 = require_debounce$1();
	function debounce$2(func, debounceMs = 0, options$2 = {}) {
		if (typeof options$2 !== "object") options$2 = {};
		const { leading = false, trailing = true, maxWait } = options$2;
		const edges = Array(2);
		if (leading) edges[0] = "leading";
		if (trailing) edges[1] = "trailing";
		let result = void 0;
		let pendingAt = null;
		const _debounced = debounce$1.debounce(function(...args) {
			result = func.apply(this, args);
			pendingAt = null;
		}, debounceMs, { edges });
		const debounced = function(...args) {
			if (maxWait != null) {
				if (pendingAt === null) pendingAt = Date.now();
				if (Date.now() - pendingAt >= maxWait) {
					result = func.apply(this, args);
					pendingAt = Date.now();
					_debounced.cancel();
					_debounced.schedule();
					return result;
				}
			}
			_debounced.apply(this, args);
			return result;
		};
		const flush = () => {
			_debounced.flush();
			return result;
		};
		debounced.cancel = _debounced.cancel;
		debounced.flush = flush;
		return debounced;
	}
	exports.debounce = debounce$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/function/throttle.js
var require_throttle$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/function/throttle.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var debounce = require_debounce();
	function throttle$1(func, throttleMs = 0, options$2 = {}) {
		const { leading = true, trailing = true } = options$2;
		return debounce.debounce(func, throttleMs, {
			leading,
			maxWait: throttleMs,
			trailing
		});
	}
	exports.throttle = throttle$1;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/throttle.js
var require_throttle = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/throttle.js": ((exports, module) => {
	module.exports = require_throttle$1().throttle;
}) });

//#endregion
//#region node_modules/recharts/es6/util/LogUtils.js
var import_throttle = /* @__PURE__ */ __toESM(require_throttle());
var isDev = true;
var warn = function warn$1(condition, format$1) {
	for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];
	if (isDev && typeof console !== "undefined" && console.warn) {
		if (format$1 === void 0) console.warn("LogUtils requires an error message argument");
		if (!condition) if (format$1 === void 0) console.warn("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
		else {
			var argIndex = 0;
			console.warn(format$1.replace(/%s/g, () => args[argIndex++]));
		}
	}
};

//#endregion
//#region node_modules/recharts/es6/component/responsiveContainerUtils.js
var calculateChartDimensions = (containerWidth, containerHeight, props) => {
	var { width = "100%", height = "100%", aspect, maxHeight } = props;
	var calculatedWidth = isPercent(width) ? containerWidth : Number(width);
	var calculatedHeight = isPercent(height) ? containerHeight : Number(height);
	if (aspect && aspect > 0) {
		if (calculatedWidth) calculatedHeight = calculatedWidth / aspect;
		else if (calculatedHeight) calculatedWidth = calculatedHeight * aspect;
		if (maxHeight && calculatedHeight > maxHeight) calculatedHeight = maxHeight;
	}
	return {
		calculatedWidth,
		calculatedHeight
	};
};
var bothOverflow = {
	width: 0,
	height: 0,
	overflow: "visible"
};
var overflowX = {
	width: 0,
	overflowX: "visible"
};
var overflowY = {
	height: 0,
	overflowY: "visible"
};
var noStyle = {};
/**
* This zero-size, overflow-visible is required to allow the chart to shrink.
* Without it, the chart itself will fill the ResponsiveContainer, and while it allows the chart to grow,
* it would always keep the container at the size of the chart,
* and ResizeObserver would never fire.
* With this zero-size element, the chart itself never actually fills the container,
* it just so happens that it is visible because it overflows.
* I learned this trick from the `react-virtualized` library: https://github.com/bvaughn/react-virtualized-auto-sizer/blob/master/src/AutoSizer.ts
* See https://github.com/recharts/recharts/issues/172 and also https://github.com/bvaughn/react-virtualized/issues/68
*
* Also, we don't need to apply the zero-size style if the dimension is a fixed number (or undefined),
* because in that case the chart can't shrink in that dimension anyway.
* This fixes defining the dimensions using aspect ratio: https://github.com/recharts/recharts/issues/6245
*/
var getInnerDivStyle = (props) => {
	var { width, height } = props;
	var isWidthPercent = isPercent(width);
	var isHeightPercent = isPercent(height);
	if (isWidthPercent && isHeightPercent) return bothOverflow;
	if (isWidthPercent) return overflowX;
	if (isHeightPercent) return overflowY;
	return noStyle;
};
function getDefaultWidthAndHeight(_ref$1) {
	var { width, height, aspect } = _ref$1;
	var calculatedWidth = width;
	var calculatedHeight = height;
	if (calculatedWidth === void 0 && calculatedHeight === void 0) {
		calculatedWidth = "100%";
		calculatedHeight = "100%";
	} else if (calculatedWidth === void 0) calculatedWidth = aspect && aspect > 0 ? void 0 : "100%";
	else if (calculatedHeight === void 0) calculatedHeight = aspect && aspect > 0 ? void 0 : "100%";
	return {
		width: calculatedWidth,
		height: calculatedHeight
	};
}

//#endregion
//#region node_modules/recharts/es6/util/isWellBehavedNumber.js
function isWellBehavedNumber(n) {
	return Number.isFinite(n);
}
function isPositiveNumber(n) {
	return typeof n === "number" && n > 0 && Number.isFinite(n);
}

//#endregion
//#region node_modules/recharts/es6/component/ResponsiveContainer.js
function _extends$44() {
	return _extends$44 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$44.apply(null, arguments);
}
function ownKeys$55(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$55(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$55(Object(t), !0).forEach(function(r$2) {
			_defineProperty$57(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$55(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$57(e, r$1, t) {
	return (r$1 = _toPropertyKey$57(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$57(t) {
	var i = _toPrimitive$57(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$57(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var ResponsiveContainerContext = /* @__PURE__ */ (0, import_react.createContext)({
	width: -1,
	height: -1
});
function ResponsiveContainerContextProvider(_ref$1) {
	var { children, width, height } = _ref$1;
	var size = (0, import_react.useMemo)(() => ({
		width,
		height
	}), [width, height]);
	if (width <= 0 || height <= 0) return null;
	return /* @__PURE__ */ import_react.createElement(ResponsiveContainerContext.Provider, { value: size }, children);
}
var useResponsiveContainerContext = () => (0, import_react.useContext)(ResponsiveContainerContext);
var SizeDetectorContainer = /* @__PURE__ */ (0, import_react.forwardRef)((_ref2, ref) => {
	var { aspect, initialDimension = {
		width: -1,
		height: -1
	}, width, height, minWidth = 0, minHeight, maxHeight, children, debounce: debounce$4 = 0, id, className, onResize, style = {} } = _ref2;
	var containerRef = (0, import_react.useRef)(null);
	var onResizeRef = (0, import_react.useRef)();
	onResizeRef.current = onResize;
	(0, import_react.useImperativeHandle)(ref, () => containerRef.current);
	var [sizes, setSizes] = (0, import_react.useState)({
		containerWidth: initialDimension.width,
		containerHeight: initialDimension.height
	});
	var setContainerSize = (0, import_react.useCallback)((newWidth, newHeight) => {
		setSizes((prevState) => {
			var roundedWidth = Math.round(newWidth);
			var roundedHeight = Math.round(newHeight);
			if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) return prevState;
			return {
				containerWidth: roundedWidth,
				containerHeight: roundedHeight
			};
		});
	}, []);
	(0, import_react.useEffect)(() => {
		var callback = (entries) => {
			var _onResizeRef$current;
			var { width: containerWidth$2, height: containerHeight$2 } = entries[0].contentRect;
			setContainerSize(containerWidth$2, containerHeight$2);
			(_onResizeRef$current = onResizeRef.current) === null || _onResizeRef$current === void 0 || _onResizeRef$current.call(onResizeRef, containerWidth$2, containerHeight$2);
		};
		if (debounce$4 > 0) callback = (0, import_throttle.default)(callback, debounce$4, {
			trailing: true,
			leading: false
		});
		var observer = new ResizeObserver(callback);
		var { width: containerWidth$1, height: containerHeight$1 } = containerRef.current.getBoundingClientRect();
		setContainerSize(containerWidth$1, containerHeight$1);
		observer.observe(containerRef.current);
		return () => {
			observer.disconnect();
		};
	}, [setContainerSize, debounce$4]);
	var { containerWidth, containerHeight } = sizes;
	warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
	var { calculatedWidth, calculatedHeight } = calculateChartDimensions(containerWidth, containerHeight, {
		width,
		height,
		aspect,
		maxHeight
	});
	warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
	return /* @__PURE__ */ import_react.createElement("div", {
		id: id ? "".concat(id) : void 0,
		className: clsx("recharts-responsive-container", className),
		style: _objectSpread$55(_objectSpread$55({}, style), {}, {
			width,
			height,
			minWidth,
			minHeight,
			maxHeight
		}),
		ref: containerRef
	}, /* @__PURE__ */ import_react.createElement("div", { style: getInnerDivStyle({
		width,
		height
	}) }, /* @__PURE__ */ import_react.createElement(ResponsiveContainerContextProvider, {
		width: calculatedWidth,
		height: calculatedHeight
	}, children)));
});
/**
* The `ResponsiveContainer` component is a container that adjusts its width and height based on the size of its parent element.
* It is used to create responsive charts that adapt to different screen sizes.
*
* This component uses the `ResizeObserver` API to monitor changes to the size of its parent element.
* If you need to support older browsers that do not support this API, you may need to include a polyfill.
*
* @see https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
*/
var ResponsiveContainer = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var responsiveContainerContext = useResponsiveContainerContext();
	if (isPositiveNumber(responsiveContainerContext.width) && isPositiveNumber(responsiveContainerContext.height)) return props.children;
	var { width, height } = getDefaultWidthAndHeight({
		width: props.width,
		height: props.height,
		aspect: props.aspect
	});
	var { calculatedWidth, calculatedHeight } = calculateChartDimensions(void 0, void 0, {
		width,
		height,
		aspect: props.aspect,
		maxHeight: props.maxHeight
	});
	if (isNumber(calculatedWidth) && isNumber(calculatedHeight)) return /* @__PURE__ */ import_react.createElement(ResponsiveContainerContextProvider, {
		width: calculatedWidth,
		height: calculatedHeight
	}, props.children);
	return /* @__PURE__ */ import_react.createElement(SizeDetectorContainer, _extends$44({}, props, {
		width,
		height,
		ref
	}));
});

//#endregion
//#region node_modules/recharts/es6/context/chartLayoutContext.js
var useViewBox = () => {
	var _useAppSelector;
	var panorama = useIsPanorama();
	var rootViewBox = useAppSelector(selectChartViewBox);
	var brushDimensions = useAppSelector(selectBrushDimensions);
	var brushPadding = (_useAppSelector = useAppSelector(selectBrushSettings)) === null || _useAppSelector === void 0 ? void 0 : _useAppSelector.padding;
	if (!panorama || !brushDimensions || !brushPadding) return rootViewBox;
	return {
		width: brushDimensions.width - brushPadding.left - brushPadding.right,
		height: brushDimensions.height - brushPadding.top - brushPadding.bottom,
		x: brushPadding.left,
		y: brushPadding.top
	};
};
var manyComponentsThrowErrorsIfOffsetIsUndefined = {
	top: 0,
	bottom: 0,
	left: 0,
	right: 0,
	width: 0,
	height: 0,
	brushBottom: 0
};
/**
* For internal use only. If you want this information, `import { useOffset } from 'recharts'` instead.
*
* Returns the offset of the chart in pixels.
*
* @returns {ChartOffsetInternal} The offset of the chart in pixels, or a default value if not in a chart context.
*/
var useOffsetInternal = () => {
	var _useAppSelector2;
	return (_useAppSelector2 = useAppSelector(selectChartOffsetInternal)) !== null && _useAppSelector2 !== void 0 ? _useAppSelector2 : manyComponentsThrowErrorsIfOffsetIsUndefined;
};
/**
* Returns the width of the chart in pixels.
*
* If you are using chart with hardcoded `width` prop, then the width returned will be the same
* as the `width` prop on the main chart element.
*
* If you are using a chart with a `ResponsiveContainer`, the width will be the size of the chart
* as the ResponsiveContainer has decided it would be.
*
* If the chart has any axes or legend, the `width` will be the size of the chart
* including the axes and legend. Meaning: adding axes and legend will not change the width.
*
* The dimensions do not scale, meaning as user zoom in and out, the width number will not change
* as the chart gets visually larger or smaller.
*
* Returns `undefined` if used outside a chart context.
*
* @returns {number | undefined} The width of the chart in pixels, or `undefined` if not in a chart context.
*/
var useChartWidth = () => {
	return useAppSelector(selectChartWidth);
};
/**
* Returns the height of the chart in pixels.
*
* If you are using chart with hardcoded `height` props, then the height returned will be the same
* as the `height` prop on the main chart element.
*
* If you are using a chart with a `ResponsiveContainer`, the height will be the size of the chart
* as the ResponsiveContainer has decided it would be.
*
* If the chart has any axes or legend, the `height` will be the size of the chart
* including the axes and legend. Meaning: adding axes and legend will not change the height.
*
* The dimensions do not scale, meaning as user zoom in and out, the height number will not change
* as the chart gets visually larger or smaller.
*
* Returns `undefined` if used outside a chart context.
*
* @returns {number | undefined} The height of the chart in pixels, or `undefined` if not in a chart context.
*/
var useChartHeight = () => {
	return useAppSelector(selectChartHeight);
};
/**
* Margin is the empty space around the chart. Excludes axes and legend and brushes and the like.
* This is declared by the user in the chart props.
* If you are interested in the space occupied by axes, legend, or brushes,
* use `useOffset` instead.
*
* Returns `undefined` if used outside a chart context.
*
* @returns {Margin | undefined} The margin of the chart in pixels, or `undefined` if not in a chart context.
*/
var useMargin = () => {
	return useAppSelector((state) => state.layout.margin);
};
var selectChartLayout = (state) => state.layout.layoutType;
var useChartLayout = () => useAppSelector(selectChartLayout);
var ReportChartSize = (props) => {
	var dispatch = useAppDispatch();
	var isPanorama = useIsPanorama();
	var { width: widthFromProps, height: heightFromProps } = props;
	var responsiveContainerCalculations = useResponsiveContainerContext();
	var width = widthFromProps;
	var height = heightFromProps;
	if (responsiveContainerCalculations) {
		width = responsiveContainerCalculations.width > 0 ? responsiveContainerCalculations.width : widthFromProps;
		height = responsiveContainerCalculations.height > 0 ? responsiveContainerCalculations.height : heightFromProps;
	}
	(0, import_react.useEffect)(() => {
		if (!isPanorama && isPositiveNumber(width) && isPositiveNumber(height)) dispatch(setChartSize({
			width,
			height
		}));
	}, [
		dispatch,
		isPanorama,
		width,
		height
	]);
	return null;
};
var ReportChartMargin = (_ref$1) => {
	var { margin } = _ref$1;
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(setMargin(margin));
	}, [dispatch, margin]);
	return null;
};

//#endregion
//#region node_modules/recharts/es6/state/legendSlice.js
var legendSlice = createSlice({
	name: "legend",
	initialState: {
		settings: {
			layout: "horizontal",
			align: "center",
			verticalAlign: "middle",
			itemSorter: "value"
		},
		size: {
			width: 0,
			height: 0
		},
		payload: []
	},
	reducers: {
		setLegendSize(state, action) {
			state.size.width = action.payload.width;
			state.size.height = action.payload.height;
		},
		setLegendSettings(state, action) {
			state.settings.align = action.payload.align;
			state.settings.layout = action.payload.layout;
			state.settings.verticalAlign = action.payload.verticalAlign;
			state.settings.itemSorter = action.payload.itemSorter;
		},
		addLegendPayload: {
			reducer(state, action) {
				state.payload.push(castDraft(action.payload));
			},
			prepare: prepareAutoBatched()
		},
		removeLegendPayload: {
			reducer(state, action) {
				var index = current(state).payload.indexOf(castDraft(action.payload));
				if (index > -1) state.payload.splice(index, 1);
			},
			prepare: prepareAutoBatched()
		}
	}
});
var { setLegendSize, setLegendSettings, addLegendPayload, removeLegendPayload } = legendSlice.actions;
var legendReducer = legendSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/component/Legend.js
var _excluded$33 = ["contextPayload"];
function _extends$43() {
	return _extends$43 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$43.apply(null, arguments);
}
function ownKeys$54(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$54(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$54(Object(t), !0).forEach(function(r$2) {
			_defineProperty$56(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$54(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$56(e, r$1, t) {
	return (r$1 = _toPropertyKey$56(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$56(t) {
	var i = _toPrimitive$56(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$56(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$33(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$33(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$33(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function defaultUniqBy$1(entry) {
	return entry.value;
}
function LegendContent(props) {
	var { contextPayload } = props, otherProps = _objectWithoutProperties$33(props, _excluded$33);
	var finalPayload = getUniqPayload(contextPayload, props.payloadUniqBy, defaultUniqBy$1);
	var contentProps = _objectSpread$54(_objectSpread$54({}, otherProps), {}, { payload: finalPayload });
	if (/* @__PURE__ */ import_react.isValidElement(props.content)) return /* @__PURE__ */ import_react.cloneElement(props.content, contentProps);
	if (typeof props.content === "function") return /* @__PURE__ */ import_react.createElement(props.content, contentProps);
	return /* @__PURE__ */ import_react.createElement(DefaultLegendContent, contentProps);
}
function getDefaultPosition(style, props, margin, chartWidth, chartHeight, box) {
	var { layout, align, verticalAlign } = props;
	var hPos, vPos;
	if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) if (align === "center" && layout === "vertical") hPos = { left: ((chartWidth || 0) - box.width) / 2 };
	else hPos = align === "right" ? { right: margin && margin.right || 0 } : { left: margin && margin.left || 0 };
	if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) if (verticalAlign === "middle") vPos = { top: ((chartHeight || 0) - box.height) / 2 };
	else vPos = verticalAlign === "bottom" ? { bottom: margin && margin.bottom || 0 } : { top: margin && margin.top || 0 };
	return _objectSpread$54(_objectSpread$54({}, hPos), vPos);
}
function LegendSettingsDispatcher(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(setLegendSettings(props));
	}, [dispatch, props]);
	return null;
}
function LegendSizeDispatcher(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(setLegendSize(props));
		return () => {
			dispatch(setLegendSize({
				width: 0,
				height: 0
			}));
		};
	}, [dispatch, props]);
	return null;
}
function LegendWrapper(props) {
	var contextPayload = useLegendPayload();
	var legendPortalFromContext = useLegendPortal();
	var margin = useMargin();
	var { width: widthFromProps, height: heightFromProps, wrapperStyle, portal: portalFromProps } = props;
	var [lastBoundingBox, updateBoundingBox] = useElementOffset([contextPayload]);
	var chartWidth = useChartWidth();
	var chartHeight = useChartHeight();
	if (chartWidth == null || chartHeight == null) return null;
	var maxWidth = chartWidth - (margin.left || 0) - (margin.right || 0);
	var widthOrHeight = Legend.getWidthOrHeight(props.layout, heightFromProps, widthFromProps, maxWidth);
	var outerStyle = portalFromProps ? wrapperStyle : _objectSpread$54(_objectSpread$54({
		position: "absolute",
		width: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.width) || widthFromProps || "auto",
		height: (widthOrHeight === null || widthOrHeight === void 0 ? void 0 : widthOrHeight.height) || heightFromProps || "auto"
	}, getDefaultPosition(wrapperStyle, props, margin, chartWidth, chartHeight, lastBoundingBox)), wrapperStyle);
	var legendPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : legendPortalFromContext;
	if (legendPortal == null) return null;
	var legendElement = /* @__PURE__ */ import_react.createElement("div", {
		className: "recharts-legend-wrapper",
		style: outerStyle,
		ref: updateBoundingBox
	}, /* @__PURE__ */ import_react.createElement(LegendSettingsDispatcher, {
		layout: props.layout,
		align: props.align,
		verticalAlign: props.verticalAlign,
		itemSorter: props.itemSorter
	}), /* @__PURE__ */ import_react.createElement(LegendSizeDispatcher, {
		width: lastBoundingBox.width,
		height: lastBoundingBox.height
	}), /* @__PURE__ */ import_react.createElement(LegendContent, _extends$43({}, props, widthOrHeight, {
		margin,
		chartWidth,
		chartHeight,
		contextPayload
	})));
	return /* @__PURE__ */ (0, import_react_dom$1.createPortal)(legendElement, legendPortal);
}
var Legend = class extends import_react.PureComponent {
	static getWidthOrHeight(layout, height, width, maxWidth) {
		if (layout === "vertical" && isNumber(height)) return { height };
		if (layout === "horizontal") return { width: width || maxWidth };
		return null;
	}
	render() {
		return /* @__PURE__ */ import_react.createElement(LegendWrapper, this.props);
	}
};
_defineProperty$56(Legend, "displayName", "Legend");
_defineProperty$56(Legend, "defaultProps", {
	align: "center",
	iconSize: 14,
	itemSorter: "value",
	layout: "horizontal",
	verticalAlign: "bottom"
});

//#endregion
//#region node_modules/recharts/es6/component/DefaultTooltipContent.js
var import_sortBy$1 = /* @__PURE__ */ __toESM(require_sortBy());
function _extends$42() {
	return _extends$42 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$42.apply(null, arguments);
}
function ownKeys$53(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$53(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$53(Object(t), !0).forEach(function(r$2) {
			_defineProperty$55(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$53(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$55(e, r$1, t) {
	return (r$1 = _toPropertyKey$55(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$55(t) {
	var i = _toPrimitive$55(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$55(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function defaultFormatter(value) {
	return Array.isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = (props) => {
	var { separator = " : ", contentStyle = {}, itemStyle = {}, labelStyle = {}, payload, formatter, itemSorter, wrapperClassName, labelClassName, label, labelFormatter, accessibilityLayer = false } = props;
	var renderContent$1 = () => {
		if (payload && payload.length) {
			var listStyle = {
				padding: 0,
				margin: 0
			};
			var items = (itemSorter ? (0, import_sortBy$1.default)(payload, itemSorter) : payload).map((entry, i) => {
				if (entry.type === "none") return null;
				var finalFormatter = entry.formatter || formatter || defaultFormatter;
				var { value, name } = entry;
				var finalValue = value;
				var finalName = name;
				if (finalFormatter) {
					var formatted = finalFormatter(value, name, entry, i, payload);
					if (Array.isArray(formatted)) [finalValue, finalName] = formatted;
					else if (formatted != null) finalValue = formatted;
					else return null;
				}
				var finalItemStyle = _objectSpread$53({
					display: "block",
					paddingTop: 4,
					paddingBottom: 4,
					color: entry.color || "#000"
				}, itemStyle);
				return /* @__PURE__ */ import_react.createElement("li", {
					className: "recharts-tooltip-item",
					key: "tooltip-item-".concat(i),
					style: finalItemStyle
				}, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-name" }, finalName) : null, isNumOrStr(finalName) ? /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-separator" }, separator) : null, /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-value" }, finalValue), /* @__PURE__ */ import_react.createElement("span", { className: "recharts-tooltip-item-unit" }, entry.unit || ""));
			});
			return /* @__PURE__ */ import_react.createElement("ul", {
				className: "recharts-tooltip-item-list",
				style: listStyle
			}, items);
		}
		return null;
	};
	var finalStyle = _objectSpread$53({
		margin: 0,
		padding: 10,
		backgroundColor: "#fff",
		border: "1px solid #ccc",
		whiteSpace: "nowrap"
	}, contentStyle);
	var finalLabelStyle = _objectSpread$53({ margin: 0 }, labelStyle);
	var hasLabel = !isNullish(label);
	var finalLabel = hasLabel ? label : "";
	var wrapperCN = clsx("recharts-default-tooltip", wrapperClassName);
	var labelCN = clsx("recharts-tooltip-label", labelClassName);
	if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) finalLabel = labelFormatter(label, payload);
	var accessibilityAttributes = accessibilityLayer ? {
		role: "status",
		"aria-live": "assertive"
	} : {};
	return /* @__PURE__ */ import_react.createElement("div", _extends$42({
		className: wrapperCN,
		style: finalStyle
	}, accessibilityAttributes), /* @__PURE__ */ import_react.createElement("p", {
		className: labelCN,
		style: finalLabelStyle
	}, /* @__PURE__ */ import_react.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), renderContent$1());
};

//#endregion
//#region node_modules/recharts/es6/util/tooltip/translate.js
var CSS_CLASS_PREFIX = "recharts-tooltip-wrapper";
var TOOLTIP_HIDDEN = { visibility: "hidden" };
function getTooltipCSSClassName(_ref$1) {
	var { coordinate, translateX, translateY } = _ref$1;
	return clsx(CSS_CLASS_PREFIX, {
		["".concat(CSS_CLASS_PREFIX, "-right")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x,
		["".concat(CSS_CLASS_PREFIX, "-left")]: isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x,
		["".concat(CSS_CLASS_PREFIX, "-bottom")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y,
		["".concat(CSS_CLASS_PREFIX, "-top")]: isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y
	});
}
function getTooltipTranslateXY(_ref2) {
	var { allowEscapeViewBox, coordinate, key, offsetTopLeft, position: position$1, reverseDirection, tooltipDimension, viewBox, viewBoxDimension } = _ref2;
	if (position$1 && isNumber(position$1[key])) return position$1[key];
	var negative = coordinate[key] - tooltipDimension - (offsetTopLeft > 0 ? offsetTopLeft : 0);
	var positive = coordinate[key] + offsetTopLeft;
	if (allowEscapeViewBox[key]) return reverseDirection[key] ? negative : positive;
	var viewBoxKey = viewBox[key];
	if (viewBoxKey == null) return 0;
	if (reverseDirection[key]) {
		if (negative < viewBoxKey) return Math.max(positive, viewBoxKey);
		return Math.max(negative, viewBoxKey);
	}
	if (viewBoxDimension == null) return 0;
	var tooltipBoundary = positive + tooltipDimension;
	var viewBoxBoundary = viewBoxKey + viewBoxDimension;
	if (tooltipBoundary > viewBoxBoundary) return Math.max(negative, viewBoxKey);
	return Math.max(positive, viewBoxKey);
}
function getTransformStyle(_ref3) {
	var { translateX, translateY, useTranslate3d } = _ref3;
	return { transform: useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)") };
}
function getTooltipTranslate(_ref4) {
	var { allowEscapeViewBox, coordinate, offsetTopLeft, position: position$1, reverseDirection, tooltipBox, useTranslate3d, viewBox } = _ref4;
	var cssProperties, translateX, translateY;
	if (tooltipBox.height > 0 && tooltipBox.width > 0 && coordinate) {
		translateX = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "x",
			offsetTopLeft,
			position: position$1,
			reverseDirection,
			tooltipDimension: tooltipBox.width,
			viewBox,
			viewBoxDimension: viewBox.width
		});
		translateY = getTooltipTranslateXY({
			allowEscapeViewBox,
			coordinate,
			key: "y",
			offsetTopLeft,
			position: position$1,
			reverseDirection,
			tooltipDimension: tooltipBox.height,
			viewBox,
			viewBoxDimension: viewBox.height
		});
		cssProperties = getTransformStyle({
			translateX,
			translateY,
			useTranslate3d
		});
	} else cssProperties = TOOLTIP_HIDDEN;
	return {
		cssProperties,
		cssClasses: getTooltipCSSClassName({
			translateX,
			translateY,
			coordinate
		})
	};
}

//#endregion
//#region node_modules/recharts/es6/component/TooltipBoundingBox.js
function ownKeys$52(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$52(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$52(Object(t), !0).forEach(function(r$2) {
			_defineProperty$54(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$52(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$54(e, r$1, t) {
	return (r$1 = _toPropertyKey$54(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$54(t) {
	var i = _toPrimitive$54(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$54(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var TooltipBoundingBox = class extends import_react.PureComponent {
	constructor() {
		super(...arguments);
		_defineProperty$54(this, "state", {
			dismissed: false,
			dismissedAtCoordinate: {
				x: 0,
				y: 0
			}
		});
		_defineProperty$54(this, "handleKeyDown", (event) => {
			if (event.key === "Escape") {
				var _this$props$coordinat, _this$props$coordinat2, _this$props$coordinat3, _this$props$coordinat4;
				this.setState({
					dismissed: true,
					dismissedAtCoordinate: {
						x: (_this$props$coordinat = (_this$props$coordinat2 = this.props.coordinate) === null || _this$props$coordinat2 === void 0 ? void 0 : _this$props$coordinat2.x) !== null && _this$props$coordinat !== void 0 ? _this$props$coordinat : 0,
						y: (_this$props$coordinat3 = (_this$props$coordinat4 = this.props.coordinate) === null || _this$props$coordinat4 === void 0 ? void 0 : _this$props$coordinat4.y) !== null && _this$props$coordinat3 !== void 0 ? _this$props$coordinat3 : 0
					}
				});
			}
		});
	}
	componentDidMount() {
		document.addEventListener("keydown", this.handleKeyDown);
	}
	componentWillUnmount() {
		document.removeEventListener("keydown", this.handleKeyDown);
	}
	componentDidUpdate() {
		var _this$props$coordinat5, _this$props$coordinat6;
		if (!this.state.dismissed) return;
		if (((_this$props$coordinat5 = this.props.coordinate) === null || _this$props$coordinat5 === void 0 ? void 0 : _this$props$coordinat5.x) !== this.state.dismissedAtCoordinate.x || ((_this$props$coordinat6 = this.props.coordinate) === null || _this$props$coordinat6 === void 0 ? void 0 : _this$props$coordinat6.y) !== this.state.dismissedAtCoordinate.y) this.state.dismissed = false;
	}
	render() {
		var { active, allowEscapeViewBox, animationDuration, animationEasing, children, coordinate, hasPayload, isAnimationActive, offset, position: position$1, reverseDirection, useTranslate3d, viewBox, wrapperStyle, lastBoundingBox, innerRef, hasPortalFromProps } = this.props;
		var { cssClasses, cssProperties } = getTooltipTranslate({
			allowEscapeViewBox,
			coordinate,
			offsetTopLeft: offset,
			position: position$1,
			reverseDirection,
			tooltipBox: {
				height: lastBoundingBox.height,
				width: lastBoundingBox.width
			},
			useTranslate3d,
			viewBox
		});
		var positionStyles = hasPortalFromProps ? {} : _objectSpread$52(_objectSpread$52({ transition: isAnimationActive && active ? "transform ".concat(animationDuration, "ms ").concat(animationEasing) : void 0 }, cssProperties), {}, {
			pointerEvents: "none",
			visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
			position: "absolute",
			top: 0,
			left: 0
		});
		var outerStyle = _objectSpread$52(_objectSpread$52({}, positionStyles), {}, { visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden" }, wrapperStyle);
		return /* @__PURE__ */ import_react.createElement("div", {
			xmlns: "http://www.w3.org/1999/xhtml",
			tabIndex: -1,
			className: cssClasses,
			style: outerStyle,
			ref: innerRef
		}, children);
	}
};

//#endregion
//#region node_modules/recharts/es6/util/Global.js
var parseIsSsrByDefault = () => !(typeof window !== "undefined" && window.document && Boolean(window.document.createElement) && window.setTimeout);
var Global = {
	devToolsEnabled: false,
	isSsr: parseIsSsrByDefault()
};

//#endregion
//#region node_modules/recharts/es6/context/accessibilityContext.js
var useAccessibilityLayer = () => useAppSelector((state) => state.rootProps.accessibilityLayer);

//#endregion
//#region node_modules/recharts/es6/shape/Curve.js
function _extends$41() {
	return _extends$41 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$41.apply(null, arguments);
}
function ownKeys$51(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$51(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$51(Object(t), !0).forEach(function(r$2) {
			_defineProperty$53(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$51(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$53(e, r$1, t) {
	return (r$1 = _toPropertyKey$53(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$53(t) {
	var i = _toPrimitive$53(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$53(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var CURVE_FACTORIES = {
	curveBasisClosed: basisClosed_default$1,
	curveBasisOpen: basisOpen_default,
	curveBasis: basis_default$1,
	curveBumpX: bumpX,
	curveBumpY: bumpY,
	curveLinearClosed: linearClosed_default,
	curveLinear: linear_default,
	curveMonotoneX: monotoneX,
	curveMonotoneY: monotoneY,
	curveNatural: natural_default,
	curveStep: step_default,
	curveStepAfter: stepAfter,
	curveStepBefore: stepBefore
};
/**
* @deprecated use {@link Coordinate} instead
* Duplicated with `Coordinate` in `util/types.ts`
*/
/**
* @deprecated use {@link NullableCoordinate} instead
* Duplicated with `NullableCoordinate` in `util/types.ts`
*/
var defined = (p) => isWellBehavedNumber(p.x) && isWellBehavedNumber(p.y);
var getX = (p) => p.x;
var getY = (p) => p.y;
var getCurveFactory = (type, layout) => {
	if (typeof type === "function") return type;
	var name = "curve".concat(upperFirst(type));
	if ((name === "curveMonotone" || name === "curveBump") && layout) return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
	return CURVE_FACTORIES[name] || linear_default;
};
/**
* Calculate the path of curve. Returns null if points is an empty array.
* @return path or null
*/
var getPath$1 = (_ref$1) => {
	var { type = "linear", points = [], baseLine, layout, connectNulls = false } = _ref$1;
	var curveFactory = getCurveFactory(type, layout);
	var formatPoints = connectNulls ? points.filter(defined) : points;
	var lineFunction;
	if (Array.isArray(baseLine)) {
		var formatBaseLine = connectNulls ? baseLine.filter((base) => defined(base)) : baseLine;
		var areaPoints = formatPoints.map((entry, index) => _objectSpread$51(_objectSpread$51({}, entry), {}, { base: formatBaseLine[index] }));
		if (layout === "vertical") lineFunction = area_default().y(getY).x1(getX).x0((d) => d.base.x);
		else lineFunction = area_default().x(getX).y1(getY).y0((d) => d.base.y);
		lineFunction.defined(defined).curve(curveFactory);
		return lineFunction(areaPoints);
	}
	if (layout === "vertical" && isNumber(baseLine)) lineFunction = area_default().y(getY).x1(getX).x0(baseLine);
	else if (isNumber(baseLine)) lineFunction = area_default().x(getX).y1(getY).y0(baseLine);
	else lineFunction = line_default().x(getX).y(getY);
	lineFunction.defined(defined).curve(curveFactory);
	return lineFunction(formatPoints);
};
var Curve = (props) => {
	var { className, points, path: path$1, pathRef } = props;
	if ((!points || !points.length) && !path$1) return null;
	var realPath = points && points.length ? getPath$1(props) : path$1;
	return /* @__PURE__ */ import_react.createElement("path", _extends$41({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
		className: clsx("recharts-curve", className),
		d: realPath === null ? void 0 : realPath,
		ref: pathRef
	}));
};

//#endregion
//#region node_modules/recharts/es6/shape/Cross.js
var _excluded$32 = [
	"x",
	"y",
	"top",
	"left",
	"width",
	"height",
	"className"
];
function _extends$40() {
	return _extends$40 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$40.apply(null, arguments);
}
function ownKeys$50(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$50(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$50(Object(t), !0).forEach(function(r$2) {
			_defineProperty$52(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$50(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$52(e, r$1, t) {
	return (r$1 = _toPropertyKey$52(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$52(t) {
	var i = _toPrimitive$52(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$52(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$32(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$32(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$32(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var getPath = (x$1, y$1, width, height, top, left) => {
	return "M".concat(x$1, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y$1, "h").concat(width);
};
var Cross = (_ref$1) => {
	var { x: x$1 = 0, y: y$1 = 0, top = 0, left = 0, width = 0, height = 0, className } = _ref$1, rest = _objectWithoutProperties$32(_ref$1, _excluded$32);
	var props = _objectSpread$50({
		x: x$1,
		y: y$1,
		top,
		left,
		width,
		height
	}, rest);
	if (!isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) return null;
	return /* @__PURE__ */ import_react.createElement("path", _extends$40({}, svgPropertiesAndEvents(props), {
		className: clsx("recharts-cross", className),
		d: getPath(x$1, y$1, width, height, top, left)
	}));
};

//#endregion
//#region node_modules/recharts/es6/util/cursor/getCursorRectangle.js
function getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize) {
	var halfSize = tooltipAxisBandSize / 2;
	return {
		stroke: "none",
		fill: "#ccc",
		x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + .5,
		y: layout === "horizontal" ? offset.top + .5 : activeCoordinate.y - halfSize,
		width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
		height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
	};
}

//#endregion
//#region node_modules/recharts/es6/util/resolveDefaultProps.js
function ownKeys$49(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$49(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$49(Object(t), !0).forEach(function(r$2) {
			_defineProperty$51(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$49(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$51(e, r$1, t) {
	return (r$1 = _toPropertyKey$51(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$51(t) {
	var i = _toPrimitive$51(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$51(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* This function mimics the behavior of the `defaultProps` static property in React.
* Functional components do not have a defaultProps property, so this function is useful to resolve default props.
*
* The common recommendation is to use ES6 destructuring with default values in the function signature,
* but you need to be careful there and make sure you destructure all the individual properties
* and not the whole object. See the test file for example.
*
* And because destructuring all properties one by one is a faff, and it's easy to miss one property,
* this function exists.
*
* @param realProps - the props object passed to the component by the user
* @param defaultProps - the default props object defined in the component by Recharts
* @returns - the props object with all the default props resolved. All `undefined` values are replaced with the default value.
*/
function resolveDefaultProps(realProps, defaultProps$10) {
	var resolvedProps = _objectSpread$49({}, realProps);
	var dp = defaultProps$10;
	return Object.keys(defaultProps$10).reduce((acc, key) => {
		if (acc[key] === void 0 && dp[key] !== void 0) acc[key] = dp[key];
		return acc;
	}, resolvedProps);
}
/**
* Helper type to extract the keys of T that are required.
* It iterates through each key K in T. If Pick<T, K> cannot be assigned an empty object {},
* it means K is required, so we keep K; otherwise, we discard it (never).
* [keyof T] at the end creates a union of the kept keys.
*/
/**
* Helper type to extract the keys of T that are optional.
* It iterates through each key K in T. If Pick<T, K> can be assigned an empty object {},
* it means K is optional (or potentially missing), so we keep K; otherwise, we discard it (never).
* [keyof T] at the end creates a union of the kept keys.
*/
/**
* Helper type to ensure keys of D exist in T.
* For each key K in D, if K is also a key of T, keep the type D[K].
* If K is NOT a key of T, map it to type `never`.
* An object cannot have a property of type `never`, effectively disallowing extra keys.
*/
/**
* This type will take a source type `Props` and a default type `Defaults` and will return a new type
* where all properties that are optional in `Props` but required in `Defaults` are made required in the result.
* Properties that are required in `Props` and optional in `Defaults` will remain required.
* Properties that are optional in both `Props` and `Defaults` will remain optional.
*
* This is useful for creating a type that represents the resolved props of a component with default props.
*/
//#endregion
//#region node_modules/es-toolkit/dist/function/noop.mjs
function noop() {}

//#endregion
//#region node_modules/es-toolkit/dist/predicate/isNotNil.mjs
function isNotNil(x$1) {
	return x$1 != null;
}

//#endregion
//#region node_modules/recharts/es6/animation/util.js
function ownKeys$48(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$48(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$48(Object(t), !0).forEach(function(r$2) {
			_defineProperty$50(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$48(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$50(e, r$1, t) {
	return (r$1 = _toPropertyKey$50(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$50(t) {
	var i = _toPrimitive$50(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$50(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var getDashCase = (name) => name.replace(/([A-Z])/g, (v) => "-".concat(v.toLowerCase()));
var getTransitionVal = (props, duration, easing) => props.map((prop) => "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing)).join(",");
/**
* Finds the intersection of keys between two objects
* @param {object} preObj previous object
* @param {object} nextObj next object
* @returns an array of keys that exist in both objects
*/
var getIntersectionKeys = (preObj, nextObj) => [Object.keys(preObj), Object.keys(nextObj)].reduce((a$1, b) => a$1.filter((c$1) => b.includes(c$1)));
/**
* Maps an object to another object
* @param {function} fn function to map
* @param {object} obj object to map
* @returns mapped object
*/
var mapObject = (fn, obj) => Object.keys(obj).reduce((res, key) => _objectSpread$48(_objectSpread$48({}, res), {}, { [key]: fn(key, obj[key]) }), {});

//#endregion
//#region node_modules/recharts/es6/animation/configUpdate.js
function ownKeys$47(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$47(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$47(Object(t), !0).forEach(function(r$2) {
			_defineProperty$49(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$47(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$49(e, r$1, t) {
	return (r$1 = _toPropertyKey$49(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$49(t) {
	var i = _toPrimitive$49(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$49(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var alpha = (begin, end, k$1) => begin + (end - begin) * k$1;
var needContinue = (_ref$1) => {
	var { from: from$1, to: to$1 } = _ref$1;
	return from$1 !== to$1;
};
var calStepperVals = (easing, preVals, steps) => {
	var nextStepVals = mapObject((key, val) => {
		if (needContinue(val)) {
			var [newX, newV] = easing(val.from, val.to, val.velocity);
			return _objectSpread$47(_objectSpread$47({}, val), {}, {
				from: newX,
				velocity: newV
			});
		}
		return val;
	}, preVals);
	if (steps < 1) return mapObject((key, val) => {
		if (needContinue(val)) return _objectSpread$47(_objectSpread$47({}, val), {}, {
			velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
			from: alpha(val.from, nextStepVals[key].from, steps)
		});
		return val;
	}, preVals);
	return calStepperVals(easing, nextStepVals, steps - 1);
};
function createStepperUpdate(from$1, to$1, easing, interKeys, render, timeoutController) {
	var preTime;
	var stepperStyle = interKeys.reduce((res, key) => _objectSpread$47(_objectSpread$47({}, res), {}, { [key]: {
		from: from$1[key],
		velocity: 0,
		to: to$1[key]
	} }), {});
	var getCurrStyle = () => mapObject((key, val) => val.from, stepperStyle);
	var shouldStopAnimation = () => !Object.values(stepperStyle).filter(needContinue).length;
	var stopAnimation = null;
	var stepperUpdate = (now) => {
		if (!preTime) preTime = now;
		var steps = (now - preTime) / easing.dt;
		stepperStyle = calStepperVals(easing, stepperStyle, steps);
		render(_objectSpread$47(_objectSpread$47(_objectSpread$47({}, from$1), to$1), getCurrStyle()));
		preTime = now;
		if (!shouldStopAnimation()) stopAnimation = timeoutController.setTimeout(stepperUpdate);
	};
	return () => {
		stopAnimation = timeoutController.setTimeout(stepperUpdate);
		return () => {
			stopAnimation();
		};
	};
}
function createTimingUpdate(from$1, to$1, easing, duration, interKeys, render, timeoutController) {
	var stopAnimation = null;
	var timingStyle = interKeys.reduce((res, key) => _objectSpread$47(_objectSpread$47({}, res), {}, { [key]: [from$1[key], to$1[key]] }), {});
	var beginTime;
	var timingUpdate = (now) => {
		if (!beginTime) beginTime = now;
		var t = (now - beginTime) / duration;
		var currStyle = mapObject((key, val) => alpha(...val, easing(t)), timingStyle);
		render(_objectSpread$47(_objectSpread$47(_objectSpread$47({}, from$1), to$1), currStyle));
		if (t < 1) stopAnimation = timeoutController.setTimeout(timingUpdate);
		else {
			var finalStyle = mapObject((key, val) => alpha(...val, easing(1)), timingStyle);
			render(_objectSpread$47(_objectSpread$47(_objectSpread$47({}, from$1), to$1), finalStyle));
		}
	};
	return () => {
		stopAnimation = timeoutController.setTimeout(timingUpdate);
		return () => {
			stopAnimation();
		};
	};
}
var configUpdate_default = (from$1, to$1, easing, duration, render, timeoutController) => {
	var interKeys = getIntersectionKeys(from$1, to$1);
	return easing.isStepper === true ? createStepperUpdate(from$1, to$1, easing, interKeys, render, timeoutController) : createTimingUpdate(from$1, to$1, easing, duration, interKeys, render, timeoutController);
};

//#endregion
//#region node_modules/recharts/es6/animation/easing.js
var ACCURACY = 1e-4;
var cubicBezierFactor = (c1, c2) => [
	0,
	3 * c1,
	3 * c2 - 6 * c1,
	3 * c1 - 3 * c2 + 1
];
var evaluatePolynomial = (params, t) => params.map((param, i) => param * t ** i).reduce((pre, curr) => pre + curr);
var cubicBezier = (c1, c2) => (t) => {
	var params = cubicBezierFactor(c1, c2);
	return evaluatePolynomial(params, t);
};
var derivativeCubicBezier = (c1, c2) => (t) => {
	var newParams = [...cubicBezierFactor(c1, c2).map((param, i) => param * i).slice(1), 0];
	return evaluatePolynomial(newParams, t);
};
var configBezier = function configBezier$1() {
	var x1, x2, y1, y2;
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
	if (args.length === 1) switch (args[0]) {
		case "linear":
			[x1, y1, x2, y2] = [
				0,
				0,
				1,
				1
			];
			break;
		case "ease":
			[x1, y1, x2, y2] = [
				.25,
				.1,
				.25,
				1
			];
			break;
		case "ease-in":
			[x1, y1, x2, y2] = [
				.42,
				0,
				1,
				1
			];
			break;
		case "ease-out":
			[x1, y1, x2, y2] = [
				.42,
				0,
				.58,
				1
			];
			break;
		case "ease-in-out":
			[x1, y1, x2, y2] = [
				0,
				0,
				.58,
				1
			];
			break;
		default:
			var easing = args[0].split("(");
			if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) [x1, y1, x2, y2] = easing[1].split(")")[0].split(",").map((x$1) => parseFloat(x$1));
	}
	else if (args.length === 4) [x1, y1, x2, y2] = args;
	var curveX = cubicBezier(x1, x2);
	var curveY = cubicBezier(y1, y2);
	var derCurveX = derivativeCubicBezier(x1, x2);
	var rangeValue = (value) => {
		if (value > 1) return 1;
		if (value < 0) return 0;
		return value;
	};
	var bezier = (_t) => {
		var t = _t > 1 ? 1 : _t;
		var x$1 = t;
		for (var i = 0; i < 8; ++i) {
			var evalT = curveX(x$1) - t;
			var derVal = derCurveX(x$1);
			if (Math.abs(evalT - t) < ACCURACY || derVal < ACCURACY) return curveY(x$1);
			x$1 = rangeValue(x$1 - evalT / derVal);
		}
		return curveY(x$1);
	};
	bezier.isStepper = false;
	return bezier;
};
var configSpring = function configSpring$1() {
	var { stiff = 100, damping = 8, dt = 17 } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
	var stepper = (currX, destX, currV) => {
		var FSpring = -(currX - destX) * stiff;
		var FDamping = currV * damping;
		var newV = currV + (FSpring - FDamping) * dt / 1e3;
		var newX = currV * dt / 1e3 + currX;
		if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) return [destX, 0];
		return [newX, newV];
	};
	stepper.isStepper = true;
	stepper.dt = dt;
	return stepper;
};
var configEasing = (easing) => {
	if (typeof easing === "string") switch (easing) {
		case "ease":
		case "ease-in-out":
		case "ease-out":
		case "ease-in":
		case "linear": return configBezier(easing);
		case "spring": return configSpring();
		default: if (easing.split("(")[0] === "cubic-bezier") return configBezier(easing);
	}
	if (typeof easing === "function") return easing;
	return null;
};

//#endregion
//#region node_modules/recharts/es6/animation/AnimationManager.js
/**
* Represents a single item in the ReactSmoothQueue.
* The item can be:
* - A number representing a delay in milliseconds.
* - An object representing a style change
* - A StartAnimationFunction that starts eased transition and calls different render
*      because of course in Recharts we have to have three ways to do everything
* - An arbitrary function to be executed
*/
function createAnimateManager(timeoutController) {
	var currStyle;
	var handleChange = () => null;
	var shouldStop = false;
	var cancelTimeout = null;
	var setStyle = (_style) => {
		if (shouldStop) return;
		if (Array.isArray(_style)) {
			if (!_style.length) return;
			var [curr, ...restStyles] = _style;
			if (typeof curr === "number") {
				cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles), curr);
				return;
			}
			setStyle(curr);
			cancelTimeout = timeoutController.setTimeout(setStyle.bind(null, restStyles));
			return;
		}
		if (typeof _style === "string") {
			currStyle = _style;
			handleChange(currStyle);
		}
		if (typeof _style === "object") {
			currStyle = _style;
			handleChange(currStyle);
		}
		if (typeof _style === "function") _style();
	};
	return {
		stop: () => {
			shouldStop = true;
		},
		start: (style) => {
			shouldStop = false;
			if (cancelTimeout) {
				cancelTimeout();
				cancelTimeout = null;
			}
			setStyle(style);
		},
		subscribe: (_handleChange) => {
			handleChange = _handleChange;
			return () => {
				handleChange = () => null;
			};
		},
		getTimeoutController: () => timeoutController
	};
}

//#endregion
//#region node_modules/recharts/es6/animation/timeoutController.js
/**
* Callback type for the timeout function.
* Receives current time in milliseconds as an argument.
*/
/**
* A function that, when called, cancels the timeout.
*/
var RequestAnimationFrameTimeoutController = class {
	setTimeout(callback) {
		var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
		var startTime = performance.now();
		var requestId = null;
		var executeCallback = (now) => {
			if (now - startTime >= delay) callback(now);
			else if (typeof requestAnimationFrame === "function") requestId = requestAnimationFrame(executeCallback);
		};
		requestId = requestAnimationFrame(executeCallback);
		return () => {
			cancelAnimationFrame(requestId);
		};
	}
};

//#endregion
//#region node_modules/recharts/es6/animation/createDefaultAnimationManager.js
function createDefaultAnimationManager() {
	return createAnimateManager(new RequestAnimationFrameTimeoutController());
}

//#endregion
//#region node_modules/recharts/es6/animation/useAnimationManager.js
var AnimationManagerContext = /* @__PURE__ */ (0, import_react.createContext)(createDefaultAnimationManager);
function useAnimationManager(animationId, animationManagerFromProps) {
	var contextAnimationManager = (0, import_react.useContext)(AnimationManagerContext);
	return (0, import_react.useMemo)(() => animationManagerFromProps !== null && animationManagerFromProps !== void 0 ? animationManagerFromProps : contextAnimationManager(animationId), [
		animationId,
		animationManagerFromProps,
		contextAnimationManager
	]);
}

//#endregion
//#region node_modules/recharts/es6/animation/JavascriptAnimate.js
var defaultJavascriptAnimateProps = {
	begin: 0,
	duration: 1e3,
	easing: "ease",
	isActive: true,
	canBegin: true,
	onAnimationEnd: () => {},
	onAnimationStart: () => {}
};
var from = { t: 0 };
var to = { t: 1 };
function JavascriptAnimate(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultJavascriptAnimateProps);
	var { isActive, canBegin, duration, easing, begin, onAnimationEnd, onAnimationStart, children } = props;
	var animationManager = useAnimationManager(props.animationId, props.animationManager);
	var [style, setStyle] = (0, import_react.useState)(isActive ? from : to);
	var stopJSAnimation = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		if (!isActive) setStyle(to);
	}, [isActive]);
	(0, import_react.useEffect)(() => {
		if (!isActive || !canBegin) return noop;
		var startAnimation = configUpdate_default(from, to, configEasing(easing), duration, setStyle, animationManager.getTimeoutController());
		var onAnimationActive = () => {
			stopJSAnimation.current = startAnimation();
		};
		animationManager.start([
			onAnimationStart,
			begin,
			onAnimationActive,
			duration,
			onAnimationEnd
		]);
		return () => {
			animationManager.stop();
			if (stopJSAnimation.current) stopJSAnimation.current();
			onAnimationEnd();
		};
	}, [
		isActive,
		canBegin,
		duration,
		easing,
		begin,
		onAnimationStart,
		onAnimationEnd,
		animationManager
	]);
	return children(style.t);
}

//#endregion
//#region node_modules/recharts/es6/util/useAnimationId.js
/**
* This hook returns a unique animation id for the object input.
* If input changes (as in, reference equality is different), the animation id will change.
* If input does not change, the animation id will not change.
*
* This is useful for animations. The Animate component
* does have a `shouldReAnimate` prop but that doesn't seem to be doing what the name implies.
* Also, we don't always want to re-animate on every render;
* we only want to re-animate when the input changes. Not the internal state (e.g. `isAnimating`).
*
* @param input The object to check for changes. Uses reference equality (=== operator)
* @param prefix Optional prefix to use for the animation id
* @returns A unique animation id
*/
function useAnimationId(input) {
	var prefix$2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "animation-";
	var animationId = (0, import_react.useRef)(uniqueId(prefix$2));
	var prevProps = (0, import_react.useRef)(input);
	if (prevProps.current !== input) {
		animationId.current = uniqueId(prefix$2);
		prevProps.current = input;
	}
	return animationId.current;
}

//#endregion
//#region node_modules/recharts/es6/shape/Rectangle.js
var _excluded$31 = ["radius"], _excluded2$15 = ["radius"];
function ownKeys$46(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$46(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$46(Object(t), !0).forEach(function(r$2) {
			_defineProperty$48(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$46(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$48(e, r$1, t) {
	return (r$1 = _toPropertyKey$48(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$48(t) {
	var i = _toPrimitive$48(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$48(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$39() {
	return _extends$39 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$39.apply(null, arguments);
}
function _objectWithoutProperties$31(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$31(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$31(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var getRectanglePath = (x$1, y$1, width, height, radius) => {
	var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
	var ySign = height >= 0 ? 1 : -1;
	var xSign = width >= 0 ? 1 : -1;
	var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
	var path$1;
	if (maxRadius > 0 && radius instanceof Array) {
		var newRadius = [
			0,
			0,
			0,
			0
		];
		for (var i = 0, len = 4; i < len; i++) newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
		path$1 = "M".concat(x$1, ",").concat(y$1 + ySign * newRadius[0]);
		if (newRadius[0] > 0) path$1 += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * newRadius[0], ",").concat(y$1);
		path$1 += "L ".concat(x$1 + width - xSign * newRadius[1], ",").concat(y$1);
		if (newRadius[1] > 0) path$1 += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width, ",").concat(y$1 + ySign * newRadius[1]);
		path$1 += "L ".concat(x$1 + width, ",").concat(y$1 + height - ySign * newRadius[2]);
		if (newRadius[2] > 0) path$1 += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x$1 + width - xSign * newRadius[2], ",").concat(y$1 + height);
		path$1 += "L ".concat(x$1 + xSign * newRadius[3], ",").concat(y$1 + height);
		if (newRadius[3] > 0) path$1 += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x$1, ",").concat(y$1 + height - ySign * newRadius[3]);
		path$1 += "Z";
	} else if (maxRadius > 0 && radius === +radius && radius > 0) {
		var _newRadius = Math.min(maxRadius, radius);
		path$1 = "M ".concat(x$1, ",").concat(y$1 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + xSign * _newRadius, ",").concat(y$1, "\n            L ").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width, ",").concat(y$1 + ySign * _newRadius, "\n            L ").concat(x$1 + width, ",").concat(y$1 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1 + width - xSign * _newRadius, ",").concat(y$1 + height, "\n            L ").concat(x$1 + xSign * _newRadius, ",").concat(y$1 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x$1, ",").concat(y$1 + height - ySign * _newRadius, " Z");
	} else path$1 = "M ".concat(x$1, ",").concat(y$1, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
	return path$1;
};
var defaultProps$9 = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	radius: 0,
	isAnimationActive: false,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Rectangle = (rectangleProps) => {
	var props = resolveDefaultProps(rectangleProps, defaultProps$9);
	var pathRef = (0, import_react.useRef)(null);
	var [totalLength, setTotalLength] = (0, import_react.useState)(-1);
	(0, import_react.useEffect)(() => {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (_unused) {}
	}, []);
	var { x: x$1, y: y$1, width, height, radius, className } = props;
	var { animationEasing, animationDuration, animationBegin, isAnimationActive, isUpdateAnimationActive } = props;
	var prevWidthRef = (0, import_react.useRef)(width);
	var prevHeightRef = (0, import_react.useRef)(height);
	var prevXRef = (0, import_react.useRef)(x$1);
	var prevYRef = (0, import_react.useRef)(y$1);
	var animationIdInput = (0, import_react.useMemo)(() => ({
		x: x$1,
		y: y$1,
		width,
		height,
		radius
	}), [
		x$1,
		y$1,
		width,
		height,
		radius
	]);
	var animationId = useAnimationId(animationIdInput, "rectangle-");
	if (x$1 !== +x$1 || y$1 !== +y$1 || width !== +width || height !== +height || width === 0 || height === 0) return null;
	var layerClass = clsx("recharts-rectangle", className);
	if (!isUpdateAnimationActive) {
		var _svgPropertiesAndEven = svgPropertiesAndEvents(props), { radius: _ } = _svgPropertiesAndEven, otherPathProps = _objectWithoutProperties$31(_svgPropertiesAndEven, _excluded$31);
		return /* @__PURE__ */ import_react.createElement("path", _extends$39({}, otherPathProps, {
			radius: typeof radius === "number" ? radius : void 0,
			className: layerClass,
			d: getRectanglePath(x$1, y$1, width, height, radius)
		}));
	}
	var prevWidth = prevWidthRef.current;
	var prevHeight = prevHeightRef.current;
	var prevX = prevXRef.current;
	var prevY = prevYRef.current;
	var from$1 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
	var to$1 = "".concat(totalLength, "px 0px");
	var transition = getTransitionVal(["strokeDasharray"], animationDuration, typeof animationEasing === "string" ? animationEasing : void 0);
	return /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		key: animationId,
		canBegin: totalLength > 0,
		duration: animationDuration,
		easing: animationEasing,
		isActive: isUpdateAnimationActive,
		begin: animationBegin
	}, (t) => {
		var currWidth = interpolate(prevWidth, width, t);
		var currHeight = interpolate(prevHeight, height, t);
		var currX = interpolate(prevX, x$1, t);
		var currY = interpolate(prevY, y$1, t);
		if (pathRef.current) {
			prevWidthRef.current = currWidth;
			prevHeightRef.current = currHeight;
			prevXRef.current = currX;
			prevYRef.current = currY;
		}
		var animationStyle;
		if (!isAnimationActive) animationStyle = { strokeDasharray: to$1 };
		else if (t > 0) animationStyle = {
			transition,
			strokeDasharray: to$1
		};
		else animationStyle = { strokeDasharray: from$1 };
		var _svgPropertiesAndEven2 = svgPropertiesAndEvents(props), { radius: _$1 } = _svgPropertiesAndEven2, otherPathProps$1 = _objectWithoutProperties$31(_svgPropertiesAndEven2, _excluded2$15);
		return /* @__PURE__ */ import_react.createElement("path", _extends$39({}, otherPathProps$1, {
			radius: typeof radius === "number" ? radius : void 0,
			className: layerClass,
			d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
			ref: pathRef,
			style: _objectSpread$46(_objectSpread$46({}, animationStyle), props.style)
		}));
	});
};

//#endregion
//#region node_modules/recharts/es6/util/cursor/getRadialCursorPoints.js
/**
* Only applicable for radial layouts
* @param {Object} activeCoordinate ChartCoordinate
* @returns {Object} RadialCursorPoints
*/
function getRadialCursorPoints(activeCoordinate) {
	var { cx, cy, radius, startAngle, endAngle } = activeCoordinate;
	var startPoint = polarToCartesian(cx, cy, radius, startAngle);
	var endPoint = polarToCartesian(cx, cy, radius, endAngle);
	return {
		points: [startPoint, endPoint],
		cx,
		cy,
		radius,
		startAngle,
		endAngle
	};
}

//#endregion
//#region node_modules/recharts/es6/shape/Sector.js
function _extends$38() {
	return _extends$38 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$38.apply(null, arguments);
}
var getDeltaAngle$1 = (startAngle, endAngle) => {
	var sign$1 = mathSign(endAngle - startAngle);
	var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
	return sign$1 * deltaAngle;
};
var getTangentCircle = (_ref$1) => {
	var { cx, cy, radius, angle, sign: sign$1, isExternal, cornerRadius, cornerIsExternal } = _ref$1;
	var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
	var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
	var centerAngle = cornerIsExternal ? angle : angle + sign$1 * theta;
	var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
	var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
	var lineTangencyAngle = cornerIsExternal ? angle - sign$1 * theta : angle;
	var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
	return {
		center,
		circleTangency,
		lineTangency,
		theta
	};
};
var getSectorPath = (_ref2) => {
	var { cx, cy, innerRadius, outerRadius, startAngle, endAngle } = _ref2;
	var angle = getDeltaAngle$1(startAngle, endAngle);
	var tempEndAngle = startAngle + angle;
	var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
	var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
	var path$1 = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
	if (innerRadius > 0) {
		var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
		var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
		path$1 += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
	} else path$1 += "L ".concat(cx, ",").concat(cy, " Z");
	return path$1;
};
var getSectorWithCorner = (_ref3) => {
	var { cx, cy, innerRadius, outerRadius, cornerRadius, forceCornerRadius, cornerIsExternal, startAngle, endAngle } = _ref3;
	var sign$1 = mathSign(endAngle - startAngle);
	var { circleTangency: soct, lineTangency: solt, theta: sot } = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: startAngle,
		sign: sign$1,
		cornerRadius,
		cornerIsExternal
	});
	var { circleTangency: eoct, lineTangency: eolt, theta: eot } = getTangentCircle({
		cx,
		cy,
		radius: outerRadius,
		angle: endAngle,
		sign: -sign$1,
		cornerRadius,
		cornerIsExternal
	});
	var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
	if (outerArcAngle < 0) {
		if (forceCornerRadius) return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
		return getSectorPath({
			cx,
			cy,
			innerRadius,
			outerRadius,
			startAngle,
			endAngle
		});
	}
	var path$1 = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign$1 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
	if (innerRadius > 0) {
		var { circleTangency: sict, lineTangency: silt, theta: sit } = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: startAngle,
			sign: sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		});
		var { circleTangency: eict, lineTangency: eilt, theta: eit } = getTangentCircle({
			cx,
			cy,
			radius: innerRadius,
			angle: endAngle,
			sign: -sign$1,
			isExternal: true,
			cornerRadius,
			cornerIsExternal
		});
		var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
		if (innerArcAngle < 0 && cornerRadius === 0) return "".concat(path$1, "L").concat(cx, ",").concat(cy, "Z");
		path$1 += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign$1 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign$1 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
	} else path$1 += "L".concat(cx, ",").concat(cy, "Z");
	return path$1;
};
/**
* SVG cx, cy are `string | number | undefined`, but internally we use `number` so let's
* override the types here.
*/
var defaultProps$8 = {
	cx: 0,
	cy: 0,
	innerRadius: 0,
	outerRadius: 0,
	startAngle: 0,
	endAngle: 0,
	cornerRadius: 0,
	forceCornerRadius: false,
	cornerIsExternal: false
};
var Sector = (sectorProps) => {
	var props = resolveDefaultProps(sectorProps, defaultProps$8);
	var { cx, cy, innerRadius, outerRadius, cornerRadius, forceCornerRadius, cornerIsExternal, startAngle, endAngle, className } = props;
	if (outerRadius < innerRadius || startAngle === endAngle) return null;
	var layerClass = clsx("recharts-sector", className);
	var deltaRadius = outerRadius - innerRadius;
	var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
	var path$1;
	if (cr > 0 && Math.abs(startAngle - endAngle) < 360) path$1 = getSectorWithCorner({
		cx,
		cy,
		innerRadius,
		outerRadius,
		cornerRadius: Math.min(cr, deltaRadius / 2),
		forceCornerRadius,
		cornerIsExternal,
		startAngle,
		endAngle
	});
	else path$1 = getSectorPath({
		cx,
		cy,
		innerRadius,
		outerRadius,
		startAngle,
		endAngle
	});
	return /* @__PURE__ */ import_react.createElement("path", _extends$38({}, svgPropertiesAndEvents(props), {
		className: layerClass,
		d: path$1
	}));
};

//#endregion
//#region node_modules/recharts/es6/util/cursor/getCursorPoints.js
function getCursorPoints(layout, activeCoordinate, offset) {
	var x1, y1, x2, y2;
	if (layout === "horizontal") {
		x1 = activeCoordinate.x;
		x2 = x1;
		y1 = offset.top;
		y2 = offset.top + offset.height;
	} else if (layout === "vertical") {
		y1 = activeCoordinate.y;
		y2 = y1;
		x1 = offset.left;
		x2 = offset.left + offset.width;
	} else if (activeCoordinate.cx != null && activeCoordinate.cy != null) if (layout === "centric") {
		var { cx, cy, innerRadius, outerRadius, angle } = activeCoordinate;
		var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
		var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
		x1 = innerPoint.x;
		y1 = innerPoint.y;
		x2 = outerPoint.x;
		y2 = outerPoint.y;
	} else return getRadialCursorPoints(activeCoordinate);
	return [{
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	}];
}

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/toNumber.js
var require_toNumber = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/toNumber.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isSymbol = require_isSymbol();
	function toNumber$1(value) {
		if (isSymbol.isSymbol(value)) return NaN;
		return Number(value);
	}
	exports.toNumber = toNumber$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/toFinite.js
var require_toFinite = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/toFinite.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var toNumber = require_toNumber();
	function toFinite$2(value) {
		if (!value) return value === 0 ? value : 0;
		value = toNumber.toNumber(value);
		if (value === Infinity || value === -Infinity) return (value < 0 ? -1 : 1) * Number.MAX_VALUE;
		return value === value ? value : 0;
	}
	exports.toFinite = toFinite$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/math/range.js
var require_range$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/math/range.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isIterateeCall = require_isIterateeCall();
	var toFinite$1 = require_toFinite();
	function range$4(start, end, step) {
		if (step && typeof step !== "number" && isIterateeCall.isIterateeCall(start, end, step)) end = step = void 0;
		start = toFinite$1.toFinite(start);
		if (end === void 0) {
			end = start;
			start = 0;
		} else end = toFinite$1.toFinite(end);
		step = step === void 0 ? start < end ? 1 : -1 : toFinite$1.toFinite(step);
		const length = Math.max(Math.ceil((end - start) / (step || 1)), 0);
		const result = new Array(length);
		for (let index = 0; index < length; index++) {
			result[index] = start;
			start += step;
		}
		return result;
	}
	exports.range = range$4;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/range.js
var require_range = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/range.js": ((exports, module) => {
	module.exports = require_range$1().range;
}) });

//#endregion
//#region node_modules/d3-array/src/ascending.js
function ascending(a$1, b) {
	return a$1 == null || b == null ? NaN : a$1 < b ? -1 : a$1 > b ? 1 : a$1 >= b ? 0 : NaN;
}

//#endregion
//#region node_modules/d3-array/src/descending.js
function descending(a$1, b) {
	return a$1 == null || b == null ? NaN : b < a$1 ? -1 : b > a$1 ? 1 : b >= a$1 ? 0 : NaN;
}

//#endregion
//#region node_modules/d3-array/src/bisector.js
function bisector(f) {
	let compare1, compare2, delta;
	if (f.length !== 2) {
		compare1 = ascending;
		compare2 = (d, x$1) => ascending(f(d), x$1);
		delta = (d, x$1) => f(d) - x$1;
	} else {
		compare1 = f === ascending || f === descending ? f : zero$1;
		compare2 = f;
		delta = f;
	}
	function left(a$1, x$1, lo = 0, hi = a$1.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$1[mid], x$1) < 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function right(a$1, x$1, lo = 0, hi = a$1.length) {
		if (lo < hi) {
			if (compare1(x$1, x$1) !== 0) return hi;
			do {
				const mid = lo + hi >>> 1;
				if (compare2(a$1[mid], x$1) <= 0) lo = mid + 1;
				else hi = mid;
			} while (lo < hi);
		}
		return lo;
	}
	function center(a$1, x$1, lo = 0, hi = a$1.length) {
		const i = left(a$1, x$1, lo, hi - 1);
		return i > lo && delta(a$1[i - 1], x$1) > -delta(a$1[i], x$1) ? i - 1 : i;
	}
	return {
		left,
		center,
		right
	};
}
function zero$1() {
	return 0;
}

//#endregion
//#region node_modules/d3-array/src/number.js
function number$2(x$1) {
	return x$1 === null ? NaN : +x$1;
}
function* numbers(values, valueof) {
	if (valueof === void 0) {
		for (let value of values) if (value != null && (value = +value) >= value) yield value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) yield value;
	}
}

//#endregion
//#region node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
const bisectLeft = ascendingBisect.left;
const bisectCenter = bisector(number$2).center;
var bisect_default = bisectRight;

//#endregion
//#region node_modules/internmap/src/index.js
var InternMap = class extends Map {
	constructor(entries, key = keyof) {
		super();
		Object.defineProperties(this, {
			_intern: { value: /* @__PURE__ */ new Map() },
			_key: { value: key }
		});
		if (entries != null) for (const [key$1, value] of entries) this.set(key$1, value);
	}
	get(key) {
		return super.get(intern_get(this, key));
	}
	has(key) {
		return super.has(intern_get(this, key));
	}
	set(key, value) {
		return super.set(intern_set(this, key), value);
	}
	delete(key) {
		return super.delete(intern_delete(this, key));
	}
};
function intern_get({ _intern, _key }, value) {
	const key = _key(value);
	return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) return _intern.get(key);
	_intern.set(key, value);
	return value;
}
function intern_delete({ _intern, _key }, value) {
	const key = _key(value);
	if (_intern.has(key)) {
		value = _intern.get(key);
		_intern.delete(key);
	}
	return value;
}
function keyof(value) {
	return value !== null && typeof value === "object" ? value.valueOf() : value;
}

//#endregion
//#region node_modules/d3-array/src/sort.js
function compareDefined(compare = ascending) {
	if (compare === ascending) return ascendingDefined;
	if (typeof compare !== "function") throw new TypeError("compare is not a function");
	return (a$1, b) => {
		const x$1 = compare(a$1, b);
		if (x$1 || x$1 === 0) return x$1;
		return (compare(b, b) === 0) - (compare(a$1, a$1) === 0);
	};
}
function ascendingDefined(a$1, b) {
	return (a$1 == null || !(a$1 >= a$1)) - (b == null || !(b >= b)) || (a$1 < b ? -1 : a$1 > b ? 1 : 0);
}

//#endregion
//#region node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
	const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
	let i1, i2, inc;
	if (power < 0) {
		inc = Math.pow(10, -power) / factor;
		i1 = Math.round(start * inc);
		i2 = Math.round(stop * inc);
		if (i1 / inc < start) ++i1;
		if (i2 / inc > stop) --i2;
		inc = -inc;
	} else {
		inc = Math.pow(10, power) * factor;
		i1 = Math.round(start / inc);
		i2 = Math.round(stop / inc);
		if (i1 * inc < start) ++i1;
		if (i2 * inc > stop) --i2;
	}
	if (i2 < i1 && .5 <= count && count < 2) return tickSpec(start, stop, count * 2);
	return [
		i1,
		i2,
		inc
	];
}
function ticks(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	if (!(count > 0)) return [];
	if (start === stop) return [start];
	const reverse$1 = stop < start, [i1, i2, inc] = reverse$1 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
	if (!(i2 >= i1)) return [];
	const n = i2 - i1 + 1, ticks$1 = new Array(n);
	if (reverse$1) if (inc < 0) for (let i = 0; i < n; ++i) ticks$1[i] = (i2 - i) / -inc;
	else for (let i = 0; i < n; ++i) ticks$1[i] = (i2 - i) * inc;
	else if (inc < 0) for (let i = 0; i < n; ++i) ticks$1[i] = (i1 + i) / -inc;
	else for (let i = 0; i < n; ++i) ticks$1[i] = (i1 + i) * inc;
	return ticks$1;
}
function tickIncrement(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
	stop = +stop, start = +start, count = +count;
	const reverse$1 = stop < start, inc = reverse$1 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
	return (reverse$1 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

//#endregion
//#region node_modules/d3-array/src/max.js
function max(values, valueof) {
	let max$1;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (max$1 < value || max$1 === void 0 && value >= value)) max$1 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (max$1 < value || max$1 === void 0 && value >= value)) max$1 = value;
	}
	return max$1;
}

//#endregion
//#region node_modules/d3-array/src/min.js
function min(values, valueof) {
	let min$1;
	if (valueof === void 0) {
		for (const value of values) if (value != null && (min$1 > value || min$1 === void 0 && value >= value)) min$1 = value;
	} else {
		let index = -1;
		for (let value of values) if ((value = valueof(value, ++index, values)) != null && (min$1 > value || min$1 === void 0 && value >= value)) min$1 = value;
	}
	return min$1;
}

//#endregion
//#region node_modules/d3-array/src/quickselect.js
function quickselect(array, k$1, left = 0, right = Infinity, compare) {
	k$1 = Math.floor(k$1);
	left = Math.floor(Math.max(0, left));
	right = Math.floor(Math.min(array.length - 1, right));
	if (!(left <= k$1 && k$1 <= right)) return array;
	compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
	while (right > left) {
		if (right - left > 600) {
			const n = right - left + 1;
			const m = k$1 - left + 1;
			const z = Math.log(n);
			const s$1 = .5 * Math.exp(2 * z / 3);
			const sd = .5 * Math.sqrt(z * s$1 * (n - s$1) / n) * (m - n / 2 < 0 ? -1 : 1);
			const newLeft = Math.max(left, Math.floor(k$1 - m * s$1 / n + sd));
			const newRight = Math.min(right, Math.floor(k$1 + (n - m) * s$1 / n + sd));
			quickselect(array, k$1, newLeft, newRight, compare);
		}
		const t = array[k$1];
		let i = left;
		let j = right;
		swap(array, left, k$1);
		if (compare(array[right], t) > 0) swap(array, left, right);
		while (i < j) {
			swap(array, i, j), ++i, --j;
			while (compare(array[i], t) < 0) ++i;
			while (compare(array[j], t) > 0) --j;
		}
		if (compare(array[left], t) === 0) swap(array, left, j);
		else ++j, swap(array, j, right);
		if (j <= k$1) left = j + 1;
		if (k$1 <= j) right = j - 1;
	}
	return array;
}
function swap(array, i, j) {
	const t = array[i];
	array[i] = array[j];
	array[j] = t;
}

//#endregion
//#region node_modules/d3-array/src/quantile.js
function quantile(values, p, valueof) {
	values = Float64Array.from(numbers(values, valueof));
	if (!(n = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n < 2) return min(values);
	if (p >= 1) return max(values);
	var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
	return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p, valueof = number$2) {
	if (!(n = values.length) || isNaN(p = +p)) return;
	if (p <= 0 || n < 2) return +valueof(values[0], 0, values);
	if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
	return value0 + (value1 - value0) * (i - i0);
}

//#endregion
//#region node_modules/d3-array/src/range.js
function range$3(start, stop, step) {
	start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
	var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range$5 = new Array(n);
	while (++i < n) range$5[i] = start + i * step;
	return range$5;
}

//#endregion
//#region node_modules/d3-scale/src/init.js
function initRange(domain, range$5) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			this.range(domain);
			break;
		default:
			this.range(range$5).domain(domain);
			break;
	}
	return this;
}
function initInterpolator(domain, interpolator) {
	switch (arguments.length) {
		case 0: break;
		case 1:
			if (typeof domain === "function") this.interpolator(domain);
			else this.range(domain);
			break;
		default:
			this.domain(domain);
			if (typeof interpolator === "function") this.interpolator(interpolator);
			else this.range(interpolator);
			break;
	}
	return this;
}

//#endregion
//#region node_modules/d3-scale/src/ordinal.js
const implicit = Symbol("implicit");
function ordinal() {
	var index = new InternMap(), domain = [], range$5 = [], unknown = implicit;
	function scale(d) {
		let i = index.get(d);
		if (i === void 0) {
			if (unknown !== implicit) return unknown;
			index.set(d, i = domain.push(d) - 1);
		}
		return range$5[i % range$5.length];
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [], index = new InternMap();
		for (const value of _) {
			if (index.has(value)) continue;
			index.set(value, domain.push(value) - 1);
		}
		return scale;
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), scale) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return ordinal(domain, range$5).unknown(unknown);
	};
	initRange.apply(scale, arguments);
	return scale;
}

//#endregion
//#region node_modules/d3-scale/src/band.js
function band() {
	var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = .5;
	delete scale.unknown;
	function rescale() {
		var n = domain().length, reverse$1 = r1 < r0, start = reverse$1 ? r1 : r0, stop = reverse$1 ? r0 : r1;
		step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
		if (round) step = Math.floor(step);
		start += (stop - start - step * (n - paddingInner)) * align;
		bandwidth = step * (1 - paddingInner);
		if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
		var values = range$3(n).map(function(i) {
			return start + step * i;
		});
		return ordinalRange(reverse$1 ? values.reverse() : values);
	}
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.range = function(_) {
		return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
	};
	scale.rangeRound = function(_) {
		return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
	};
	scale.bandwidth = function() {
		return bandwidth;
	};
	scale.step = function() {
		return step;
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, rescale()) : round;
	};
	scale.padding = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
	};
	scale.paddingInner = function(_) {
		return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
	};
	scale.paddingOuter = function(_) {
		return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
	};
	scale.align = function(_) {
		return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	};
	scale.copy = function() {
		return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
	};
	return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
	var copy$2 = scale.copy;
	scale.padding = scale.paddingOuter;
	delete scale.paddingInner;
	delete scale.paddingOuter;
	scale.copy = function() {
		return pointish(copy$2());
	};
	return scale;
}
function point() {
	return pointish(band.apply(null, arguments).paddingInner(1));
}

//#endregion
//#region node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
	constructor.prototype = factory.prototype = prototype;
	prototype.constructor = constructor;
}
function extend(parent, definition) {
	var prototype = Object.create(parent.prototype);
	for (var key in definition) prototype[key] = definition[key];
	return prototype;
}

//#endregion
//#region node_modules/d3-color/src/color.js
function Color() {}
var darker = .7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = /* @__PURE__ */ new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = /* @__PURE__ */ new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = /* @__PURE__ */ new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = /* @__PURE__ */ new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = /* @__PURE__ */ new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = /* @__PURE__ */ new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
define_default(Color, color, {
	copy(channels) {
		return Object.assign(new this.constructor(), this, channels);
	},
	displayable() {
		return this.rgb().displayable();
	},
	hex: color_formatHex,
	formatHex: color_formatHex,
	formatHex8: color_formatHex8,
	formatHsl: color_formatHsl,
	formatRgb: color_formatRgb,
	toString: color_formatRgb
});
function color_formatHex() {
	return this.rgb().formatHex();
}
function color_formatHex8() {
	return this.rgb().formatHex8();
}
function color_formatHsl() {
	return hslConvert(this).formatHsl();
}
function color_formatRgb() {
	return this.rgb().formatRgb();
}
function color(format$1) {
	var m, l;
	format$1 = (format$1 + "").trim().toLowerCase();
	return (m = reHex.exec(format$1)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format$1)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format$1)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format$1)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format$1)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format$1)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format$1)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format$1) ? rgbn(named[format$1]) : format$1 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
	return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r$1, g, b, a$1) {
	if (a$1 <= 0) r$1 = g = b = NaN;
	return new Rgb(r$1, g, b, a$1);
}
function rgbConvert(o) {
	if (!(o instanceof Color)) o = color(o);
	if (!o) return new Rgb();
	o = o.rgb();
	return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r$1, g, b, opacity) {
	return arguments.length === 1 ? rgbConvert(r$1) : new Rgb(r$1, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r$1, g, b, opacity) {
	this.r = +r$1;
	this.g = +g;
	this.b = +b;
	this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Rgb(this.r * k$1, this.g * k$1, this.b * k$1, this.opacity);
	},
	rgb() {
		return this;
	},
	clamp() {
		return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
	},
	displayable() {
		return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
	},
	hex: rgb_formatHex,
	formatHex: rgb_formatHex,
	formatHex8: rgb_formatHex8,
	formatRgb: rgb_formatRgb,
	toString: rgb_formatRgb
}));
function rgb_formatHex() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
	return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
	const a$1 = clampa(this.opacity);
	return `${a$1 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a$1 === 1 ? ")" : `, ${a$1})`}`;
}
function clampa(opacity) {
	return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
	return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
	value = clampi(value);
	return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s$1, l, a$1) {
	if (a$1 <= 0) h = s$1 = l = NaN;
	else if (l <= 0 || l >= 1) h = s$1 = NaN;
	else if (s$1 <= 0) h = NaN;
	return new Hsl(h, s$1, l, a$1);
}
function hslConvert(o) {
	if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	if (!(o instanceof Color)) o = color(o);
	if (!o) return new Hsl();
	if (o instanceof Hsl) return o;
	o = o.rgb();
	var r$1 = o.r / 255, g = o.g / 255, b = o.b / 255, min$1 = Math.min(r$1, g, b), max$1 = Math.max(r$1, g, b), h = NaN, s$1 = max$1 - min$1, l = (max$1 + min$1) / 2;
	if (s$1) {
		if (r$1 === max$1) h = (g - b) / s$1 + (g < b) * 6;
		else if (g === max$1) h = (b - r$1) / s$1 + 2;
		else h = (r$1 - g) / s$1 + 4;
		s$1 /= l < .5 ? max$1 + min$1 : 2 - max$1 - min$1;
		h *= 60;
	} else s$1 = l > 0 && l < 1 ? 0 : h;
	return new Hsl(h, s$1, l, o.opacity);
}
function hsl(h, s$1, l, opacity) {
	return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s$1, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s$1, l, opacity) {
	this.h = +h;
	this.s = +s$1;
	this.l = +l;
	this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color, {
	brighter(k$1) {
		k$1 = k$1 == null ? brighter : Math.pow(brighter, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	darker(k$1) {
		k$1 = k$1 == null ? darker : Math.pow(darker, k$1);
		return new Hsl(this.h, this.s, this.l * k$1, this.opacity);
	},
	rgb() {
		var h = this.h % 360 + (this.h < 0) * 360, s$1 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < .5 ? l : 1 - l) * s$1, m1 = 2 * l - m2;
		return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
	},
	clamp() {
		return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
	},
	displayable() {
		return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
	},
	formatHsl() {
		const a$1 = clampa(this.opacity);
		return `${a$1 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a$1 === 1 ? ")" : `, ${a$1})`}`;
	}
}));
function clamph(value) {
	value = (value || 0) % 360;
	return value < 0 ? value + 360 : value;
}
function clampt(value) {
	return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
	return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

//#endregion
//#region node_modules/d3-interpolate/src/basis.js
function basis(t1$1, v0, v1, v2, v3) {
	var t2 = t1$1 * t1$1, t3 = t2 * t1$1;
	return ((1 - 3 * t1$1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1$1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}
function basis_default(values) {
	var n = values.length - 1;
	return function(t) {
		var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
	var n = values.length;
	return function(t) {
		var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
		return basis((t - i / n) * n, v0, v1, v2, v3);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/constant.js
var constant_default = (x$1) => () => x$1;

//#endregion
//#region node_modules/d3-interpolate/src/color.js
function linear$1(a$1, d) {
	return function(t) {
		return a$1 + t * d;
	};
}
function exponential(a$1, b, y$1) {
	return a$1 = Math.pow(a$1, y$1), b = Math.pow(b, y$1) - a$1, y$1 = 1 / y$1, function(t) {
		return Math.pow(a$1 + t * b, y$1);
	};
}
function gamma(y$1) {
	return (y$1 = +y$1) === 1 ? nogamma : function(a$1, b) {
		return b - a$1 ? exponential(a$1, b, y$1) : constant_default(isNaN(a$1) ? b : a$1);
	};
}
function nogamma(a$1, b) {
	var d = b - a$1;
	return d ? linear$1(a$1, d) : constant_default(isNaN(a$1) ? b : a$1);
}

//#endregion
//#region node_modules/d3-interpolate/src/rgb.js
var rgb_default = (function rgbGamma(y$1) {
	var color$1 = gamma(y$1);
	function rgb$1(start, end) {
		var r$1 = color$1((start = rgb(start)).r, (end = rgb(end)).r), g = color$1(start.g, end.g), b = color$1(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
		return function(t) {
			start.r = r$1(t);
			start.g = g(t);
			start.b = b(t);
			start.opacity = opacity(t);
			return start + "";
		};
	}
	rgb$1.gamma = rgbGamma;
	return rgb$1;
})(1);
function rgbSpline(spline) {
	return function(colors) {
		var n = colors.length, r$1 = new Array(n), g = new Array(n), b = new Array(n), i, color$1;
		for (i = 0; i < n; ++i) {
			color$1 = rgb(colors[i]);
			r$1[i] = color$1.r || 0;
			g[i] = color$1.g || 0;
			b[i] = color$1.b || 0;
		}
		r$1 = spline(r$1);
		g = spline(g);
		b = spline(b);
		color$1.opacity = 1;
		return function(t) {
			color$1.r = r$1(t);
			color$1.g = g(t);
			color$1.b = b(t);
			return color$1 + "";
		};
	};
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

//#endregion
//#region node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a$1, b) {
	if (!b) b = [];
	var n = a$1 ? Math.min(b.length, a$1.length) : 0, c$1 = b.slice(), i;
	return function(t) {
		for (i = 0; i < n; ++i) c$1[i] = a$1[i] * (1 - t) + b[i] * t;
		return c$1;
	};
}
function isNumberArray(x$1) {
	return ArrayBuffer.isView(x$1) && !(x$1 instanceof DataView);
}

//#endregion
//#region node_modules/d3-interpolate/src/array.js
function genericArray(a$1, b) {
	var nb = b ? b.length : 0, na = a$1 ? Math.min(nb, a$1.length) : 0, x$1 = new Array(na), c$1 = new Array(nb), i;
	for (i = 0; i < na; ++i) x$1[i] = value_default(a$1[i], b[i]);
	for (; i < nb; ++i) c$1[i] = b[i];
	return function(t) {
		for (i = 0; i < na; ++i) c$1[i] = x$1[i](t);
		return c$1;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/date.js
function date_default(a$1, b) {
	var d = /* @__PURE__ */ new Date();
	return a$1 = +a$1, b = +b, function(t) {
		return d.setTime(a$1 * (1 - t) + b * t), d;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/number.js
function number_default(a$1, b) {
	return a$1 = +a$1, b = +b, function(t) {
		return a$1 * (1 - t) + b * t;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/object.js
function object_default(a$1, b) {
	var i = {}, c$1 = {}, k$1;
	if (a$1 === null || typeof a$1 !== "object") a$1 = {};
	if (b === null || typeof b !== "object") b = {};
	for (k$1 in b) if (k$1 in a$1) i[k$1] = value_default(a$1[k$1], b[k$1]);
	else c$1[k$1] = b[k$1];
	return function(t) {
		for (k$1 in i) c$1[k$1] = i[k$1](t);
		return c$1;
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
	return function() {
		return b;
	};
}
function one(b) {
	return function(t) {
		return b(t) + "";
	};
}
function string_default(a$1, b) {
	var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s$1 = [], q = [];
	a$1 = a$1 + "", b = b + "";
	while ((am = reA.exec(a$1)) && (bm = reB.exec(b))) {
		if ((bs = bm.index) > bi) {
			bs = b.slice(bi, bs);
			if (s$1[i]) s$1[i] += bs;
			else s$1[++i] = bs;
		}
		if ((am = am[0]) === (bm = bm[0])) if (s$1[i]) s$1[i] += bm;
		else s$1[++i] = bm;
		else {
			s$1[++i] = null;
			q.push({
				i,
				x: number_default(am, bm)
			});
		}
		bi = reB.lastIndex;
	}
	if (bi < b.length) {
		bs = b.slice(bi);
		if (s$1[i]) s$1[i] += bs;
		else s$1[++i] = bs;
	}
	return s$1.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
		for (var i$1 = 0, o; i$1 < b; ++i$1) s$1[(o = q[i$1]).i] = o.x(t);
		return s$1.join("");
	});
}

//#endregion
//#region node_modules/d3-interpolate/src/value.js
function value_default(a$1, b) {
	var t = typeof b, c$1;
	return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c$1 = color(b)) ? (b = c$1, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a$1, b);
}

//#endregion
//#region node_modules/d3-interpolate/src/round.js
function round_default(a$1, b) {
	return a$1 = +a$1, b = +b, function(t) {
		return Math.round(a$1 * (1 - t) + b * t);
	};
}

//#endregion
//#region node_modules/d3-interpolate/src/piecewise.js
function piecewise(interpolate$1, values) {
	if (values === void 0) values = interpolate$1, interpolate$1 = value_default;
	var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
	while (i < n) I[i] = interpolate$1(v, v = values[++i]);
	return function(t) {
		var i$1 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
		return I[i$1](t - i$1);
	};
}

//#endregion
//#region node_modules/d3-scale/src/constant.js
function constants(x$1) {
	return function() {
		return x$1;
	};
}

//#endregion
//#region node_modules/d3-scale/src/number.js
function number$1(x$1) {
	return +x$1;
}

//#endregion
//#region node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity$3(x$1) {
	return x$1;
}
function normalize(a$1, b) {
	return (b -= a$1 = +a$1) ? function(x$1) {
		return (x$1 - a$1) / b;
	} : constants(isNaN(b) ? NaN : .5);
}
function clamper(a$1, b) {
	var t;
	if (a$1 > b) t = a$1, a$1 = b, b = t;
	return function(x$1) {
		return Math.max(a$1, Math.min(b, x$1));
	};
}
function bimap(domain, range$5, interpolate$1) {
	var d0 = domain[0], d1 = domain[1], r0 = range$5[0], r1 = range$5[1];
	if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate$1(r1, r0);
	else d0 = normalize(d0, d1), r0 = interpolate$1(r0, r1);
	return function(x$1) {
		return r0(d0(x$1));
	};
}
function polymap(domain, range$5, interpolate$1) {
	var j = Math.min(domain.length, range$5.length) - 1, d = new Array(j), r$1 = new Array(j), i = -1;
	if (domain[j] < domain[0]) {
		domain = domain.slice().reverse();
		range$5 = range$5.slice().reverse();
	}
	while (++i < j) {
		d[i] = normalize(domain[i], domain[i + 1]);
		r$1[i] = interpolate$1(range$5[i], range$5[i + 1]);
	}
	return function(x$1) {
		var i$1 = bisect_default(domain, x$1, 1, j) - 1;
		return r$1[i$1](d[i$1](x$1));
	};
}
function copy$1(source, target) {
	return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
	var domain = unit, range$5 = unit, interpolate$1 = value_default, transform, untransform, unknown, clamp = identity$3, piecewise$1, output, input;
	function rescale() {
		var n = Math.min(domain.length, range$5.length);
		if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
		piecewise$1 = n > 2 ? polymap : bimap;
		output = input = null;
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : (output || (output = piecewise$1(domain.map(transform), range$5, interpolate$1)))(transform(clamp(x$1)));
	}
	scale.invert = function(y$1) {
		return clamp(untransform((input || (input = piecewise$1(range$5, domain.map(transform), number_default)))(y$1)));
	};
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return range$5 = Array.from(_), interpolate$1 = round_default, rescale();
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
	};
	scale.interpolate = function(_) {
		return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t, u) {
		transform = t, untransform = u;
		return rescale();
	};
}
function continuous() {
	return transformer$2()(identity$3, identity$3);
}

//#endregion
//#region node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x$1) {
	return Math.abs(x$1 = Math.round(x$1)) >= 1e21 ? x$1.toLocaleString("en").replace(/,/g, "") : x$1.toString(10);
}
function formatDecimalParts(x$1, p) {
	if ((i = (x$1 = p ? x$1.toExponential(p - 1) : x$1.toExponential()).indexOf("e")) < 0) return null;
	var i, coefficient = x$1.slice(0, i);
	return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x$1.slice(i + 1)];
}

//#endregion
//#region node_modules/d3-format/src/exponent.js
function exponent_default(x$1) {
	return x$1 = formatDecimalParts(Math.abs(x$1)), x$1 ? x$1[1] : NaN;
}

//#endregion
//#region node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
	return function(value, width) {
		var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
		while (i > 0 && g > 0) {
			if (length + g + 1 > width) g = Math.max(1, width - length);
			t.push(value.substring(i -= g, i + g));
			if ((length += g + 1) > width) break;
			g = grouping[j = (j + 1) % grouping.length];
		}
		return t.reverse().join(thousands);
	};
}

//#endregion
//#region node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
	return function(value) {
		return value.replace(/[0-9]/g, function(i) {
			return numerals[+i];
		});
	};
}

//#endregion
//#region node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
	if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	var match;
	return new FormatSpecifier({
		fill: match[1],
		align: match[2],
		sign: match[3],
		symbol: match[4],
		zero: match[5],
		width: match[6],
		comma: match[7],
		precision: match[8] && match[8].slice(1),
		trim: match[9],
		type: match[10]
	});
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
	this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
	this.align = specifier.align === void 0 ? ">" : specifier.align + "";
	this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
	this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
	this.zero = !!specifier.zero;
	this.width = specifier.width === void 0 ? void 0 : +specifier.width;
	this.comma = !!specifier.comma;
	this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
	this.trim = !!specifier.trim;
	this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
	return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

//#endregion
//#region node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s$1) {
	out: for (var n = s$1.length, i = 1, i0 = -1, i1; i < n; ++i) switch (s$1[i]) {
		case ".":
			i0 = i1 = i;
			break;
		case "0":
			if (i0 === 0) i0 = i;
			i1 = i;
			break;
		default:
			if (!+s$1[i]) break out;
			if (i0 > 0) i0 = 0;
			break;
	}
	return i0 > 0 ? s$1.slice(0, i0) + s$1.slice(i1 + 1) : s$1;
}

//#endregion
//#region node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
	return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x$1, Math.max(0, p + i - 1))[0];
}

//#endregion
//#region node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x$1, p) {
	var d = formatDecimalParts(x$1, p);
	if (!d) return x$1 + "";
	var coefficient = d[0], exponent = d[1];
	return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

//#endregion
//#region node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
	"%": (x$1, p) => (x$1 * 100).toFixed(p),
	"b": (x$1) => Math.round(x$1).toString(2),
	"c": (x$1) => x$1 + "",
	"d": formatDecimal_default,
	"e": (x$1, p) => x$1.toExponential(p),
	"f": (x$1, p) => x$1.toFixed(p),
	"g": (x$1, p) => x$1.toPrecision(p),
	"o": (x$1) => Math.round(x$1).toString(8),
	"p": (x$1, p) => formatRounded_default(x$1 * 100, p),
	"r": formatRounded_default,
	"s": formatPrefixAuto_default,
	"X": (x$1) => Math.round(x$1).toString(16).toUpperCase(),
	"x": (x$1) => Math.round(x$1).toString(16)
};

//#endregion
//#region node_modules/d3-format/src/identity.js
function identity_default(x$1) {
	return x$1;
}

//#endregion
//#region node_modules/d3-format/src/locale.js
var map$1 = Array.prototype.map, prefixes = [
	"y",
	"z",
	"a",
	"f",
	"p",
	"n",
	"",
	"m",
	"",
	"k",
	"M",
	"G",
	"T",
	"P",
	"E",
	"Z",
	"Y"
];
function locale_default(locale$2) {
	var group = locale$2.grouping === void 0 || locale$2.thousands === void 0 ? identity_default : formatGroup_default(map$1.call(locale$2.grouping, Number), locale$2.thousands + ""), currencyPrefix = locale$2.currency === void 0 ? "" : locale$2.currency[0] + "", currencySuffix = locale$2.currency === void 0 ? "" : locale$2.currency[1] + "", decimal = locale$2.decimal === void 0 ? "." : locale$2.decimal + "", numerals = locale$2.numerals === void 0 ? identity_default : formatNumerals_default(map$1.call(locale$2.numerals, String)), percent = locale$2.percent === void 0 ? "%" : locale$2.percent + "", minus = locale$2.minus === void 0 ? "" : locale$2.minus + "", nan = locale$2.nan === void 0 ? "NaN" : locale$2.nan + "";
	function newFormat(specifier) {
		specifier = formatSpecifier(specifier);
		var fill = specifier.fill, align = specifier.align, sign$1 = specifier.sign, symbol = specifier.symbol, zero$2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
		if (type === "n") comma = true, type = "g";
		else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
		if (zero$2 || fill === "0" && align === "=") zero$2 = true, fill = "0", align = "=";
		var prefix$2 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
		var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
		precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
		function format$1(value) {
			var valuePrefix = prefix$2, valueSuffix = suffix, i, n, c$1;
			if (type === "c") {
				valueSuffix = formatType(value) + valueSuffix;
				value = "";
			} else {
				value = +value;
				var valueNegative = value < 0 || 1 / value < 0;
				value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
				if (trim) value = formatTrim_default(value);
				if (valueNegative && +value === 0 && sign$1 !== "+") valueNegative = false;
				valuePrefix = (valueNegative ? sign$1 === "(" ? sign$1 : minus : sign$1 === "-" || sign$1 === "(" ? "" : sign$1) + valuePrefix;
				valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign$1 === "(" ? ")" : "");
				if (maybeSuffix) {
					i = -1, n = value.length;
					while (++i < n) if (c$1 = value.charCodeAt(i), 48 > c$1 || c$1 > 57) {
						valueSuffix = (c$1 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
						value = value.slice(0, i);
						break;
					}
				}
			}
			if (comma && !zero$2) value = group(value, Infinity);
			var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
			if (comma && zero$2) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
			switch (align) {
				case "<":
					value = valuePrefix + value + valueSuffix + padding;
					break;
				case "=":
					value = valuePrefix + padding + value + valueSuffix;
					break;
				case "^":
					value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
					break;
				default:
					value = padding + valuePrefix + value + valueSuffix;
					break;
			}
			return numerals(value);
		}
		format$1.toString = function() {
			return specifier + "";
		};
		return format$1;
	}
	function formatPrefix$1(specifier, value) {
		var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k$1 = Math.pow(10, -e), prefix$2 = prefixes[8 + e / 3];
		return function(value$1) {
			return f(k$1 * value$1) + prefix$2;
		};
	}
	return {
		format: newFormat,
		formatPrefix: formatPrefix$1
	};
}

//#endregion
//#region node_modules/d3-format/src/defaultLocale.js
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
	thousands: ",",
	grouping: [3],
	currency: ["$", ""]
});
function defaultLocale$1(definition) {
	locale$1 = locale_default(definition);
	format = locale$1.format;
	formatPrefix = locale$1.formatPrefix;
	return locale$1;
}

//#endregion
//#region node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
	return Math.max(0, -exponent_default(Math.abs(step)));
}

//#endregion
//#region node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
	return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

//#endregion
//#region node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max$1) {
	step = Math.abs(step), max$1 = Math.abs(max$1) - step;
	return Math.max(0, exponent_default(max$1) - exponent_default(step)) + 1;
}

//#endregion
//#region node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count, specifier) {
	var step = tickStep(start, stop, count), precision;
	specifier = formatSpecifier(specifier == null ? ",f" : specifier);
	switch (specifier.type) {
		case "s":
			var value = Math.max(Math.abs(start), Math.abs(stop));
			if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
			return formatPrefix(specifier, value);
		case "":
		case "e":
		case "g":
		case "p":
		case "r":
			if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
			break;
		case "f":
		case "%":
			if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
			break;
	}
	return format(specifier);
}

//#endregion
//#region node_modules/d3-scale/src/linear.js
function linearish(scale) {
	var domain = scale.domain;
	scale.ticks = function(count) {
		var d = domain();
		return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	};
	scale.tickFormat = function(count, specifier) {
		var d = domain();
		return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
	};
	scale.nice = function(count) {
		if (count == null) count = 10;
		var d = domain();
		var i0 = 0;
		var i1 = d.length - 1;
		var start = d[i0];
		var stop = d[i1];
		var prestep;
		var step;
		var maxIter = 10;
		if (stop < start) {
			step = start, start = stop, stop = step;
			step = i0, i0 = i1, i1 = step;
		}
		while (maxIter-- > 0) {
			step = tickIncrement(start, stop, count);
			if (step === prestep) {
				d[i0] = start;
				d[i1] = stop;
				return domain(d);
			} else if (step > 0) {
				start = Math.floor(start / step) * step;
				stop = Math.ceil(stop / step) * step;
			} else if (step < 0) {
				start = Math.ceil(start * step) / step;
				stop = Math.floor(stop * step) / step;
			} else break;
			prestep = step;
		}
		return scale;
	};
	return scale;
}
function linear() {
	var scale = continuous();
	scale.copy = function() {
		return copy$1(scale, linear());
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}

//#endregion
//#region node_modules/d3-scale/src/identity.js
function identity$4(domain) {
	var unknown;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : x$1;
	}
	scale.invert = scale;
	scale.domain = scale.range = function(_) {
		return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return identity$4(domain).unknown(unknown);
	};
	domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
	return linearish(scale);
}

//#endregion
//#region node_modules/d3-scale/src/nice.js
function nice(domain, interval) {
	domain = domain.slice();
	var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
	if (x1 < x0) {
		t = i0, i0 = i1, i1 = t;
		t = x0, x0 = x1, x1 = t;
	}
	domain[i0] = interval.floor(x0);
	domain[i1] = interval.ceil(x1);
	return domain;
}

//#endregion
//#region node_modules/d3-scale/src/log.js
function transformLog(x$1) {
	return Math.log(x$1);
}
function transformExp(x$1) {
	return Math.exp(x$1);
}
function transformLogn(x$1) {
	return -Math.log(-x$1);
}
function transformExpn(x$1) {
	return -Math.exp(-x$1);
}
function pow10(x$1) {
	return isFinite(x$1) ? +("1e" + x$1) : x$1 < 0 ? 0 : x$1;
}
function powp(base) {
	return base === 10 ? pow10 : base === Math.E ? Math.exp : (x$1) => Math.pow(base, x$1);
}
function logp(base) {
	return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x$1) => Math.log(x$1) / base);
}
function reflect(f) {
	return (x$1, k$1) => -f(-x$1, k$1);
}
function loggish(transform) {
	const scale = transform(transformLog, transformExp);
	const domain = scale.domain;
	let base = 10;
	let logs;
	let pows;
	function rescale() {
		logs = logp(base), pows = powp(base);
		if (domain()[0] < 0) {
			logs = reflect(logs), pows = reflect(pows);
			transform(transformLogn, transformExpn);
		} else transform(transformLog, transformExp);
		return scale;
	}
	scale.base = function(_) {
		return arguments.length ? (base = +_, rescale()) : base;
	};
	scale.domain = function(_) {
		return arguments.length ? (domain(_), rescale()) : domain();
	};
	scale.ticks = (count) => {
		const d = domain();
		let u = d[0];
		let v = d[d.length - 1];
		const r$1 = v < u;
		if (r$1) [u, v] = [v, u];
		let i = logs(u);
		let j = logs(v);
		let k$1;
		let t;
		const n = count == null ? 10 : +count;
		let z = [];
		if (!(base % 1) && j - i < n) {
			i = Math.floor(i), j = Math.ceil(j);
			if (u > 0) for (; i <= j; ++i) for (k$1 = 1; k$1 < base; ++k$1) {
				t = i < 0 ? k$1 / pows(-i) : k$1 * pows(i);
				if (t < u) continue;
				if (t > v) break;
				z.push(t);
			}
			else for (; i <= j; ++i) for (k$1 = base - 1; k$1 >= 1; --k$1) {
				t = i > 0 ? k$1 / pows(-i) : k$1 * pows(i);
				if (t < u) continue;
				if (t > v) break;
				z.push(t);
			}
			if (z.length * 2 < n) z = ticks(u, v, n);
		} else z = ticks(i, j, Math.min(j - i, n)).map(pows);
		return r$1 ? z.reverse() : z;
	};
	scale.tickFormat = (count, specifier) => {
		if (count == null) count = 10;
		if (specifier == null) specifier = base === 10 ? "s" : ",";
		if (typeof specifier !== "function") {
			if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
			specifier = format(specifier);
		}
		if (count === Infinity) return specifier;
		const k$1 = Math.max(1, base * count / scale.ticks().length);
		return (d) => {
			let i = d / pows(Math.round(logs(d)));
			if (i * base < base - .5) i *= base;
			return i <= k$1 ? specifier(d) : "";
		};
	};
	scale.nice = () => {
		return domain(nice(domain(), {
			floor: (x$1) => pows(Math.floor(logs(x$1))),
			ceil: (x$1) => pows(Math.ceil(logs(x$1)))
		}));
	};
	return scale;
}
function log() {
	const scale = loggish(transformer$2()).domain([1, 10]);
	scale.copy = () => copy$1(scale, log()).base(scale.base());
	initRange.apply(scale, arguments);
	return scale;
}

//#endregion
//#region node_modules/d3-scale/src/symlog.js
function transformSymlog(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.log1p(Math.abs(x$1 / c$1));
	};
}
function transformSymexp(c$1) {
	return function(x$1) {
		return Math.sign(x$1) * Math.expm1(Math.abs(x$1)) * c$1;
	};
}
function symlogish(transform) {
	var c$1 = 1, scale = transform(transformSymlog(c$1), transformSymexp(c$1));
	scale.constant = function(_) {
		return arguments.length ? transform(transformSymlog(c$1 = +_), transformSymexp(c$1)) : c$1;
	};
	return linearish(scale);
}
function symlog() {
	var scale = symlogish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, symlog()).constant(scale.constant());
	};
	return initRange.apply(scale, arguments);
}

//#endregion
//#region node_modules/d3-scale/src/pow.js
function transformPow(exponent) {
	return function(x$1) {
		return x$1 < 0 ? -Math.pow(-x$1, exponent) : Math.pow(x$1, exponent);
	};
}
function transformSqrt(x$1) {
	return x$1 < 0 ? -Math.sqrt(-x$1) : Math.sqrt(x$1);
}
function transformSquare(x$1) {
	return x$1 < 0 ? -x$1 * x$1 : x$1 * x$1;
}
function powish(transform) {
	var scale = transform(identity$3, identity$3), exponent = 1;
	function rescale() {
		return exponent === 1 ? transform(identity$3, identity$3) : exponent === .5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
	}
	scale.exponent = function(_) {
		return arguments.length ? (exponent = +_, rescale()) : exponent;
	};
	return linearish(scale);
}
function pow() {
	var scale = powish(transformer$2());
	scale.copy = function() {
		return copy$1(scale, pow()).exponent(scale.exponent());
	};
	initRange.apply(scale, arguments);
	return scale;
}
function sqrt() {
	return pow.apply(null, arguments).exponent(.5);
}

//#endregion
//#region node_modules/d3-scale/src/radial.js
function square(x$1) {
	return Math.sign(x$1) * x$1 * x$1;
}
function unsquare(x$1) {
	return Math.sign(x$1) * Math.sqrt(Math.abs(x$1));
}
function radial() {
	var squared = continuous(), range$5 = [0, 1], round = false, unknown;
	function scale(x$1) {
		var y$1 = unsquare(squared(x$1));
		return isNaN(y$1) ? unknown : round ? Math.round(y$1) : y$1;
	}
	scale.invert = function(y$1) {
		return squared.invert(square(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? (squared.domain(_), scale) : squared.domain();
	};
	scale.range = function(_) {
		return arguments.length ? (squared.range((range$5 = Array.from(_, number$1)).map(square)), scale) : range$5.slice();
	};
	scale.rangeRound = function(_) {
		return scale.range(_).round(true);
	};
	scale.round = function(_) {
		return arguments.length ? (round = !!_, scale) : round;
	};
	scale.clamp = function(_) {
		return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return radial(squared.domain(), range$5).round(round).clamp(squared.clamp()).unknown(unknown);
	};
	initRange.apply(scale, arguments);
	return linearish(scale);
}

//#endregion
//#region node_modules/d3-scale/src/quantile.js
function quantile$1() {
	var domain = [], range$5 = [], thresholds = [], unknown;
	function rescale() {
		var i = 0, n = Math.max(1, range$5.length);
		thresholds = new Array(n - 1);
		while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
		return scale;
	}
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : range$5[bisect_default(thresholds, x$1)];
	}
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
	};
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return rescale();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), rescale()) : range$5.slice();
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.quantiles = function() {
		return thresholds.slice();
	};
	scale.copy = function() {
		return quantile$1().domain(domain).range(range$5).unknown(unknown);
	};
	return initRange.apply(scale, arguments);
}

//#endregion
//#region node_modules/d3-scale/src/quantize.js
function quantize() {
	var x0 = 0, x1 = 1, n = 1, domain = [.5], range$5 = [0, 1], unknown;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n)] : unknown;
	}
	function rescale() {
		var i = -1;
		domain = new Array(n);
		while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
		return scale;
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
	};
	scale.range = function(_) {
		return arguments.length ? (n = (range$5 = Array.from(_)).length - 1, rescale()) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : scale;
	};
	scale.thresholds = function() {
		return domain.slice();
	};
	scale.copy = function() {
		return quantize().domain([x0, x1]).range(range$5).unknown(unknown);
	};
	return initRange.apply(linearish(scale), arguments);
}

//#endregion
//#region node_modules/d3-scale/src/threshold.js
function threshold() {
	var domain = [.5], range$5 = [0, 1], unknown, n = 1;
	function scale(x$1) {
		return x$1 != null && x$1 <= x$1 ? range$5[bisect_default(domain, x$1, 0, n)] : unknown;
	}
	scale.domain = function(_) {
		return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range$5.length - 1), scale) : domain.slice();
	};
	scale.range = function(_) {
		return arguments.length ? (range$5 = Array.from(_), n = Math.min(domain.length, range$5.length - 1), scale) : range$5.slice();
	};
	scale.invertExtent = function(y$1) {
		var i = range$5.indexOf(y$1);
		return [domain[i - 1], domain[i]];
	};
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	scale.copy = function() {
		return threshold().domain(domain).range(range$5).unknown(unknown);
	};
	return initRange.apply(scale, arguments);
}

//#endregion
//#region node_modules/d3-time/src/interval.js
var t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
	function interval(date$1) {
		return floori(date$1 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date$1)), date$1;
	}
	interval.floor = (date$1) => {
		return floori(date$1 = /* @__PURE__ */ new Date(+date$1)), date$1;
	};
	interval.ceil = (date$1) => {
		return floori(date$1 = /* @__PURE__ */ new Date(date$1 - 1)), offseti(date$1, 1), floori(date$1), date$1;
	};
	interval.round = (date$1) => {
		const d0 = interval(date$1), d1 = interval.ceil(date$1);
		return date$1 - d0 < d1 - date$1 ? d0 : d1;
	};
	interval.offset = (date$1, step) => {
		return offseti(date$1 = /* @__PURE__ */ new Date(+date$1), step == null ? 1 : Math.floor(step)), date$1;
	};
	interval.range = (start, stop, step) => {
		const range$5 = [];
		start = interval.ceil(start);
		step = step == null ? 1 : Math.floor(step);
		if (!(start < stop) || !(step > 0)) return range$5;
		let previous;
		do
			range$5.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
		while (previous < start && start < stop);
		return range$5;
	};
	interval.filter = (test) => {
		return timeInterval((date$1) => {
			if (date$1 >= date$1) while (floori(date$1), !test(date$1)) date$1.setTime(date$1 - 1);
		}, (date$1, step) => {
			if (date$1 >= date$1) if (step < 0) while (++step <= 0) while (offseti(date$1, -1), !test(date$1));
			else while (--step >= 0) while (offseti(date$1, 1), !test(date$1));
		});
	};
	if (count) {
		interval.count = (start, end) => {
			t0.setTime(+start), t1.setTime(+end);
			floori(t0), floori(t1);
			return Math.floor(count(t0, t1));
		};
		interval.every = (step) => {
			step = Math.floor(step);
			return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
		};
	}
	return interval;
}

//#endregion
//#region node_modules/d3-time/src/millisecond.js
const millisecond = timeInterval(() => {}, (date$1, step) => {
	date$1.setTime(+date$1 + step);
}, (start, end) => {
	return end - start;
});
millisecond.every = (k$1) => {
	k$1 = Math.floor(k$1);
	if (!isFinite(k$1) || !(k$1 > 0)) return null;
	if (!(k$1 > 1)) return millisecond;
	return timeInterval((date$1) => {
		date$1.setTime(Math.floor(date$1 / k$1) * k$1);
	}, (date$1, step) => {
		date$1.setTime(+date$1 + step * k$1);
	}, (start, end) => {
		return (end - start) / k$1;
	});
};
const milliseconds = millisecond.range;

//#endregion
//#region node_modules/d3-time/src/duration.js
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

//#endregion
//#region node_modules/d3-time/src/second.js
const second = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds());
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationSecond);
}, (start, end) => {
	return (end - start) / durationSecond;
}, (date$1) => {
	return date$1.getUTCSeconds();
});
const seconds = second.range;

//#endregion
//#region node_modules/d3-time/src/minute.js
const timeMinute = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds() - date$1.getSeconds() * durationSecond);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$1) => {
	return date$1.getMinutes();
});
const timeMinutes = timeMinute.range;
const utcMinute = timeInterval((date$1) => {
	date$1.setUTCSeconds(0, 0);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationMinute);
}, (start, end) => {
	return (end - start) / durationMinute;
}, (date$1) => {
	return date$1.getUTCMinutes();
});
const utcMinutes = utcMinute.range;

//#endregion
//#region node_modules/d3-time/src/hour.js
const timeHour = timeInterval((date$1) => {
	date$1.setTime(date$1 - date$1.getMilliseconds() - date$1.getSeconds() * durationSecond - date$1.getMinutes() * durationMinute);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$1) => {
	return date$1.getHours();
});
const timeHours = timeHour.range;
const utcHour = timeInterval((date$1) => {
	date$1.setUTCMinutes(0, 0, 0);
}, (date$1, step) => {
	date$1.setTime(+date$1 + step * durationHour);
}, (start, end) => {
	return (end - start) / durationHour;
}, (date$1) => {
	return date$1.getUTCHours();
});
const utcHours = utcHour.range;

//#endregion
//#region node_modules/d3-time/src/day.js
const timeDay = timeInterval((date$1) => date$1.setHours(0, 0, 0, 0), (date$1, step) => date$1.setDate(date$1.getDate() + step), (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay, (date$1) => date$1.getDate() - 1);
const timeDays = timeDay.range;
const utcDay = timeInterval((date$1) => {
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCDate(date$1.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$1) => {
	return date$1.getUTCDate() - 1;
});
const utcDays = utcDay.range;
const unixDay = timeInterval((date$1) => {
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCDate(date$1.getUTCDate() + step);
}, (start, end) => {
	return (end - start) / durationDay;
}, (date$1) => {
	return Math.floor(date$1 / durationDay);
});
const unixDays = unixDay.range;

//#endregion
//#region node_modules/d3-time/src/week.js
function timeWeekday(i) {
	return timeInterval((date$1) => {
		date$1.setDate(date$1.getDate() - (date$1.getDay() + 7 - i) % 7);
		date$1.setHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setDate(date$1.getDate() + step * 7);
	}, (start, end) => {
		return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	});
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
const timeSundays = timeSunday.range;
const timeMondays = timeMonday.range;
const timeTuesdays = timeTuesday.range;
const timeWednesdays = timeWednesday.range;
const timeThursdays = timeThursday.range;
const timeFridays = timeFriday.range;
const timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
	return timeInterval((date$1) => {
		date$1.setUTCDate(date$1.getUTCDate() - (date$1.getUTCDay() + 7 - i) % 7);
		date$1.setUTCHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setUTCDate(date$1.getUTCDate() + step * 7);
	}, (start, end) => {
		return (end - start) / durationWeek;
	});
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
const utcSundays = utcSunday.range;
const utcMondays = utcMonday.range;
const utcTuesdays = utcTuesday.range;
const utcWednesdays = utcWednesday.range;
const utcThursdays = utcThursday.range;
const utcFridays = utcFriday.range;
const utcSaturdays = utcSaturday.range;

//#endregion
//#region node_modules/d3-time/src/month.js
const timeMonth = timeInterval((date$1) => {
	date$1.setDate(1);
	date$1.setHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setMonth(date$1.getMonth() + step);
}, (start, end) => {
	return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date$1) => {
	return date$1.getMonth();
});
const timeMonths = timeMonth.range;
const utcMonth = timeInterval((date$1) => {
	date$1.setUTCDate(1);
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCMonth(date$1.getUTCMonth() + step);
}, (start, end) => {
	return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date$1) => {
	return date$1.getUTCMonth();
});
const utcMonths = utcMonth.range;

//#endregion
//#region node_modules/d3-time/src/year.js
const timeYear = timeInterval((date$1) => {
	date$1.setMonth(0, 1);
	date$1.setHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setFullYear(date$1.getFullYear() + step);
}, (start, end) => {
	return end.getFullYear() - start.getFullYear();
}, (date$1) => {
	return date$1.getFullYear();
});
timeYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$1) => {
		date$1.setFullYear(Math.floor(date$1.getFullYear() / k$1) * k$1);
		date$1.setMonth(0, 1);
		date$1.setHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setFullYear(date$1.getFullYear() + step * k$1);
	});
};
const timeYears = timeYear.range;
const utcYear = timeInterval((date$1) => {
	date$1.setUTCMonth(0, 1);
	date$1.setUTCHours(0, 0, 0, 0);
}, (date$1, step) => {
	date$1.setUTCFullYear(date$1.getUTCFullYear() + step);
}, (start, end) => {
	return end.getUTCFullYear() - start.getUTCFullYear();
}, (date$1) => {
	return date$1.getUTCFullYear();
});
utcYear.every = (k$1) => {
	return !isFinite(k$1 = Math.floor(k$1)) || !(k$1 > 0) ? null : timeInterval((date$1) => {
		date$1.setUTCFullYear(Math.floor(date$1.getUTCFullYear() / k$1) * k$1);
		date$1.setUTCMonth(0, 1);
		date$1.setUTCHours(0, 0, 0, 0);
	}, (date$1, step) => {
		date$1.setUTCFullYear(date$1.getUTCFullYear() + step * k$1);
	});
};
const utcYears = utcYear.range;

//#endregion
//#region node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
	const tickIntervals = [
		[
			second,
			1,
			durationSecond
		],
		[
			second,
			5,
			5 * durationSecond
		],
		[
			second,
			15,
			15 * durationSecond
		],
		[
			second,
			30,
			30 * durationSecond
		],
		[
			minute,
			1,
			durationMinute
		],
		[
			minute,
			5,
			5 * durationMinute
		],
		[
			minute,
			15,
			15 * durationMinute
		],
		[
			minute,
			30,
			30 * durationMinute
		],
		[
			hour,
			1,
			durationHour
		],
		[
			hour,
			3,
			3 * durationHour
		],
		[
			hour,
			6,
			6 * durationHour
		],
		[
			hour,
			12,
			12 * durationHour
		],
		[
			day,
			1,
			durationDay
		],
		[
			day,
			2,
			2 * durationDay
		],
		[
			week,
			1,
			durationWeek
		],
		[
			month,
			1,
			durationMonth
		],
		[
			month,
			3,
			3 * durationMonth
		],
		[
			year,
			1,
			durationYear
		]
	];
	function ticks$1(start, stop, count) {
		const reverse$1 = stop < start;
		if (reverse$1) [start, stop] = [stop, start];
		const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
		const ticks$2 = interval ? interval.range(start, +stop + 1) : [];
		return reverse$1 ? ticks$2.reverse() : ticks$2;
	}
	function tickInterval(start, stop, count) {
		const target = Math.abs(stop - start) / count;
		const i = bisector(([, , step$1]) => step$1).right(tickIntervals, target);
		if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
		if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
		const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
		return t.every(step);
	}
	return [ticks$1, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

//#endregion
//#region node_modules/d3-time-format/src/locale.js
function localDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$1 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
		date$1.setFullYear(d.y);
		return date$1;
	}
	return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
	if (0 <= d.y && d.y < 100) {
		var date$1 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
		date$1.setUTCFullYear(d.y);
		return date$1;
	}
	return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y$1, m, d) {
	return {
		y: y$1,
		m,
		d,
		H: 0,
		M: 0,
		S: 0,
		L: 0
	};
}
function formatLocale(locale$2) {
	var locale_dateTime = locale$2.dateTime, locale_date = locale$2.date, locale_time = locale$2.time, locale_periods = locale$2.periods, locale_weekdays = locale$2.days, locale_shortWeekdays = locale$2.shortDays, locale_months = locale$2.months, locale_shortMonths = locale$2.shortMonths;
	var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
	var formats = {
		"a": formatShortWeekday,
		"A": formatWeekday,
		"b": formatShortMonth,
		"B": formatMonth,
		"c": null,
		"d": formatDayOfMonth,
		"e": formatDayOfMonth,
		"f": formatMicroseconds,
		"g": formatYearISO,
		"G": formatFullYearISO,
		"H": formatHour24,
		"I": formatHour12,
		"j": formatDayOfYear,
		"L": formatMilliseconds,
		"m": formatMonthNumber,
		"M": formatMinutes,
		"p": formatPeriod,
		"q": formatQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatSeconds,
		"u": formatWeekdayNumberMonday,
		"U": formatWeekNumberSunday,
		"V": formatWeekNumberISO,
		"w": formatWeekdayNumberSunday,
		"W": formatWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatYear,
		"Y": formatFullYear,
		"Z": formatZone,
		"%": formatLiteralPercent
	};
	var utcFormats = {
		"a": formatUTCShortWeekday,
		"A": formatUTCWeekday,
		"b": formatUTCShortMonth,
		"B": formatUTCMonth,
		"c": null,
		"d": formatUTCDayOfMonth,
		"e": formatUTCDayOfMonth,
		"f": formatUTCMicroseconds,
		"g": formatUTCYearISO,
		"G": formatUTCFullYearISO,
		"H": formatUTCHour24,
		"I": formatUTCHour12,
		"j": formatUTCDayOfYear,
		"L": formatUTCMilliseconds,
		"m": formatUTCMonthNumber,
		"M": formatUTCMinutes,
		"p": formatUTCPeriod,
		"q": formatUTCQuarter,
		"Q": formatUnixTimestamp,
		"s": formatUnixTimestampSeconds,
		"S": formatUTCSeconds,
		"u": formatUTCWeekdayNumberMonday,
		"U": formatUTCWeekNumberSunday,
		"V": formatUTCWeekNumberISO,
		"w": formatUTCWeekdayNumberSunday,
		"W": formatUTCWeekNumberMonday,
		"x": null,
		"X": null,
		"y": formatUTCYear,
		"Y": formatUTCFullYear,
		"Z": formatUTCZone,
		"%": formatLiteralPercent
	};
	var parses = {
		"a": parseShortWeekday,
		"A": parseWeekday,
		"b": parseShortMonth,
		"B": parseMonth,
		"c": parseLocaleDateTime,
		"d": parseDayOfMonth,
		"e": parseDayOfMonth,
		"f": parseMicroseconds,
		"g": parseYear,
		"G": parseFullYear,
		"H": parseHour24,
		"I": parseHour24,
		"j": parseDayOfYear,
		"L": parseMilliseconds,
		"m": parseMonthNumber,
		"M": parseMinutes,
		"p": parsePeriod,
		"q": parseQuarter,
		"Q": parseUnixTimestamp,
		"s": parseUnixTimestampSeconds,
		"S": parseSeconds,
		"u": parseWeekdayNumberMonday,
		"U": parseWeekNumberSunday,
		"V": parseWeekNumberISO,
		"w": parseWeekdayNumberSunday,
		"W": parseWeekNumberMonday,
		"x": parseLocaleDate,
		"X": parseLocaleTime,
		"y": parseYear,
		"Y": parseFullYear,
		"Z": parseZone,
		"%": parseLiteralPercent
	};
	formats.x = newFormat(locale_date, formats);
	formats.X = newFormat(locale_time, formats);
	formats.c = newFormat(locale_dateTime, formats);
	utcFormats.x = newFormat(locale_date, utcFormats);
	utcFormats.X = newFormat(locale_time, utcFormats);
	utcFormats.c = newFormat(locale_dateTime, utcFormats);
	function newFormat(specifier, formats$1) {
		return function(date$1) {
			var string = [], i = -1, j = 0, n = specifier.length, c$1, pad$1, format$1;
			if (!(date$1 instanceof Date)) date$1 = /* @__PURE__ */ new Date(+date$1);
			while (++i < n) if (specifier.charCodeAt(i) === 37) {
				string.push(specifier.slice(j, i));
				if ((pad$1 = pads[c$1 = specifier.charAt(++i)]) != null) c$1 = specifier.charAt(++i);
				else pad$1 = c$1 === "e" ? " " : "0";
				if (format$1 = formats$1[c$1]) c$1 = format$1(date$1, pad$1);
				string.push(c$1);
				j = i + 1;
			}
			string.push(specifier.slice(j, i));
			return string.join("");
		};
	}
	function newParse(specifier, Z) {
		return function(string) {
			var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
			if (i != string.length) return null;
			if ("Q" in d) return new Date(d.Q);
			if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
			if (Z && !("Z" in d)) d.Z = 0;
			if ("p" in d) d.H = d.H % 12 + d.p * 12;
			if (d.m === void 0) d.m = "q" in d ? d.q : 0;
			if ("V" in d) {
				if (d.V < 1 || d.V > 53) return null;
				if (!("w" in d)) d.w = 1;
				if ("Z" in d) {
					week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
					week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
					week = utcDay.offset(week, (d.V - 1) * 7);
					d.y = week.getUTCFullYear();
					d.m = week.getUTCMonth();
					d.d = week.getUTCDate() + (d.w + 6) % 7;
				} else {
					week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
					week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
					week = timeDay.offset(week, (d.V - 1) * 7);
					d.y = week.getFullYear();
					d.m = week.getMonth();
					d.d = week.getDate() + (d.w + 6) % 7;
				}
			} else if ("W" in d || "U" in d) {
				if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
				day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
				d.m = 0;
				d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
			}
			if ("Z" in d) {
				d.H += d.Z / 100 | 0;
				d.M += d.Z % 100;
				return utcDate(d);
			}
			return localDate(d);
		};
	}
	function parseSpecifier(d, specifier, string, j) {
		var i = 0, n = specifier.length, m = string.length, c$1, parse;
		while (i < n) {
			if (j >= m) return -1;
			c$1 = specifier.charCodeAt(i++);
			if (c$1 === 37) {
				c$1 = specifier.charAt(i++);
				parse = parses[c$1 in pads ? specifier.charAt(i++) : c$1];
				if (!parse || (j = parse(d, string, j)) < 0) return -1;
			} else if (c$1 != string.charCodeAt(j++)) return -1;
		}
		return j;
	}
	function parsePeriod(d, string, i) {
		var n = periodRe.exec(string.slice(i));
		return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseShortWeekday(d, string, i) {
		var n = shortWeekdayRe.exec(string.slice(i));
		return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseWeekday(d, string, i) {
		var n = weekdayRe.exec(string.slice(i));
		return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseShortMonth(d, string, i) {
		var n = shortMonthRe.exec(string.slice(i));
		return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseMonth(d, string, i) {
		var n = monthRe.exec(string.slice(i));
		return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
	}
	function parseLocaleDateTime(d, string, i) {
		return parseSpecifier(d, locale_dateTime, string, i);
	}
	function parseLocaleDate(d, string, i) {
		return parseSpecifier(d, locale_date, string, i);
	}
	function parseLocaleTime(d, string, i) {
		return parseSpecifier(d, locale_time, string, i);
	}
	function formatShortWeekday(d) {
		return locale_shortWeekdays[d.getDay()];
	}
	function formatWeekday(d) {
		return locale_weekdays[d.getDay()];
	}
	function formatShortMonth(d) {
		return locale_shortMonths[d.getMonth()];
	}
	function formatMonth(d) {
		return locale_months[d.getMonth()];
	}
	function formatPeriod(d) {
		return locale_periods[+(d.getHours() >= 12)];
	}
	function formatQuarter(d) {
		return 1 + ~~(d.getMonth() / 3);
	}
	function formatUTCShortWeekday(d) {
		return locale_shortWeekdays[d.getUTCDay()];
	}
	function formatUTCWeekday(d) {
		return locale_weekdays[d.getUTCDay()];
	}
	function formatUTCShortMonth(d) {
		return locale_shortMonths[d.getUTCMonth()];
	}
	function formatUTCMonth(d) {
		return locale_months[d.getUTCMonth()];
	}
	function formatUTCPeriod(d) {
		return locale_periods[+(d.getUTCHours() >= 12)];
	}
	function formatUTCQuarter(d) {
		return 1 + ~~(d.getUTCMonth() / 3);
	}
	return {
		format: function(specifier) {
			var f = newFormat(specifier += "", formats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		parse: function(specifier) {
			var p = newParse(specifier += "", false);
			p.toString = function() {
				return specifier;
			};
			return p;
		},
		utcFormat: function(specifier) {
			var f = newFormat(specifier += "", utcFormats);
			f.toString = function() {
				return specifier;
			};
			return f;
		},
		utcParse: function(specifier) {
			var p = newParse(specifier += "", true);
			p.toString = function() {
				return specifier;
			};
			return p;
		}
	};
}
var pads = {
	"-": "",
	"_": " ",
	"0": "0"
}, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
	var sign$1 = value < 0 ? "-" : "", string = (sign$1 ? -value : value) + "", length = string.length;
	return sign$1 + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}
function requote(s$1) {
	return s$1.replace(requoteRe, "\\$&");
}
function formatRe(names) {
	return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
	return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 4));
	return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
	var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 1));
	return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 3));
	return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 2));
	return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 3));
	return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
	var n = numberRe.exec(string.slice(i, i + 6));
	return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
	var n = percentRe.exec(string.slice(i, i + 1));
	return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
	var n = numberRe.exec(string.slice(i));
	return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
	var n = numberRe.exec(string.slice(i));
	return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
	return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
	return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
	return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
	return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
	return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
	return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
	return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
	return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
	return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
	var day = d.getDay();
	return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
	return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
	var day = d.getDay();
	return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
	d = dISO(d);
	return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
	return d.getDay();
}
function formatWeekNumberMonday(d, p) {
	return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
	return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
	d = dISO(d);
	return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
	var day = d.getDay();
	d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
	return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
	var z = d.getTimezoneOffset();
	return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
	return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
	return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
	return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
	return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
	return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
	return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
	return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
	return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
	return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
	var dow = d.getUTCDay();
	return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
	return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
	var day = d.getUTCDay();
	return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
	d = UTCdISO(d);
	return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
	return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
	return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
	d = UTCdISO(d);
	return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
	var day = d.getUTCDay();
	d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
	return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
	return "+0000";
}
function formatLiteralPercent() {
	return "%";
}
function formatUnixTimestamp(d) {
	return +d;
}
function formatUnixTimestampSeconds(d) {
	return Math.floor(+d / 1e3);
}

//#endregion
//#region node_modules/d3-time-format/src/defaultLocale.js
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
	dateTime: "%x, %X",
	date: "%-m/%-d/%Y",
	time: "%-I:%M:%S %p",
	periods: ["AM", "PM"],
	days: [
		"Sunday",
		"Monday",
		"Tuesday",
		"Wednesday",
		"Thursday",
		"Friday",
		"Saturday"
	],
	shortDays: [
		"Sun",
		"Mon",
		"Tue",
		"Wed",
		"Thu",
		"Fri",
		"Sat"
	],
	months: [
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
	],
	shortMonths: [
		"Jan",
		"Feb",
		"Mar",
		"Apr",
		"May",
		"Jun",
		"Jul",
		"Aug",
		"Sep",
		"Oct",
		"Nov",
		"Dec"
	]
});
function defaultLocale(definition) {
	locale = formatLocale(definition);
	timeFormat = locale.format;
	timeParse = locale.parse;
	utcFormat = locale.utcFormat;
	utcParse = locale.utcParse;
	return locale;
}

//#endregion
//#region node_modules/d3-scale/src/time.js
function date(t) {
	return new Date(t);
}
function number(t) {
	return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
}
function calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$1) {
	var scale = continuous(), invert = scale.invert, domain = scale.domain;
	var formatMillisecond = format$1(".%L"), formatSecond = format$1(":%S"), formatMinute = format$1("%I:%M"), formatHour = format$1("%I %p"), formatDay = format$1("%a %d"), formatWeek = format$1("%b %d"), formatMonth = format$1("%B"), formatYear$1 = format$1("%Y");
	function tickFormat$1(date$1) {
		return (second$1(date$1) < date$1 ? formatMillisecond : minute(date$1) < date$1 ? formatSecond : hour(date$1) < date$1 ? formatMinute : day(date$1) < date$1 ? formatHour : month(date$1) < date$1 ? week(date$1) < date$1 ? formatDay : formatWeek : year(date$1) < date$1 ? formatMonth : formatYear$1)(date$1);
	}
	scale.invert = function(y$1) {
		return new Date(invert(y$1));
	};
	scale.domain = function(_) {
		return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
	};
	scale.ticks = function(interval) {
		var d = domain();
		return ticks$1(d[0], d[d.length - 1], interval == null ? 10 : interval);
	};
	scale.tickFormat = function(count, specifier) {
		return specifier == null ? tickFormat$1 : format$1(specifier);
	};
	scale.nice = function(interval) {
		var d = domain();
		if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
		return interval ? domain(nice(d, interval)) : scale;
	};
	scale.copy = function() {
		return copy$1(scale, calendar(ticks$1, tickInterval, year, month, week, day, hour, minute, second$1, format$1));
	};
	return scale;
}
function time() {
	return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}

//#endregion
//#region node_modules/d3-scale/src/utcTime.js
function utcTime() {
	return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}

//#endregion
//#region node_modules/d3-scale/src/sequential.js
function transformer$1() {
	var x0 = 0, x1 = 1, t0$1, t1$1, k10, transform, interpolator = identity$3, clamp = false, unknown;
	function scale(x$1) {
		return x$1 == null || isNaN(x$1 = +x$1) ? unknown : interpolator(k10 === 0 ? .5 : (x$1 = (transform(x$1) - t0$1) * k10, clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1] = _, t0$1 = transform(x0 = +x0), t1$1 = transform(x1 = +x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1), scale) : [x0, x1];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate$1) {
		return function(_) {
			var r0, r1;
			return arguments.length ? ([r0, r1] = _, interpolator = interpolate$1(r0, r1), scale) : [interpolator(0), interpolator(1)];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t) {
		transform = t, t0$1 = t(x0), t1$1 = t(x1), k10 = t0$1 === t1$1 ? 0 : 1 / (t1$1 - t0$1);
		return scale;
	};
}
function copy(source, target) {
	return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
	var scale = linearish(transformer$1()(identity$3));
	scale.copy = function() {
		return copy(scale, sequential());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
	var scale = loggish(transformer$1()).domain([1, 10]);
	scale.copy = function() {
		return copy(scale, sequentialLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
	var scale = symlogish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
	var scale = powish(transformer$1());
	scale.copy = function() {
		return copy(scale, sequentialPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
	return sequentialPow.apply(null, arguments).exponent(.5);
}

//#endregion
//#region node_modules/d3-scale/src/sequentialQuantile.js
function sequentialQuantile() {
	var domain = [], interpolator = identity$3;
	function scale(x$1) {
		if (x$1 != null && !isNaN(x$1 = +x$1)) return interpolator((bisect_default(domain, x$1, 1) - 1) / (domain.length - 1));
	}
	scale.domain = function(_) {
		if (!arguments.length) return domain.slice();
		domain = [];
		for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
		domain.sort(ascending);
		return scale;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	scale.range = function() {
		return domain.map((d, i) => interpolator(i / (domain.length - 1)));
	};
	scale.quantiles = function(n) {
		return Array.from({ length: n + 1 }, (_, i) => quantile(domain, i / n));
	};
	scale.copy = function() {
		return sequentialQuantile(interpolator).domain(domain);
	};
	return initInterpolator.apply(scale, arguments);
}

//#endregion
//#region node_modules/d3-scale/src/diverging.js
function transformer() {
	var x0 = 0, x1 = .5, x2 = 1, s$1 = 1, t0$1, t1$1, t2, k10, k21, interpolator = identity$3, transform, clamp = false, unknown;
	function scale(x$1) {
		return isNaN(x$1 = +x$1) ? unknown : (x$1 = .5 + ((x$1 = +transform(x$1)) - t1$1) * (s$1 * x$1 < s$1 * t1$1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x$1)) : x$1));
	}
	scale.domain = function(_) {
		return arguments.length ? ([x0, x1, x2] = _, t0$1 = transform(x0 = +x0), t1$1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$1 = t1$1 < t0$1 ? -1 : 1, scale) : [
			x0,
			x1,
			x2
		];
	};
	scale.clamp = function(_) {
		return arguments.length ? (clamp = !!_, scale) : clamp;
	};
	scale.interpolator = function(_) {
		return arguments.length ? (interpolator = _, scale) : interpolator;
	};
	function range$5(interpolate$1) {
		return function(_) {
			var r0, r1, r2;
			return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate$1, [
				r0,
				r1,
				r2
			]), scale) : [
				interpolator(0),
				interpolator(.5),
				interpolator(1)
			];
		};
	}
	scale.range = range$5(value_default);
	scale.rangeRound = range$5(round_default);
	scale.unknown = function(_) {
		return arguments.length ? (unknown = _, scale) : unknown;
	};
	return function(t) {
		transform = t, t0$1 = t(x0), t1$1 = t(x1), t2 = t(x2), k10 = t0$1 === t1$1 ? 0 : .5 / (t1$1 - t0$1), k21 = t1$1 === t2 ? 0 : .5 / (t2 - t1$1), s$1 = t1$1 < t0$1 ? -1 : 1;
		return scale;
	};
}
function diverging() {
	var scale = linearish(transformer()(identity$3));
	scale.copy = function() {
		return copy(scale, diverging());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
	var scale = loggish(transformer()).domain([
		.1,
		1,
		10
	]);
	scale.copy = function() {
		return copy(scale, divergingLog()).base(scale.base());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
	var scale = symlogish(transformer());
	scale.copy = function() {
		return copy(scale, divergingSymlog()).constant(scale.constant());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
	var scale = powish(transformer());
	scale.copy = function() {
		return copy(scale, divergingPow()).exponent(scale.exponent());
	};
	return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
	return divergingPow.apply(null, arguments).exponent(.5);
}

//#endregion
//#region node_modules/victory-vendor/es/d3-scale.js
var import_range$1 = /* @__PURE__ */ __toESM(require_range());
var d3_scale_exports = /* @__PURE__ */ __export({
	scaleBand: () => band,
	scaleDiverging: () => diverging,
	scaleDivergingLog: () => divergingLog,
	scaleDivergingPow: () => divergingPow,
	scaleDivergingSqrt: () => divergingSqrt,
	scaleDivergingSymlog: () => divergingSymlog,
	scaleIdentity: () => identity$4,
	scaleImplicit: () => implicit,
	scaleLinear: () => linear,
	scaleLog: () => log,
	scaleOrdinal: () => ordinal,
	scalePoint: () => point,
	scalePow: () => pow,
	scaleQuantile: () => quantile$1,
	scaleQuantize: () => quantize,
	scaleRadial: () => radial,
	scaleSequential: () => sequential,
	scaleSequentialLog: () => sequentialLog,
	scaleSequentialPow: () => sequentialPow,
	scaleSequentialQuantile: () => sequentialQuantile,
	scaleSequentialSqrt: () => sequentialSqrt,
	scaleSequentialSymlog: () => sequentialSymlog,
	scaleSqrt: () => sqrt,
	scaleSymlog: () => symlog,
	scaleThreshold: () => threshold,
	scaleTime: () => time,
	scaleUtc: () => utcTime,
	tickFormat: () => tickFormat
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/dataSelectors.js
/**
* This selector always returns the data with the indexes set by a Brush.
* Trouble is, that might or might not be what you want.
*
* In charts with Brush, you will sometimes want to select the full range of data, and sometimes the one decided by the Brush
* - even if the Brush is active, the panorama inside the Brush should show the full range of data.
*
* So instead of this selector, consider using either selectChartDataAndAlwaysIgnoreIndexes or selectChartDataWithIndexesIfNotInPanorama
*
* @param state RechartsRootState
* @returns data defined on the chart root element, such as BarChart or ScatterChart
*/
var selectChartDataWithIndexes = (state) => state.chartData;
/**
* This selector will always return the full range of data, ignoring the indexes set by a Brush.
* Useful for when you want to render the full range of data, even if a Brush is active.
* For example: in the Brush panorama, in Legend, in Tooltip.
*/
var selectChartDataAndAlwaysIgnoreIndexes = createSelector([selectChartDataWithIndexes], (dataState) => {
	var dataEndIndex = dataState.chartData != null ? dataState.chartData.length - 1 : 0;
	return {
		chartData: dataState.chartData,
		computedData: dataState.computedData,
		dataEndIndex,
		dataStartIndex: 0
	};
});
var selectChartDataWithIndexesIfNotInPanorama = (state, _unused1, _unused2, isPanorama) => {
	if (isPanorama) return selectChartDataAndAlwaysIgnoreIndexes(state);
	return selectChartDataWithIndexes(state);
};

//#endregion
//#region node_modules/recharts/es6/util/isDomainSpecifiedByUser.js
function isWellFormedNumberDomain(v) {
	if (Array.isArray(v) && v.length === 2) {
		var [min$1, max$1] = v;
		if (isWellBehavedNumber(min$1) && isWellBehavedNumber(max$1)) return true;
	}
	return false;
}
function extendDomain(providedDomain, boundaryDomain, allowDataOverflow) {
	if (allowDataOverflow) return providedDomain;
	return [Math.min(providedDomain[0], boundaryDomain[0]), Math.max(providedDomain[1], boundaryDomain[1])];
}
/**
* So Recharts allows users to provide their own domains,
* but it also places some expectations on what the domain is.
* We can improve on the typescript typing, but we also need a runtime test
to observe that the user-provided domain is well-formed,
* that is: an array with exactly two numbers.
*
* This function does not accept data as an argument.
* This is to enable a performance optimization - if the domain is there,
* and we know what it is without traversing all the data,
* then we don't have to traverse all the data!
*
* If the user-provided domain is not well-formed,
* this function will return undefined - in which case we should traverse the data to calculate the real domain.
*
* This function is for parsing the numerical domain only.
*
* @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.
* @param allowDataOverflow boolean, provided by users. If true then the data domain wins
*
* @return [min, max] domain if it's well-formed; undefined if the domain is invalid
*/
function numericalDomainSpecifiedWithoutRequiringData(userDomain, allowDataOverflow) {
	if (!allowDataOverflow) return;
	if (typeof userDomain === "function") return;
	if (Array.isArray(userDomain) && userDomain.length === 2) {
		var [providedMin, providedMax] = userDomain;
		var finalMin, finalMax;
		if (isWellBehavedNumber(providedMin)) finalMin = providedMin;
		else if (typeof providedMin === "function") return;
		if (isWellBehavedNumber(providedMax)) finalMax = providedMax;
		else if (typeof providedMax === "function") return;
		var candidate = [finalMin, finalMax];
		if (isWellFormedNumberDomain(candidate)) return candidate;
	}
}
/**
* So Recharts allows users to provide their own domains,
* but it also places some expectations on what the domain is.
* We can improve on the typescript typing, but we also need a runtime test
* to observe that the user-provided domain is well-formed,
* that is: an array with exactly two numbers.
* If the user-provided domain is not well-formed,
* this function will return undefined - in which case we should traverse the data to calculate the real domain.
*
* This function is for parsing the numerical domain only.
*
* You are probably thinking, why does domain need tick count?
* Well it adjusts the domain based on where the "nice ticks" land, and nice ticks depend on the tick count.
*
* @param userDomain external prop, user provided, before validation. Can have various shapes: array, function, special magical strings inside too.
* @param dataDomain calculated from data. Can be undefined, as an option for performance optimization
* @param allowDataOverflow provided by users. If true then the data domain wins
*
* @return [min, max] domain if it's well-formed; undefined if the domain is invalid
*/
function parseNumericalUserDomain(userDomain, dataDomain, allowDataOverflow) {
	if (!allowDataOverflow && dataDomain == null) return;
	if (typeof userDomain === "function" && dataDomain != null) try {
		var result = userDomain(dataDomain, allowDataOverflow);
		if (isWellFormedNumberDomain(result)) return extendDomain(result, dataDomain, allowDataOverflow);
	} catch (_unused) {}
	if (Array.isArray(userDomain) && userDomain.length === 2) {
		var [providedMin, providedMax] = userDomain;
		var finalMin, finalMax;
		if (providedMin === "auto") {
			if (dataDomain != null) finalMin = Math.min(...dataDomain);
		} else if (isNumber(providedMin)) finalMin = providedMin;
		else if (typeof providedMin === "function") try {
			if (dataDomain != null) finalMin = providedMin(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0]);
		} catch (_unused2) {}
		else if (typeof providedMin === "string" && MIN_VALUE_REG.test(providedMin)) {
			var match = MIN_VALUE_REG.exec(providedMin);
			if (match == null || dataDomain == null) finalMin = void 0;
			else {
				var value = +match[1];
				finalMin = dataDomain[0] - value;
			}
		} else finalMin = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[0];
		if (providedMax === "auto") {
			if (dataDomain != null) finalMax = Math.max(...dataDomain);
		} else if (isNumber(providedMax)) finalMax = providedMax;
		else if (typeof providedMax === "function") try {
			if (dataDomain != null) finalMax = providedMax(dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1]);
		} catch (_unused3) {}
		else if (typeof providedMax === "string" && MAX_VALUE_REG.test(providedMax)) {
			var _match = MAX_VALUE_REG.exec(providedMax);
			if (_match == null || dataDomain == null) finalMax = void 0;
			else {
				var _value = +_match[1];
				finalMax = dataDomain[1] + _value;
			}
		} else finalMax = dataDomain === null || dataDomain === void 0 ? void 0 : dataDomain[1];
		var candidate = [finalMin, finalMax];
		if (isWellFormedNumberDomain(candidate)) {
			if (dataDomain == null) return candidate;
			return extendDomain(candidate, dataDomain, allowDataOverflow);
		}
	}
}

//#endregion
//#region node_modules/decimal.js-light/decimal.js
var require_decimal = /* @__PURE__ */ __commonJS({ "node_modules/decimal.js-light/decimal.js": ((exports, module) => {
	(function(globalScope) {
		var MAX_DIGITS = 1e9, Decimal$2 = {
			precision: 20,
			rounding: 4,
			toExpNeg: -7,
			toExpPos: 21,
			LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
		}, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
		P.absoluteValue = P.abs = function() {
			var x$1 = new this.constructor(this);
			if (x$1.s) x$1.s = 1;
			return x$1;
		};
		P.comparedTo = P.cmp = function(y$1) {
			var i, j, xdL, ydL, x$1 = this;
			y$1 = new x$1.constructor(y$1);
			if (x$1.s !== y$1.s) return x$1.s || -y$1.s;
			if (x$1.e !== y$1.e) return x$1.e > y$1.e ^ x$1.s < 0 ? 1 : -1;
			xdL = x$1.d.length;
			ydL = y$1.d.length;
			for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) if (x$1.d[i] !== y$1.d[i]) return x$1.d[i] > y$1.d[i] ^ x$1.s < 0 ? 1 : -1;
			return xdL === ydL ? 0 : xdL > ydL ^ x$1.s < 0 ? 1 : -1;
		};
		P.decimalPlaces = P.dp = function() {
			var x$1 = this, w = x$1.d.length - 1, dp = (w - x$1.e) * LOG_BASE;
			w = x$1.d[w];
			if (w) for (; w % 10 == 0; w /= 10) dp--;
			return dp < 0 ? 0 : dp;
		};
		P.dividedBy = P.div = function(y$1) {
			return divide(this, new this.constructor(y$1));
		};
		P.dividedToIntegerBy = P.idiv = function(y$1) {
			var x$1 = this, Ctor = x$1.constructor;
			return round(divide(x$1, new Ctor(y$1), 0, 1), Ctor.precision);
		};
		P.equals = P.eq = function(y$1) {
			return !this.cmp(y$1);
		};
		P.exponent = function() {
			return getBase10Exponent(this);
		};
		P.greaterThan = P.gt = function(y$1) {
			return this.cmp(y$1) > 0;
		};
		P.greaterThanOrEqualTo = P.gte = function(y$1) {
			return this.cmp(y$1) >= 0;
		};
		P.isInteger = P.isint = function() {
			return this.e > this.d.length - 2;
		};
		P.isNegative = P.isneg = function() {
			return this.s < 0;
		};
		P.isPositive = P.ispos = function() {
			return this.s > 0;
		};
		P.isZero = function() {
			return this.s === 0;
		};
		P.lessThan = P.lt = function(y$1) {
			return this.cmp(y$1) < 0;
		};
		P.lessThanOrEqualTo = P.lte = function(y$1) {
			return this.cmp(y$1) < 1;
		};
		P.logarithm = P.log = function(base) {
			var r$1, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision, wpr = pr + 5;
			if (base === void 0) base = new Ctor(10);
			else {
				base = new Ctor(base);
				if (base.s < 1 || base.eq(ONE)) throw Error(decimalError + "NaN");
			}
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			external = false;
			r$1 = divide(ln(x$1, wpr), ln(base, wpr), wpr);
			external = true;
			return round(r$1, pr);
		};
		P.minus = P.sub = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? subtract(x$1, y$1) : add(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.modulo = P.mod = function(y$1) {
			var q, x$1 = this, Ctor = x$1.constructor, pr = Ctor.precision;
			y$1 = new Ctor(y$1);
			if (!y$1.s) throw Error(decimalError + "NaN");
			if (!x$1.s) return round(new Ctor(x$1), pr);
			external = false;
			q = divide(x$1, y$1, 0, 1).times(y$1);
			external = true;
			return x$1.minus(q);
		};
		P.naturalExponential = P.exp = function() {
			return exp(this);
		};
		P.naturalLogarithm = P.ln = function() {
			return ln(this);
		};
		P.negated = P.neg = function() {
			var x$1 = new this.constructor(this);
			x$1.s = -x$1.s || 0;
			return x$1;
		};
		P.plus = P.add = function(y$1) {
			var x$1 = this;
			y$1 = new x$1.constructor(y$1);
			return x$1.s == y$1.s ? add(x$1, y$1) : subtract(x$1, (y$1.s = -y$1.s, y$1));
		};
		P.precision = P.sd = function(z) {
			var e, sd, w, x$1 = this;
			if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
			e = getBase10Exponent(x$1) + 1;
			w = x$1.d.length - 1;
			sd = w * LOG_BASE + 1;
			w = x$1.d[w];
			if (w) {
				for (; w % 10 == 0; w /= 10) sd--;
				for (w = x$1.d[0]; w >= 10; w /= 10) sd++;
			}
			return z && e > sd ? e : sd;
		};
		P.squareRoot = P.sqrt = function() {
			var e, n, pr, r$1, s$1, t, wpr, x$1 = this, Ctor = x$1.constructor;
			if (x$1.s < 1) {
				if (!x$1.s) return new Ctor(0);
				throw Error(decimalError + "NaN");
			}
			e = getBase10Exponent(x$1);
			external = false;
			s$1 = Math.sqrt(+x$1);
			if (s$1 == 0 || s$1 == Infinity) {
				n = digitsToString(x$1.d);
				if ((n.length + e) % 2 == 0) n += "0";
				s$1 = Math.sqrt(n);
				e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
				if (s$1 == Infinity) n = "5e" + e;
				else {
					n = s$1.toExponential();
					n = n.slice(0, n.indexOf("e") + 1) + e;
				}
				r$1 = new Ctor(n);
			} else r$1 = new Ctor(s$1.toString());
			pr = Ctor.precision;
			s$1 = wpr = pr + 3;
			for (;;) {
				t = r$1;
				r$1 = t.plus(divide(x$1, t, wpr + 2)).times(.5);
				if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r$1.d)).slice(0, wpr)) {
					n = n.slice(wpr - 3, wpr + 1);
					if (s$1 == wpr && n == "4999") {
						round(t, pr + 1, 0);
						if (t.times(t).eq(x$1)) {
							r$1 = t;
							break;
						}
					} else if (n != "9999") break;
					wpr += 4;
				}
			}
			external = true;
			return round(r$1, pr);
		};
		P.times = P.mul = function(y$1) {
			var carry, e, i, k$1, r$1, rL, t, xdL, ydL, x$1 = this, Ctor = x$1.constructor, xd = x$1.d, yd = (y$1 = new Ctor(y$1)).d;
			if (!x$1.s || !y$1.s) return new Ctor(0);
			y$1.s *= x$1.s;
			e = x$1.e + y$1.e;
			xdL = xd.length;
			ydL = yd.length;
			if (xdL < ydL) {
				r$1 = xd;
				xd = yd;
				yd = r$1;
				rL = xdL;
				xdL = ydL;
				ydL = rL;
			}
			r$1 = [];
			rL = xdL + ydL;
			for (i = rL; i--;) r$1.push(0);
			for (i = ydL; --i >= 0;) {
				carry = 0;
				for (k$1 = xdL + i; k$1 > i;) {
					t = r$1[k$1] + yd[i] * xd[k$1 - i - 1] + carry;
					r$1[k$1--] = t % BASE | 0;
					carry = t / BASE | 0;
				}
				r$1[k$1] = (r$1[k$1] + carry) % BASE | 0;
			}
			for (; !r$1[--rL];) r$1.pop();
			if (carry) ++e;
			else r$1.shift();
			y$1.d = r$1;
			y$1.e = e;
			return external ? round(y$1, Ctor.precision) : y$1;
		};
		P.toDecimalPlaces = P.todp = function(dp, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			x$1 = new Ctor(x$1);
			if (dp === void 0) return x$1;
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			return round(x$1, dp + getBase10Exponent(x$1) + 1, rm);
		};
		P.toExponential = function(dp, rm) {
			var str, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) str = toString$2(x$1, true);
			else {
				checkInt32(dp, 0, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), dp + 1, rm);
				str = toString$2(x$1, true, dp + 1);
			}
			return str;
		};
		P.toFixed = function(dp, rm) {
			var str, y$1, x$1 = this, Ctor = x$1.constructor;
			if (dp === void 0) return toString$2(x$1);
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			y$1 = round(new Ctor(x$1), dp + getBase10Exponent(x$1) + 1, rm);
			str = toString$2(y$1.abs(), false, dp + getBase10Exponent(y$1) + 1);
			return x$1.isneg() && !x$1.isZero() ? "-" + str : str;
		};
		P.toInteger = P.toint = function() {
			var x$1 = this, Ctor = x$1.constructor;
			return round(new Ctor(x$1), getBase10Exponent(x$1) + 1, Ctor.rounding);
		};
		P.toNumber = function() {
			return +this;
		};
		P.toPower = P.pow = function(y$1) {
			var e, k$1, pr, r$1, sign$1, yIsInt, x$1 = this, Ctor = x$1.constructor, guard = 12, yn = +(y$1 = new Ctor(y$1));
			if (!y$1.s) return new Ctor(ONE);
			x$1 = new Ctor(x$1);
			if (!x$1.s) {
				if (y$1.s < 1) throw Error(decimalError + "Infinity");
				return x$1;
			}
			if (x$1.eq(ONE)) return x$1;
			pr = Ctor.precision;
			if (y$1.eq(ONE)) return round(x$1, pr);
			e = y$1.e;
			k$1 = y$1.d.length - 1;
			yIsInt = e >= k$1;
			sign$1 = x$1.s;
			if (!yIsInt) {
				if (sign$1 < 0) throw Error(decimalError + "NaN");
			} else if ((k$1 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
				r$1 = new Ctor(ONE);
				e = Math.ceil(pr / LOG_BASE + 4);
				external = false;
				for (;;) {
					if (k$1 % 2) {
						r$1 = r$1.times(x$1);
						truncate(r$1.d, e);
					}
					k$1 = mathfloor(k$1 / 2);
					if (k$1 === 0) break;
					x$1 = x$1.times(x$1);
					truncate(x$1.d, e);
				}
				external = true;
				return y$1.s < 0 ? new Ctor(ONE).div(r$1) : round(r$1, pr);
			}
			sign$1 = sign$1 < 0 && y$1.d[Math.max(e, k$1)] & 1 ? -1 : 1;
			x$1.s = 1;
			external = false;
			r$1 = y$1.times(ln(x$1, pr + guard));
			external = true;
			r$1 = exp(r$1);
			r$1.s = sign$1;
			return r$1;
		};
		P.toPrecision = function(sd, rm) {
			var e, str, x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				e = getBase10Exponent(x$1);
				str = toString$2(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x$1 = round(new Ctor(x$1), sd, rm);
				e = getBase10Exponent(x$1);
				str = toString$2(x$1, sd <= e || e <= Ctor.toExpNeg, sd);
			}
			return str;
		};
		P.toSignificantDigits = P.tosd = function(sd, rm) {
			var x$1 = this, Ctor = x$1.constructor;
			if (sd === void 0) {
				sd = Ctor.precision;
				rm = Ctor.rounding;
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
			}
			return round(new Ctor(x$1), sd, rm);
		};
		P.toString = P.valueOf = P.val = P.toJSON = function() {
			var x$1 = this, e = getBase10Exponent(x$1), Ctor = x$1.constructor;
			return toString$2(x$1, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
		};
		function add(x$1, y$1) {
			var carry, d, e, i, k$1, len, xd, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (!y$1.s) y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			k$1 = x$1.e;
			e = y$1.e;
			xd = xd.slice();
			i = k$1 - e;
			if (i) {
				if (i < 0) {
					d = xd;
					i = -i;
					len = yd.length;
				} else {
					d = yd;
					e = k$1;
					len = xd.length;
				}
				k$1 = Math.ceil(pr / LOG_BASE);
				len = k$1 > len ? k$1 + 1 : len + 1;
				if (i > len) {
					i = len;
					d.length = 1;
				}
				d.reverse();
				for (; i--;) d.push(0);
				d.reverse();
			}
			len = xd.length;
			i = yd.length;
			if (len - i < 0) {
				i = len;
				d = yd;
				yd = xd;
				xd = d;
			}
			for (carry = 0; i;) {
				carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
				xd[i] %= BASE;
			}
			if (carry) {
				xd.unshift(carry);
				++e;
			}
			for (len = xd.length; xd[--len] == 0;) xd.pop();
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function checkInt32(i, min$1, max$1) {
			if (i !== ~~i || i < min$1 || i > max$1) throw Error(invalidArgument + i);
		}
		function digitsToString(d) {
			var i, k$1, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
			if (indexOfLastWord > 0) {
				str += w;
				for (i = 1; i < indexOfLastWord; i++) {
					ws = d[i] + "";
					k$1 = LOG_BASE - ws.length;
					if (k$1) str += getZeroString(k$1);
					str += ws;
				}
				w = d[i];
				ws = w + "";
				k$1 = LOG_BASE - ws.length;
				if (k$1) str += getZeroString(k$1);
			} else if (w === 0) return "0";
			for (; w % 10 === 0;) w /= 10;
			return str + w;
		}
		var divide = (function() {
			function multiplyInteger(x$1, k$1) {
				var temp, carry = 0, i = x$1.length;
				for (x$1 = x$1.slice(); i--;) {
					temp = x$1[i] * k$1 + carry;
					x$1[i] = temp % BASE | 0;
					carry = temp / BASE | 0;
				}
				if (carry) x$1.unshift(carry);
				return x$1;
			}
			function compare(a$1, b, aL, bL) {
				var i, r$1;
				if (aL != bL) r$1 = aL > bL ? 1 : -1;
				else for (i = r$1 = 0; i < aL; i++) if (a$1[i] != b[i]) {
					r$1 = a$1[i] > b[i] ? 1 : -1;
					break;
				}
				return r$1;
			}
			function subtract$1(a$1, b, aL) {
				var i = 0;
				for (; aL--;) {
					a$1[aL] -= i;
					i = a$1[aL] < b[aL] ? 1 : 0;
					a$1[aL] = i * BASE + a$1[aL] - b[aL];
				}
				for (; !a$1[0] && a$1.length > 1;) a$1.shift();
			}
			return function(x$1, y$1, pr, dp) {
				var cmp, e, i, k$1, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x$1.constructor, sign$1 = x$1.s == y$1.s ? 1 : -1, xd = x$1.d, yd = y$1.d;
				if (!x$1.s) return new Ctor(x$1);
				if (!y$1.s) throw Error(decimalError + "Division by zero");
				e = x$1.e - y$1.e;
				yL = yd.length;
				xL = xd.length;
				q = new Ctor(sign$1);
				qd = q.d = [];
				for (i = 0; yd[i] == (xd[i] || 0);) ++i;
				if (yd[i] > (xd[i] || 0)) --e;
				if (pr == null) sd = pr = Ctor.precision;
				else if (dp) sd = pr + (getBase10Exponent(x$1) - getBase10Exponent(y$1)) + 1;
				else sd = pr;
				if (sd < 0) return new Ctor(0);
				sd = sd / LOG_BASE + 2 | 0;
				i = 0;
				if (yL == 1) {
					k$1 = 0;
					yd = yd[0];
					sd++;
					for (; (i < xL || k$1) && sd--; i++) {
						t = k$1 * BASE + (xd[i] || 0);
						qd[i] = t / yd | 0;
						k$1 = t % yd | 0;
					}
				} else {
					k$1 = BASE / (yd[0] + 1) | 0;
					if (k$1 > 1) {
						yd = multiplyInteger(yd, k$1);
						xd = multiplyInteger(xd, k$1);
						yL = yd.length;
						xL = xd.length;
					}
					xi = yL;
					rem = xd.slice(0, yL);
					remL = rem.length;
					for (; remL < yL;) rem[remL++] = 0;
					yz = yd.slice();
					yz.unshift(0);
					yd0 = yd[0];
					if (yd[1] >= BASE / 2) ++yd0;
					do {
						k$1 = 0;
						cmp = compare(yd, rem, yL, remL);
						if (cmp < 0) {
							rem0 = rem[0];
							if (yL != remL) rem0 = rem0 * BASE + (rem[1] || 0);
							k$1 = rem0 / yd0 | 0;
							if (k$1 > 1) {
								if (k$1 >= BASE) k$1 = BASE - 1;
								prod = multiplyInteger(yd, k$1);
								prodL = prod.length;
								remL = rem.length;
								cmp = compare(prod, rem, prodL, remL);
								if (cmp == 1) {
									k$1--;
									subtract$1(prod, yL < prodL ? yz : yd, prodL);
								}
							} else {
								if (k$1 == 0) cmp = k$1 = 1;
								prod = yd.slice();
							}
							prodL = prod.length;
							if (prodL < remL) prod.unshift(0);
							subtract$1(rem, prod, remL);
							if (cmp == -1) {
								remL = rem.length;
								cmp = compare(yd, rem, yL, remL);
								if (cmp < 1) {
									k$1++;
									subtract$1(rem, yL < remL ? yz : yd, remL);
								}
							}
							remL = rem.length;
						} else if (cmp === 0) {
							k$1++;
							rem = [0];
						}
						qd[i++] = k$1;
						if (cmp && rem[0]) rem[remL++] = xd[xi] || 0;
						else {
							rem = [xd[xi]];
							remL = 1;
						}
					} while ((xi++ < xL || rem[0] !== void 0) && sd--);
				}
				if (!qd[0]) qd.shift();
				q.e = e;
				return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
			};
		})();
		function exp(x$1, sd) {
			var denominator, guard, pow$1, sum, t, wpr, i = 0, k$1 = 0, Ctor = x$1.constructor, pr = Ctor.precision;
			if (getBase10Exponent(x$1) > 16) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			if (!x$1.s) return new Ctor(ONE);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			t = new Ctor(.03125);
			while (x$1.abs().gte(.1)) {
				x$1 = x$1.times(t);
				k$1 += 5;
			}
			guard = Math.log(mathpow(2, k$1)) / Math.LN10 * 2 + 5 | 0;
			wpr += guard;
			denominator = pow$1 = sum = new Ctor(ONE);
			Ctor.precision = wpr;
			for (;;) {
				pow$1 = round(pow$1.times(x$1), wpr);
				denominator = denominator.times(++i);
				t = sum.plus(divide(pow$1, denominator, wpr));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					while (k$1--) sum = round(sum.times(sum), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t;
			}
		}
		function getBase10Exponent(x$1) {
			var e = x$1.e * LOG_BASE, w = x$1.d[0];
			for (; w >= 10; w /= 10) e++;
			return e;
		}
		function getLn10(Ctor, sd, pr) {
			if (sd > Ctor.LN10.sd()) {
				external = true;
				if (pr) Ctor.precision = pr;
				throw Error(decimalError + "LN10 precision limit exceeded");
			}
			return round(new Ctor(Ctor.LN10), sd);
		}
		function getZeroString(k$1) {
			var zs = "";
			for (; k$1--;) zs += "0";
			return zs;
		}
		function ln(y$1, sd) {
			var c$1, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x$1 = y$1, xd = x$1.d, Ctor = x$1.constructor, pr = Ctor.precision;
			if (x$1.s < 1) throw Error(decimalError + (x$1.s ? "NaN" : "-Infinity"));
			if (x$1.eq(ONE)) return new Ctor(0);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			if (x$1.eq(10)) {
				if (sd == null) external = true;
				return getLn10(Ctor, wpr);
			}
			wpr += guard;
			Ctor.precision = wpr;
			c$1 = digitsToString(xd);
			c0 = c$1.charAt(0);
			e = getBase10Exponent(x$1);
			if (Math.abs(e) < 0x5543df729c000) {
				while (c0 < 7 && c0 != 1 || c0 == 1 && c$1.charAt(1) > 3) {
					x$1 = x$1.times(y$1);
					c$1 = digitsToString(x$1.d);
					c0 = c$1.charAt(0);
					n++;
				}
				e = getBase10Exponent(x$1);
				if (c0 > 1) {
					x$1 = new Ctor("0." + c$1);
					e++;
				} else x$1 = new Ctor(c0 + "." + c$1.slice(1));
			} else {
				t = getLn10(Ctor, wpr + 2, pr).times(e + "");
				x$1 = ln(new Ctor(c0 + "." + c$1.slice(1)), wpr - guard).plus(t);
				Ctor.precision = pr;
				return sd == null ? (external = true, round(x$1, pr)) : x$1;
			}
			sum = numerator = x$1 = divide(x$1.minus(ONE), x$1.plus(ONE), wpr);
			x2 = round(x$1.times(x$1), wpr);
			denominator = 3;
			for (;;) {
				numerator = round(numerator.times(x2), wpr);
				t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
					sum = sum.times(2);
					if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
					sum = divide(sum, new Ctor(n), wpr);
					Ctor.precision = pr;
					return sd == null ? (external = true, round(sum, pr)) : sum;
				}
				sum = t;
				denominator += 2;
			}
		}
		function parseDecimal(x$1, str) {
			var e, i, len;
			if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
			if ((i = str.search(/e/i)) > 0) {
				if (e < 0) e = i;
				e += +str.slice(i + 1);
				str = str.substring(0, i);
			} else if (e < 0) e = str.length;
			for (i = 0; str.charCodeAt(i) === 48;) ++i;
			for (len = str.length; str.charCodeAt(len - 1) === 48;) --len;
			str = str.slice(i, len);
			if (str) {
				len -= i;
				e = e - i - 1;
				x$1.e = mathfloor(e / LOG_BASE);
				x$1.d = [];
				i = (e + 1) % LOG_BASE;
				if (e < 0) i += LOG_BASE;
				if (i < len) {
					if (i) x$1.d.push(+str.slice(0, i));
					for (len -= LOG_BASE; i < len;) x$1.d.push(+str.slice(i, i += LOG_BASE));
					str = str.slice(i);
					i = LOG_BASE - str.length;
				} else i -= len;
				for (; i--;) str += "0";
				x$1.d.push(+str);
				if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + e);
			} else {
				x$1.s = 0;
				x$1.e = 0;
				x$1.d = [0];
			}
			return x$1;
		}
		function round(x$1, sd, rm) {
			var i, j, k$1, n, rd, doRound, w, xdi, xd = x$1.d;
			for (n = 1, k$1 = xd[0]; k$1 >= 10; k$1 /= 10) n++;
			i = sd - n;
			if (i < 0) {
				i += LOG_BASE;
				j = sd;
				w = xd[xdi = 0];
			} else {
				xdi = Math.ceil((i + 1) / LOG_BASE);
				k$1 = xd.length;
				if (xdi >= k$1) return x$1;
				w = k$1 = xd[xdi];
				for (n = 1; k$1 >= 10; k$1 /= 10) n++;
				i %= LOG_BASE;
				j = i - LOG_BASE + n;
			}
			if (rm !== void 0) {
				k$1 = mathpow(10, n - j - 1);
				rd = w / k$1 % 10 | 0;
				doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k$1;
				doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x$1.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x$1.s < 0 ? 8 : 7));
			}
			if (sd < 1 || !xd[0]) {
				if (doRound) {
					k$1 = getBase10Exponent(x$1);
					xd.length = 1;
					sd = sd - k$1 - 1;
					xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
					x$1.e = mathfloor(-sd / LOG_BASE) || 0;
				} else {
					xd.length = 1;
					xd[0] = x$1.e = x$1.s = 0;
				}
				return x$1;
			}
			if (i == 0) {
				xd.length = xdi;
				k$1 = 1;
				xdi--;
			} else {
				xd.length = xdi + 1;
				k$1 = mathpow(10, LOG_BASE - i);
				xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k$1 : 0;
			}
			if (doRound) for (;;) if (xdi == 0) {
				if ((xd[0] += k$1) == BASE) {
					xd[0] = 1;
					++x$1.e;
				}
				break;
			} else {
				xd[xdi] += k$1;
				if (xd[xdi] != BASE) break;
				xd[xdi--] = 0;
				k$1 = 1;
			}
			for (i = xd.length; xd[--i] === 0;) xd.pop();
			if (external && (x$1.e > MAX_E || x$1.e < -MAX_E)) throw Error(exponentOutOfRange + getBase10Exponent(x$1));
			return x$1;
		}
		function subtract(x$1, y$1) {
			var d, e, i, j, k$1, len, xd, xe, xLTy, yd, Ctor = x$1.constructor, pr = Ctor.precision;
			if (!x$1.s || !y$1.s) {
				if (y$1.s) y$1.s = -y$1.s;
				else y$1 = new Ctor(x$1);
				return external ? round(y$1, pr) : y$1;
			}
			xd = x$1.d;
			yd = y$1.d;
			e = y$1.e;
			xe = x$1.e;
			xd = xd.slice();
			k$1 = xe - e;
			if (k$1) {
				xLTy = k$1 < 0;
				if (xLTy) {
					d = xd;
					k$1 = -k$1;
					len = yd.length;
				} else {
					d = yd;
					e = xe;
					len = xd.length;
				}
				i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
				if (k$1 > i) {
					k$1 = i;
					d.length = 1;
				}
				d.reverse();
				for (i = k$1; i--;) d.push(0);
				d.reverse();
			} else {
				i = xd.length;
				len = yd.length;
				xLTy = i < len;
				if (xLTy) len = i;
				for (i = 0; i < len; i++) if (xd[i] != yd[i]) {
					xLTy = xd[i] < yd[i];
					break;
				}
				k$1 = 0;
			}
			if (xLTy) {
				d = xd;
				xd = yd;
				yd = d;
				y$1.s = -y$1.s;
			}
			len = xd.length;
			for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
			for (i = yd.length; i > k$1;) {
				if (xd[--i] < yd[i]) {
					for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
					--xd[j];
					xd[i] += BASE;
				}
				xd[i] -= yd[i];
			}
			for (; xd[--len] === 0;) xd.pop();
			for (; xd[0] === 0; xd.shift()) --e;
			if (!xd[0]) return new Ctor(0);
			y$1.d = xd;
			y$1.e = e;
			return external ? round(y$1, pr) : y$1;
		}
		function toString$2(x$1, isExp, sd) {
			var k$1, e = getBase10Exponent(x$1), str = digitsToString(x$1.d), len = str.length;
			if (isExp) {
				if (sd && (k$1 = sd - len) > 0) str = str.charAt(0) + "." + str.slice(1) + getZeroString(k$1);
				else if (len > 1) str = str.charAt(0) + "." + str.slice(1);
				str = str + (e < 0 ? "e" : "e+") + e;
			} else if (e < 0) {
				str = "0." + getZeroString(-e - 1) + str;
				if (sd && (k$1 = sd - len) > 0) str += getZeroString(k$1);
			} else if (e >= len) {
				str += getZeroString(e + 1 - len);
				if (sd && (k$1 = sd - e - 1) > 0) str = str + "." + getZeroString(k$1);
			} else {
				if ((k$1 = e + 1) < len) str = str.slice(0, k$1) + "." + str.slice(k$1);
				if (sd && (k$1 = sd - len) > 0) {
					if (e + 1 === len) str += ".";
					str += getZeroString(k$1);
				}
			}
			return x$1.s < 0 ? "-" + str : str;
		}
		function truncate(arr, len) {
			if (arr.length > len) {
				arr.length = len;
				return true;
			}
		}
		function clone(obj) {
			var i, p, ps;
			function Decimal$3(value) {
				var x$1 = this;
				if (!(x$1 instanceof Decimal$3)) return new Decimal$3(value);
				x$1.constructor = Decimal$3;
				if (value instanceof Decimal$3) {
					x$1.s = value.s;
					x$1.e = value.e;
					x$1.d = (value = value.d) ? value.slice() : value;
					return;
				}
				if (typeof value === "number") {
					if (value * 0 !== 0) throw Error(invalidArgument + value);
					if (value > 0) x$1.s = 1;
					else if (value < 0) {
						value = -value;
						x$1.s = -1;
					} else {
						x$1.s = 0;
						x$1.e = 0;
						x$1.d = [0];
						return;
					}
					if (value === ~~value && value < 1e7) {
						x$1.e = 0;
						x$1.d = [value];
						return;
					}
					return parseDecimal(x$1, value.toString());
				} else if (typeof value !== "string") throw Error(invalidArgument + value);
				if (value.charCodeAt(0) === 45) {
					value = value.slice(1);
					x$1.s = -1;
				} else x$1.s = 1;
				if (isDecimal.test(value)) parseDecimal(x$1, value);
				else throw Error(invalidArgument + value);
			}
			Decimal$3.prototype = P;
			Decimal$3.ROUND_UP = 0;
			Decimal$3.ROUND_DOWN = 1;
			Decimal$3.ROUND_CEIL = 2;
			Decimal$3.ROUND_FLOOR = 3;
			Decimal$3.ROUND_HALF_UP = 4;
			Decimal$3.ROUND_HALF_DOWN = 5;
			Decimal$3.ROUND_HALF_EVEN = 6;
			Decimal$3.ROUND_HALF_CEIL = 7;
			Decimal$3.ROUND_HALF_FLOOR = 8;
			Decimal$3.clone = clone;
			Decimal$3.config = Decimal$3.set = config;
			if (obj === void 0) obj = {};
			if (obj) {
				ps = [
					"precision",
					"rounding",
					"toExpNeg",
					"toExpPos",
					"LN10"
				];
				for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
			}
			Decimal$3.config(obj);
			return Decimal$3;
		}
		function config(obj) {
			if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
			var i, p, v, ps = [
				"precision",
				1,
				MAX_DIGITS,
				"rounding",
				0,
				8,
				"toExpNeg",
				-Infinity,
				0,
				"toExpPos",
				0,
				Infinity
			];
			for (i = 0; i < ps.length; i += 3) if ((v = obj[p = ps[i]]) !== void 0) if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
			else throw Error(invalidArgument + p + ": " + v);
			if ((v = obj[p = "LN10"]) !== void 0) if (v == Math.LN10) this[p] = new this(v);
			else throw Error(invalidArgument + p + ": " + v);
			return this;
		}
		Decimal$2 = clone(Decimal$2);
		Decimal$2["default"] = Decimal$2.Decimal = Decimal$2;
		ONE = new Decimal$2(1);
		if (typeof define == "function" && define.amd) define(function() {
			return Decimal$2;
		});
		else if (typeof module != "undefined" && module.exports) module.exports = Decimal$2;
		else {
			if (!globalScope) globalScope = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
			globalScope.Decimal = Decimal$2;
		}
	})(exports);
}) });

//#endregion
//#region node_modules/recharts/es6/util/scale/util/utils.js
var import_decimal$1 = /* @__PURE__ */ __toESM(require_decimal());
var identity$2 = (i) => i;
var PLACE_HOLDER = { "@@functional/placeholder": true };
var isPlaceHolder = (val) => val === PLACE_HOLDER;
var curry0 = (fn) => function _curried() {
	if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) return _curried;
	return fn(...arguments);
};
var curryN = (n, fn) => {
	if (n === 1) return fn;
	return curry0(function() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
		var argsLength = args.filter((arg) => arg !== PLACE_HOLDER).length;
		if (argsLength >= n) return fn(...args);
		return curryN(n - argsLength, curry0(function() {
			for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) restArgs[_key2] = arguments[_key2];
			var newArgs = args.map((arg) => isPlaceHolder(arg) ? restArgs.shift() : arg);
			return fn(...newArgs, ...restArgs);
		}));
	});
};
var curry = (fn) => curryN(fn.length, fn);
var range$2 = (begin, end) => {
	var arr = [];
	for (var i = begin; i < end; ++i) arr[i - begin] = i;
	return arr;
};
var map = curry((fn, arr) => {
	if (Array.isArray(arr)) return arr.map(fn);
	return Object.keys(arr).map((key) => arr[key]).map(fn);
});
var compose = function compose$2() {
	for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
	if (!args.length) return identity$2;
	var fns = args.reverse();
	var firstFn = fns[0];
	var tailsFn = fns.slice(1);
	return function() {
		return tailsFn.reduce((res, fn) => fn(res), firstFn(...arguments));
	};
};
var reverse = (arr) => {
	if (Array.isArray(arr)) return arr.reverse();
	return arr.split("").reverse().join("");
};
var memoize = (fn) => {
	var lastArgs = null;
	var lastResult$1 = null;
	return function() {
		for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
		if (lastArgs && args.every((val, i) => {
			var _lastArgs;
			return val === ((_lastArgs = lastArgs) === null || _lastArgs === void 0 ? void 0 : _lastArgs[i]);
		})) return lastResult$1;
		lastArgs = args;
		lastResult$1 = fn(...args);
		return lastResult$1;
	};
};

//#endregion
//#region node_modules/recharts/es6/util/scale/util/arithmetic.js
/**
* Get the digit count of a number.
* If the absolute value is in the interval [0.1, 1), the result is 0.
* If the absolute value is in the interval [0.01, 0.1), the digit count is -1.
* If the absolute value is in the interval [0.001, 0.01), the digit count is -2.
*
* @param  {Number} value The number
* @return {Integer}      Digit count
*/
function getDigitCount(value) {
	var result;
	if (value === 0) result = 1;
	else result = Math.floor(new import_decimal$1.default(value).abs().log(10).toNumber()) + 1;
	return result;
}
/**
* Get the data in the interval [start, end) with a fixed step.
* Also handles JS calculation precision issues.
*
* @param  {Decimal} start Start point
* @param  {Decimal} end   End point, not included
* @param  {Decimal} step  Step size
* @return {Array}         Array of numbers
*/
function rangeStep(start, end, step) {
	var num = new import_decimal$1.default(start);
	var i = 0;
	var result = [];
	while (num.lt(end) && i < 1e5) {
		result.push(num.toNumber());
		num = num.add(step);
		i++;
	}
	return result;
}
/**
* Linear interpolation of numbers.
*
* @param  {Number} a  Endpoint of the domain
* @param  {Number} b  Endpoint of the domain
* @param  {Number} t  A value in [0, 1]
* @return {Number}    A value in the domain
*/
var interpolateNumber$1 = curry((a$1, b, t) => {
	var newA = +a$1;
	var newB = +b;
	return newA + t * (newB - newA);
});
/**
* Inverse operation of linear interpolation.
*
* @param  {Number} a Endpoint of the domain
* @param  {Number} b Endpoint of the domain
* @param  {Number} x Can be considered as an output value after interpolation
* @return {Number}   When x is in the range a ~ b, the return value is in [0, 1]
*/
var uninterpolateNumber = curry((a$1, b, x$1) => {
	var diff = b - +a$1;
	diff = diff || Infinity;
	return (x$1 - a$1) / diff;
});
/**
* Inverse operation of linear interpolation with truncation.
*
* @param  {Number} a Endpoint of the domain
* @param  {Number} b Endpoint of the domain
* @param  {Number} x Can be considered as an output value after interpolation
* @return {Number}   When x is in the interval a ~ b, the return value is in [0, 1].
*                    When x is not in the interval a ~ b, it will be truncated to the interval a ~ b.
*/
var uninterpolateTruncation = curry((a$1, b, x$1) => {
	var diff = b - +a$1;
	diff = diff || Infinity;
	return Math.max(0, Math.min(1, (x$1 - a$1) / diff));
});

//#endregion
//#region node_modules/recharts/es6/util/scale/getNiceTickValues.js
var import_decimal = /* @__PURE__ */ __toESM(require_decimal());
/**
* Calculate a interval of a minimum value and a maximum value
*
* @param  {Number} min       The minimum value
* @param  {Number} max       The maximum value
* @return {Array} An interval
*/
var getValidInterval = (_ref$1) => {
	var [min$1, max$1] = _ref$1;
	var [validMin, validMax] = [min$1, max$1];
	if (min$1 > max$1) [validMin, validMax] = [max$1, min$1];
	return [validMin, validMax];
};
/**
* Calculate the step which is easy to understand between ticks, like 10, 20, 25
*
* @param  roughStep        The rough step calculated by dividing the difference by the tickCount
* @param  allowDecimals    Allow the ticks to be decimals or not
* @param  correctionFactor A correction factor
* @return The step which is easy to understand between two ticks
*/
var getFormatStep = (roughStep, allowDecimals, correctionFactor) => {
	if (roughStep.lte(0)) return new import_decimal.default(0);
	var digitCount = getDigitCount(roughStep.toNumber());
	var digitCountValue = new import_decimal.default(10).pow(digitCount);
	var stepRatio = roughStep.div(digitCountValue);
	var stepRatioScale = digitCount !== 1 ? .05 : .1;
	var formatStep = new import_decimal.default(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale).mul(digitCountValue);
	return allowDecimals ? new import_decimal.default(formatStep.toNumber()) : new import_decimal.default(Math.ceil(formatStep.toNumber()));
};
/**
* calculate the ticks when the minimum value equals to the maximum value
*
* @param  value         The minimum value which is also the maximum value
* @param  tickCount     The count of ticks
* @param  allowDecimals Allow the ticks to be decimals or not
* @return array of ticks
*/
var getTickOfSingleValue = (value, tickCount, allowDecimals) => {
	var step = new import_decimal.default(1);
	var middle = new import_decimal.default(value);
	if (!middle.isint() && allowDecimals) {
		var absVal = Math.abs(value);
		if (absVal < 1) {
			step = new import_decimal.default(10).pow(getDigitCount(value) - 1);
			middle = new import_decimal.default(Math.floor(middle.div(step).toNumber())).mul(step);
		} else if (absVal > 1) middle = new import_decimal.default(Math.floor(value));
	} else if (value === 0) middle = new import_decimal.default(Math.floor((tickCount - 1) / 2));
	else if (!allowDecimals) middle = new import_decimal.default(Math.floor(value));
	var middleIndex = Math.floor((tickCount - 1) / 2);
	return compose(map((n) => middle.add(new import_decimal.default(n - middleIndex).mul(step)).toNumber()), range$2)(0, tickCount);
};
/**
* Calculate the step
*
* @param  min              The minimum value of an interval
* @param  max              The maximum value of an interval
* @param  tickCount        The count of ticks
* @param  allowDecimals    Allow the ticks to be decimals or not
* @param  correctionFactor A correction factor
* @return The step, minimum value of ticks, maximum value of ticks
*/
var _calculateStep = function calculateStep(min$1, max$1, tickCount, allowDecimals) {
	var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
	if (!Number.isFinite((max$1 - min$1) / (tickCount - 1))) return {
		step: new import_decimal.default(0),
		tickMin: new import_decimal.default(0),
		tickMax: new import_decimal.default(0)
	};
	var step = getFormatStep(new import_decimal.default(max$1).sub(min$1).div(tickCount - 1), allowDecimals, correctionFactor);
	var middle;
	if (min$1 <= 0 && max$1 >= 0) middle = new import_decimal.default(0);
	else {
		middle = new import_decimal.default(min$1).add(max$1).div(2);
		middle = middle.sub(new import_decimal.default(middle).mod(step));
	}
	var belowCount = Math.ceil(middle.sub(min$1).div(step).toNumber());
	var upCount = Math.ceil(new import_decimal.default(max$1).sub(middle).div(step).toNumber());
	var scaleCount = belowCount + upCount + 1;
	if (scaleCount > tickCount) return _calculateStep(min$1, max$1, tickCount, allowDecimals, correctionFactor + 1);
	if (scaleCount < tickCount) {
		upCount = max$1 > 0 ? upCount + (tickCount - scaleCount) : upCount;
		belowCount = max$1 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
	}
	return {
		step,
		tickMin: middle.sub(new import_decimal.default(belowCount).mul(step)),
		tickMax: middle.add(new import_decimal.default(upCount).mul(step))
	};
};
function getNiceTickValuesFn(_ref2) {
	var [min$1, max$1] = _ref2;
	var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var count = Math.max(tickCount, 2);
	var [cormin, cormax] = getValidInterval([min$1, max$1]);
	if (cormin === -Infinity || cormax === Infinity) {
		var _values = cormax === Infinity ? [cormin, ...range$2(0, tickCount - 1).map(() => Infinity)] : [...range$2(0, tickCount - 1).map(() => -Infinity), cormax];
		return min$1 > max$1 ? reverse(_values) : _values;
	}
	if (cormin === cormax) return getTickOfSingleValue(cormin, tickCount, allowDecimals);
	var { step, tickMin, tickMax } = _calculateStep(cormin, cormax, count, allowDecimals, 0);
	var values = rangeStep(tickMin, tickMax.add(new import_decimal.default(.1).mul(step)), step);
	return min$1 > max$1 ? reverse(values) : values;
}
/**
* Calculate the ticks of an interval.
* Ticks will be constrained to the interval [min, max] even if it makes them less rounded and nice.
*
* @param tuple of [min,max] min: The minimum value, max: The maximum value
* @param tickCount     The count of ticks. This function may return less than tickCount ticks if the interval is too small.
* @param allowDecimals Allow the ticks to be decimals or not
* @return array of ticks
*/
function getTickValuesFixedDomainFn(_ref3, tickCount) {
	var [min$1, max$1] = _ref3;
	var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
	var [cormin, cormax] = getValidInterval([min$1, max$1]);
	if (cormin === -Infinity || cormax === Infinity) return [min$1, max$1];
	if (cormin === cormax) return [cormin];
	var count = Math.max(tickCount, 2);
	var step = getFormatStep(new import_decimal.default(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
	var values = [...rangeStep(new import_decimal.default(cormin), new import_decimal.default(cormax), step), cormax];
	if (allowDecimals === false) values = values.map((value) => Math.round(value));
	return min$1 > max$1 ? reverse(values) : values;
}
var getNiceTickValues = memoize(getNiceTickValuesFn);
var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);

//#endregion
//#region node_modules/recharts/es6/state/selectors/rootPropsSelectors.js
var selectRootMaxBarSize = (state) => state.rootProps.maxBarSize;
var selectBarGap = (state) => state.rootProps.barGap;
var selectBarCategoryGap = (state) => state.rootProps.barCategoryGap;
var selectRootBarSize = (state) => state.rootProps.barSize;
var selectStackOffsetType = (state) => state.rootProps.stackOffset;
var selectChartName = (state) => state.options.chartName;
var selectSyncId = (state) => state.rootProps.syncId;
var selectSyncMethod = (state) => state.rootProps.syncMethod;
var selectEventEmitter = (state) => state.options.eventEmitter;

//#endregion
//#region node_modules/recharts/es6/polar/defaultPolarAngleAxisProps.js
var defaultPolarAngleAxisProps = {
	allowDuplicatedCategory: true,
	angleAxisId: 0,
	axisLine: true,
	cx: 0,
	cy: 0,
	orientation: "outer",
	reversed: false,
	scale: "auto",
	tick: true,
	tickLine: true,
	tickSize: 8,
	type: "category"
};

//#endregion
//#region node_modules/recharts/es6/polar/defaultPolarRadiusAxisProps.js
var defaultPolarRadiusAxisProps = {
	allowDataOverflow: false,
	allowDuplicatedCategory: true,
	angle: 0,
	axisLine: true,
	cx: 0,
	cy: 0,
	orientation: "right",
	radiusAxisId: 0,
	scale: "auto",
	stroke: "#ccc",
	tick: true,
	tickCount: 5,
	type: "number"
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineAxisRangeWithReverse.js
var combineAxisRangeWithReverse = (axisSettings, axisRange) => {
	if (!axisSettings || !axisRange) return;
	if (axisSettings !== null && axisSettings !== void 0 && axisSettings.reversed) return [axisRange[1], axisRange[0]];
	return axisRange;
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/polarAxisSelectors.js
var implicitAngleAxis = {
	allowDataOverflow: false,
	allowDecimals: false,
	allowDuplicatedCategory: false,
	dataKey: void 0,
	domain: void 0,
	id: defaultPolarAngleAxisProps.angleAxisId,
	includeHidden: false,
	name: void 0,
	reversed: defaultPolarAngleAxisProps.reversed,
	scale: defaultPolarAngleAxisProps.scale,
	tick: defaultPolarAngleAxisProps.tick,
	tickCount: void 0,
	ticks: void 0,
	type: defaultPolarAngleAxisProps.type,
	unit: void 0
};
var implicitRadiusAxis = {
	allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
	allowDecimals: false,
	allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
	dataKey: void 0,
	domain: void 0,
	id: defaultPolarRadiusAxisProps.radiusAxisId,
	includeHidden: false,
	name: void 0,
	reversed: false,
	scale: defaultPolarRadiusAxisProps.scale,
	tick: defaultPolarRadiusAxisProps.tick,
	tickCount: defaultPolarRadiusAxisProps.tickCount,
	ticks: void 0,
	type: defaultPolarRadiusAxisProps.type,
	unit: void 0
};
var implicitRadialBarAngleAxis = {
	allowDataOverflow: false,
	allowDecimals: false,
	allowDuplicatedCategory: defaultPolarAngleAxisProps.allowDuplicatedCategory,
	dataKey: void 0,
	domain: void 0,
	id: defaultPolarAngleAxisProps.angleAxisId,
	includeHidden: false,
	name: void 0,
	reversed: false,
	scale: defaultPolarAngleAxisProps.scale,
	tick: defaultPolarAngleAxisProps.tick,
	tickCount: void 0,
	ticks: void 0,
	type: "number",
	unit: void 0
};
var implicitRadialBarRadiusAxis = {
	allowDataOverflow: defaultPolarRadiusAxisProps.allowDataOverflow,
	allowDecimals: false,
	allowDuplicatedCategory: defaultPolarRadiusAxisProps.allowDuplicatedCategory,
	dataKey: void 0,
	domain: void 0,
	id: defaultPolarRadiusAxisProps.radiusAxisId,
	includeHidden: false,
	name: void 0,
	reversed: false,
	scale: defaultPolarRadiusAxisProps.scale,
	tick: defaultPolarRadiusAxisProps.tick,
	tickCount: defaultPolarRadiusAxisProps.tickCount,
	ticks: void 0,
	type: "category",
	unit: void 0
};
var selectAngleAxis = (state, angleAxisId) => {
	if (state.polarAxis.angleAxis[angleAxisId] != null) return state.polarAxis.angleAxis[angleAxisId];
	if (state.layout.layoutType === "radial") return implicitRadialBarAngleAxis;
	return implicitAngleAxis;
};
var selectRadiusAxis = (state, radiusAxisId) => {
	if (state.polarAxis.radiusAxis[radiusAxisId] != null) return state.polarAxis.radiusAxis[radiusAxisId];
	if (state.layout.layoutType === "radial") return implicitRadialBarRadiusAxis;
	return implicitRadiusAxis;
};
var selectPolarOptions = (state) => state.polarOptions;
var selectMaxRadius = createSelector([
	selectChartWidth,
	selectChartHeight,
	selectChartOffsetInternal
], getMaxRadius);
var selectInnerRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
	if (polarChartOptions == null) return;
	return getPercentValue(polarChartOptions.innerRadius, maxRadius, 0);
});
var selectOuterRadius = createSelector([selectPolarOptions, selectMaxRadius], (polarChartOptions, maxRadius) => {
	if (polarChartOptions == null) return;
	return getPercentValue(polarChartOptions.outerRadius, maxRadius, maxRadius * .8);
});
var combineAngleAxisRange = (polarOptions) => {
	if (polarOptions == null) return [0, 0];
	var { startAngle, endAngle } = polarOptions;
	return [startAngle, endAngle];
};
var selectAngleAxisRange = createSelector([selectPolarOptions], combineAngleAxisRange);
var selectAngleAxisRangeWithReversed = createSelector([selectAngleAxis, selectAngleAxisRange], combineAxisRangeWithReverse);
var selectRadiusAxisRange = createSelector([
	selectMaxRadius,
	selectInnerRadius,
	selectOuterRadius
], (maxRadius, innerRadius, outerRadius) => {
	if (maxRadius == null || innerRadius == null || outerRadius == null) return;
	return [innerRadius, outerRadius];
});
var selectRadiusAxisRangeWithReversed = createSelector([selectRadiusAxis, selectRadiusAxisRange], combineAxisRangeWithReverse);
var selectPolarViewBox = createSelector([
	selectChartLayout,
	selectPolarOptions,
	selectInnerRadius,
	selectOuterRadius,
	selectChartWidth,
	selectChartHeight
], (layout, polarOptions, innerRadius, outerRadius, width, height) => {
	if (layout !== "centric" && layout !== "radial" || polarOptions == null || innerRadius == null || outerRadius == null) return;
	var { cx, cy, startAngle, endAngle } = polarOptions;
	return {
		cx: getPercentValue(cx, width, width / 2),
		cy: getPercentValue(cy, height, height / 2),
		innerRadius,
		outerRadius,
		startAngle,
		endAngle,
		clockWise: false
	};
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/pickAxisType.js
var pickAxisType = (_state, axisType) => axisType;

//#endregion
//#region node_modules/recharts/es6/state/selectors/pickAxisId.js
var pickAxisId = (_state, _axisType, axisId) => axisId;

//#endregion
//#region node_modules/recharts/es6/util/stacks/getStackSeriesIdentifier.js
/**
* Returns identifier for stack series which is one individual graphical item in the stack.
* @param graphicalItem - The graphical item representing the series in the stack.
* @return The identifier for the series in the stack
*/
function getStackSeriesIdentifier(graphicalItem) {
	return graphicalItem === null || graphicalItem === void 0 ? void 0 : graphicalItem.id;
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipAxisType.js
var selectTooltipAxisType = (state) => {
	var layout = selectChartLayout(state);
	if (layout === "horizontal") return "xAxis";
	if (layout === "vertical") return "yAxis";
	if (layout === "centric") return "angleAxis";
	return "radiusAxis";
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipAxisId.js
var selectTooltipAxisId = (state) => state.tooltip.settings.axisId;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipAxis.js
var selectTooltipAxis = (state) => {
	var axisType = selectTooltipAxisType(state);
	var axisId = selectTooltipAxisId(state);
	return selectAxisSettings(state, axisType, axisId);
};
var selectTooltipAxisDataKey = createSelector([selectTooltipAxis], (axis) => axis === null || axis === void 0 ? void 0 : axis.dataKey);

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineDisplayedStackedData.js
/**
* In a stacked chart, each graphical item has its own data. That data could be either:
* - defined on the chart root, in which case the item gets a unique dataKey
* - or defined on the item itself, in which case multiple items can share the same dataKey
*
* That means we cannot use the dataKey as a unique identifier for the item.
*
* This type represents a single data point in a stacked chart, where each key is a series identifier
* and the value is the numeric value for that series using the numerical axis dataKey.
*/
function combineDisplayedStackedData(stackedGraphicalItems, _ref$1, tooltipAxisSettings) {
	var { chartData = [] } = _ref$1;
	var { allowDuplicatedCategory, dataKey: tooltipDataKey } = tooltipAxisSettings;
	var knownItemsByDataKey = /* @__PURE__ */ new Map();
	stackedGraphicalItems.forEach((item) => {
		var _item$data;
		var resolvedData = (_item$data = item.data) !== null && _item$data !== void 0 ? _item$data : chartData;
		if (resolvedData == null || resolvedData.length === 0) return;
		var stackIdentifier = getStackSeriesIdentifier(item);
		resolvedData.forEach((entry, index) => {
			var tooltipValue = tooltipDataKey == null || allowDuplicatedCategory ? index : String(getValueByDataKey(entry, tooltipDataKey, null));
			var numericValue = getValueByDataKey(entry, item.dataKey, 0);
			var curr;
			if (knownItemsByDataKey.has(tooltipValue)) curr = knownItemsByDataKey.get(tooltipValue);
			else curr = {};
			Object.assign(curr, { [stackIdentifier]: numericValue });
			knownItemsByDataKey.set(tooltipValue, curr);
		});
	});
	return Array.from(knownItemsByDataKey.values());
}

//#endregion
//#region node_modules/recharts/es6/state/types/StackedGraphicalItem.js
/**
* Some graphical items allow data stacking. The stacks are optional,
* so all props here are optional too.
*/
/**
* Some graphical items allow data stacking.
* This interface is used to represent the items that are stacked
* because the user has provided the stackId and dataKey properties.
*/
function isStacked(graphicalItem) {
	return graphicalItem.stackId != null && graphicalItem.dataKey != null;
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/numberDomainEqualityCheck.js
var numberDomainEqualityCheck = (a$1, b) => {
	if (a$1 === b) return true;
	if (a$1 == null || b == null) return false;
	return a$1[0] === b[0] && a$1[1] === b[1];
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/arrayEqualityCheck.js
function arrayEqualityCheck(a$1, b) {
	if (Array.isArray(a$1) && Array.isArray(b) && a$1.length === 0 && b.length === 0) return true;
	return a$1 === b;
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/axisSelectors.js
function ownKeys$45(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$45(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$45(Object(t), !0).forEach(function(r$2) {
			_defineProperty$47(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$45(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$47(e, r$1, t) {
	return (r$1 = _toPropertyKey$47(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$47(t) {
	var i = _toPrimitive$47(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$47(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var defaultNumericDomain = [0, "auto"];
/**
* angle, radius, X, Y, and Z axes all have domain and range and scale and associated settings
*/
/**
* X and Y axes have ticks. Z axis is never displayed and so it lacks ticks
* and tick settings.
*/
/**
* If an axis is not explicitly defined as an element,
* we still need to render something in the chart and we need
* some object to hold the domain and default settings.
*/
var implicitXAxis = {
	allowDataOverflow: false,
	allowDecimals: true,
	allowDuplicatedCategory: true,
	angle: 0,
	dataKey: void 0,
	domain: void 0,
	height: 30,
	hide: true,
	id: 0,
	includeHidden: false,
	interval: "preserveEnd",
	minTickGap: 5,
	mirror: false,
	name: void 0,
	orientation: "bottom",
	padding: {
		left: 0,
		right: 0
	},
	reversed: false,
	scale: "auto",
	tick: true,
	tickCount: 5,
	tickFormatter: void 0,
	ticks: void 0,
	type: "category",
	unit: void 0
};
var selectXAxisSettingsNoDefaults = (state, axisId) => {
	return state.cartesianAxis.xAxis[axisId];
};
var selectXAxisSettings = (state, axisId) => {
	var axis = selectXAxisSettingsNoDefaults(state, axisId);
	if (axis == null) return implicitXAxis;
	return axis;
};
/**
* If an axis is not explicitly defined as an element,
* we still need to render something in the chart and we need
* some object to hold the domain and default settings.
*/
var implicitYAxis = {
	allowDataOverflow: false,
	allowDecimals: true,
	allowDuplicatedCategory: true,
	angle: 0,
	dataKey: void 0,
	domain: defaultNumericDomain,
	hide: true,
	id: 0,
	includeHidden: false,
	interval: "preserveEnd",
	minTickGap: 5,
	mirror: false,
	name: void 0,
	orientation: "left",
	padding: {
		top: 0,
		bottom: 0
	},
	reversed: false,
	scale: "auto",
	tick: true,
	tickCount: 5,
	tickFormatter: void 0,
	ticks: void 0,
	type: "number",
	unit: void 0,
	width: DEFAULT_Y_AXIS_WIDTH
};
var selectYAxisSettingsNoDefaults = (state, axisId) => {
	return state.cartesianAxis.yAxis[axisId];
};
var selectYAxisSettings = (state, axisId) => {
	var axis = selectYAxisSettingsNoDefaults(state, axisId);
	if (axis == null) return implicitYAxis;
	return axis;
};
var implicitZAxis = {
	domain: [0, "auto"],
	includeHidden: false,
	reversed: false,
	allowDataOverflow: false,
	allowDuplicatedCategory: false,
	dataKey: void 0,
	id: 0,
	name: "",
	range: [64, 64],
	scale: "auto",
	type: "number",
	unit: ""
};
var selectZAxisSettings = (state, axisId) => {
	var axis = state.cartesianAxis.zAxis[axisId];
	if (axis == null) return implicitZAxis;
	return axis;
};
var selectBaseAxis = (state, axisType, axisId) => {
	switch (axisType) {
		case "xAxis": return selectXAxisSettings(state, axisId);
		case "yAxis": return selectYAxisSettings(state, axisId);
		case "zAxis": return selectZAxisSettings(state, axisId);
		case "angleAxis": return selectAngleAxis(state, axisId);
		case "radiusAxis": return selectRadiusAxis(state, axisId);
		default: throw new Error("Unexpected axis type: ".concat(axisType));
	}
};
var selectCartesianAxisSettings = (state, axisType, axisId) => {
	switch (axisType) {
		case "xAxis": return selectXAxisSettings(state, axisId);
		case "yAxis": return selectYAxisSettings(state, axisId);
		default: throw new Error("Unexpected axis type: ".concat(axisType));
	}
};
/**
* Selects either an X or Y axis. Doesn't work with Z axis - for that, instead use selectBaseAxis.
* @param state Root state
* @param axisType xAxis | yAxis
* @param axisId xAxisId | yAxisId
* @returns axis settings object
*/
var selectAxisSettings = (state, axisType, axisId) => {
	switch (axisType) {
		case "xAxis": return selectXAxisSettings(state, axisId);
		case "yAxis": return selectYAxisSettings(state, axisId);
		case "angleAxis": return selectAngleAxis(state, axisId);
		case "radiusAxis": return selectRadiusAxis(state, axisId);
		default: throw new Error("Unexpected axis type: ".concat(axisType));
	}
};
/**
* @param state RechartsRootState
* @return boolean true if there is at least one Bar or RadialBar
*/
var selectHasBar = (state) => state.graphicalItems.cartesianItems.some((item) => item.type === "bar") || state.graphicalItems.polarItems.some((item) => item.type === "radialBar");
/**
* Filters CartesianGraphicalItemSettings by the relevant axis ID
* @param axisType 'xAxis' | 'yAxis' | 'zAxis' | 'radiusAxis' | 'angleAxis'
* @param axisId from props, defaults to 0
*
* @returns Predicate function that return true for CartesianGraphicalItemSettings that are relevant to the specified axis
*/
function itemAxisPredicate(axisType, axisId) {
	return (item) => {
		switch (axisType) {
			case "xAxis": return "xAxisId" in item && item.xAxisId === axisId;
			case "yAxis": return "yAxisId" in item && item.yAxisId === axisId;
			case "zAxis": return "zAxisId" in item && item.zAxisId === axisId;
			case "angleAxis": return "angleAxisId" in item && item.angleAxisId === axisId;
			case "radiusAxis": return "radiusAxisId" in item && item.radiusAxisId === axisId;
			default: return false;
		}
	};
}
var selectUnfilteredCartesianItems = (state) => state.graphicalItems.cartesianItems;
var selectAxisPredicate$1 = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
var combineGraphicalItemsSettings = (graphicalItems, axisSettings, axisPredicate) => graphicalItems.filter(axisPredicate).filter((item) => {
	if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.includeHidden) === true) return true;
	return !item.hide;
});
var selectCartesianItemsSettings = createSelector([
	selectUnfilteredCartesianItems,
	selectBaseAxis,
	selectAxisPredicate$1
], combineGraphicalItemsSettings, { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck } });
var selectStackedCartesianItemsSettings = createSelector([selectCartesianItemsSettings], (cartesianItems) => {
	return cartesianItems.filter((item) => item.type === "area" || item.type === "bar").filter(isStacked);
});
var filterGraphicalNotStackedItems = (cartesianItems) => cartesianItems.filter((item) => !("stackId" in item) || item.stackId === void 0);
var selectCartesianItemsSettingsExceptStacked = createSelector([selectCartesianItemsSettings], filterGraphicalNotStackedItems);
var combineGraphicalItemsData = (cartesianItems) => cartesianItems.map((item) => item.data).filter(Boolean).flat(1);
/**
* This is a "cheap" selector - it returns the data but doesn't iterate them, so it is not sensitive on the array length.
* Also does not apply dataKey yet.
* @param state RechartsRootState
* @returns data defined on the chart graphical items, such as Line or Scatter or Pie, and filtered with appropriate dataKey
*/
var selectCartesianGraphicalItemsData = createSelector([selectCartesianItemsSettings], combineGraphicalItemsData, { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck } });
var combineDisplayedData = (graphicalItemsData, _ref$1) => {
	var { chartData = [], dataStartIndex, dataEndIndex } = _ref$1;
	if (graphicalItemsData.length > 0) return graphicalItemsData;
	return chartData.slice(dataStartIndex, dataEndIndex + 1);
};
/**
* This selector will return all data there is in the chart: graphical items, chart root, all together.
* Useful for figuring out an axis domain (because that needs to know of everything),
* not useful for rendering individual graphical elements (because they need to know which data is theirs and which is not).
*
* This function will discard the original indexes, so it is also not useful for anything that depends on ordering.
*/
var selectDisplayedData$1 = createSelector([selectCartesianGraphicalItemsData, selectChartDataWithIndexesIfNotInPanorama], combineDisplayedData);
var combineAppliedValues = (data, axisSettings, items) => {
	if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) return data.map((item) => ({ value: getValueByDataKey(item, axisSettings.dataKey) }));
	if (items.length > 0) return items.map((item) => item.dataKey).flatMap((dataKey) => data.map((entry) => ({ value: getValueByDataKey(entry, dataKey) })));
	return data.map((entry) => ({ value: entry }));
};
/**
* This selector will return all values with the appropriate dataKey applied on them.
* Which dataKey is appropriate depends on where it is defined.
*
* This is an expensive selector - it will iterate all data and compute their value using the provided dataKey.
*/
var selectAllAppliedValues = createSelector([
	selectDisplayedData$1,
	selectBaseAxis,
	selectCartesianItemsSettings
], combineAppliedValues);
function isErrorBarRelevantForAxisType(axisType, errorBar) {
	switch (axisType) {
		case "xAxis": return errorBar.direction === "x";
		case "yAxis": return errorBar.direction === "y";
		default: return false;
	}
}
function makeNumber(val) {
	if (isNumOrStr(val) || val instanceof Date) {
		var n = Number(val);
		if (isWellBehavedNumber(n)) return n;
	}
}
function makeDomain(val) {
	if (Array.isArray(val)) {
		var attempt = [makeNumber(val[0]), makeNumber(val[1])];
		if (isWellFormedNumberDomain(attempt)) return attempt;
		return;
	}
	var n = makeNumber(val);
	if (n == null) return;
	return [n, n];
}
function onlyAllowNumbers(data) {
	return data.map(makeNumber).filter(isNotNil);
}
/**
* @param entry One item in the 'data' array. Could be anything really - this is defined externally. This is the raw, before dataKey application
* @param appliedValue This is the result of applying the 'main' dataKey on the `entry`.
* @param relevantErrorBars Error bars that are relevant for the current axis and layout and all that.
* @return either undefined or an array of ErrorValue
*/
function getErrorDomainByDataKey(entry, appliedValue, relevantErrorBars) {
	if (!relevantErrorBars || typeof appliedValue !== "number" || isNan(appliedValue)) return [];
	if (!relevantErrorBars.length) return [];
	return onlyAllowNumbers(relevantErrorBars.flatMap((eb) => {
		var errorValue = getValueByDataKey(entry, eb.dataKey);
		var lowBound, highBound;
		if (Array.isArray(errorValue)) [lowBound, highBound] = errorValue;
		else lowBound = highBound = errorValue;
		if (!isWellBehavedNumber(lowBound) || !isWellBehavedNumber(highBound)) return;
		return [appliedValue - lowBound, appliedValue + highBound];
	}));
}
var selectDisplayedStackedData = createSelector([
	selectStackedCartesianItemsSettings,
	selectChartDataWithIndexesIfNotInPanorama,
	selectTooltipAxis
], combineDisplayedStackedData);
var combineStackGroups = (displayedData, items, stackOffsetType) => {
	var itemsGroup = items.reduce((acc, item) => {
		if (item.stackId == null) return acc;
		if (acc[item.stackId] == null) acc[item.stackId] = [];
		acc[item.stackId].push(item);
		return acc;
	}, {});
	return Object.fromEntries(Object.entries(itemsGroup).map((_ref2) => {
		var [stackId, graphicalItems] = _ref2;
		var dataKeys = graphicalItems.map(getStackSeriesIdentifier);
		return [stackId, {
			stackedData: getStackedData(displayedData, dataKeys, stackOffsetType),
			graphicalItems
		}];
	}));
};
/**
* Stack groups are groups of graphical items that stack on each other.
* Stack is a function of axis type (X, Y), axis ID, and stack ID.
* Graphical items that do not have a stack ID are not going to be present in stack groups.
*/
var selectStackGroups = createSelector([
	selectDisplayedStackedData,
	selectStackedCartesianItemsSettings,
	selectStackOffsetType
], combineStackGroups);
var combineDomainOfStackGroups = (stackGroups, _ref3, axisType, domainFromUserPreference) => {
	var { dataStartIndex, dataEndIndex } = _ref3;
	if (domainFromUserPreference != null) return;
	if (axisType === "zAxis") return;
	var domainOfStackGroups = getDomainOfStackGroups(stackGroups, dataStartIndex, dataEndIndex);
	if (domainOfStackGroups != null && domainOfStackGroups[0] === 0 && domainOfStackGroups[1] === 0) return;
	return domainOfStackGroups;
};
var selectAllowsDataOverflow = createSelector([selectBaseAxis], (axisSettings) => axisSettings.allowDataOverflow);
var getDomainDefinition = (axisSettings) => {
	var _axisSettings$domain;
	if (axisSettings == null || !("domain" in axisSettings)) return defaultNumericDomain;
	if (axisSettings.domain != null) return axisSettings.domain;
	if (axisSettings.ticks != null) {
		if (axisSettings.type === "number") {
			var allValues = onlyAllowNumbers(axisSettings.ticks);
			return [Math.min(...allValues), Math.max(...allValues)];
		}
		if (axisSettings.type === "category") return axisSettings.ticks.map(String);
	}
	return (_axisSettings$domain = axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.domain) !== null && _axisSettings$domain !== void 0 ? _axisSettings$domain : defaultNumericDomain;
};
var selectDomainDefinition = createSelector([selectBaseAxis], getDomainDefinition);
/**
* Under certain circumstances, we can determine the domain without looking at the data at all.
* This is the case when the domain is explicitly specified as numbers, or when it is specified
* as 'auto' or 'dataMin'/'dataMax' and data overflow is not allowed.
*
* In that case, this function will return the domain, otherwise it returns undefined.
*
* This is an optimization to avoid unnecessary data processing.
* @param state
* @param axisType
* @param axisId
* @param isPanorama
*/
var selectDomainFromUserPreference = createSelector([selectDomainDefinition, selectAllowsDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
var selectDomainOfStackGroups = createSelector([
	selectStackGroups,
	selectChartDataWithIndexes,
	pickAxisType,
	selectDomainFromUserPreference
], combineDomainOfStackGroups, { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck } });
var selectAllErrorBarSettings = (state) => state.errorBars;
var combineRelevantErrorBarSettings = (cartesianItemsSettings, allErrorBarSettings, axisType) => {
	return cartesianItemsSettings.flatMap((item) => {
		return allErrorBarSettings[item.id];
	}).filter(Boolean).filter((e) => {
		return isErrorBarRelevantForAxisType(axisType, e);
	});
};
var mergeDomains = function mergeDomains$1() {
	for (var _len = arguments.length, domains = new Array(_len), _key = 0; _key < _len; _key++) domains[_key] = arguments[_key];
	var allDomains = domains.filter(Boolean);
	if (allDomains.length === 0) return;
	var allValues = allDomains.flat();
	var min$1 = Math.min(...allValues);
	var max$1 = Math.max(...allValues);
	return [min$1, max$1];
};
var combineDomainOfAllAppliedNumericalValuesIncludingErrorValues = (data, axisSettings, items, errorBars, axisType) => {
	var lowerEnd, upperEnd;
	if (items.length > 0) data.forEach((entry) => {
		items.forEach((item) => {
			var _errorBars$item$id, _axisSettings$dataKey;
			var relevantErrorBars = (_errorBars$item$id = errorBars[item.id]) === null || _errorBars$item$id === void 0 ? void 0 : _errorBars$item$id.filter((errorBar) => isErrorBarRelevantForAxisType(axisType, errorBar));
			var valueByDataKey = getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey);
			var errorDomain = getErrorDomainByDataKey(entry, valueByDataKey, relevantErrorBars);
			if (errorDomain.length >= 2) {
				var localLower = Math.min(...errorDomain);
				var localUpper = Math.max(...errorDomain);
				if (lowerEnd == null || localLower < lowerEnd) lowerEnd = localLower;
				if (upperEnd == null || localUpper > upperEnd) upperEnd = localUpper;
			}
			var dataValueDomain = makeDomain(valueByDataKey);
			if (dataValueDomain != null) {
				lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
				upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
			}
		});
	});
	if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) data.forEach((item) => {
		var dataValueDomain = makeDomain(getValueByDataKey(item, axisSettings.dataKey));
		if (dataValueDomain != null) {
			lowerEnd = lowerEnd == null ? dataValueDomain[0] : Math.min(lowerEnd, dataValueDomain[0]);
			upperEnd = upperEnd == null ? dataValueDomain[1] : Math.max(upperEnd, dataValueDomain[1]);
		}
	});
	if (isWellBehavedNumber(lowerEnd) && isWellBehavedNumber(upperEnd)) return [lowerEnd, upperEnd];
};
var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1 = createSelector([
	selectDisplayedData$1,
	selectBaseAxis,
	selectCartesianItemsSettingsExceptStacked,
	selectAllErrorBarSettings,
	pickAxisType
], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck } });
function onlyAllowNumbersAndStringsAndDates(item) {
	var { value } = item;
	if (isNumOrStr(value) || value instanceof Date) return value;
}
var computeDomainOfTypeCategory = (allDataSquished, axisSettings, isCategorical) => {
	var categoricalDomain = allDataSquished.map(onlyAllowNumbersAndStringsAndDates).filter((v) => v != null);
	if (isCategorical && (axisSettings.dataKey == null || axisSettings.allowDuplicatedCategory && hasDuplicate(categoricalDomain))) return (0, import_range$1.default)(0, allDataSquished.length);
	if (axisSettings.allowDuplicatedCategory) return categoricalDomain;
	return Array.from(new Set(categoricalDomain));
};
var selectReferenceDots = (state) => state.referenceElements.dots;
var filterReferenceElements = (elements, axisType, axisId) => {
	return elements.filter((el) => el.ifOverflow === "extendDomain").filter((el) => {
		if (axisType === "xAxis") return el.xAxisId === axisId;
		return el.yAxisId === axisId;
	});
};
var selectReferenceDotsByAxis = createSelector([
	selectReferenceDots,
	pickAxisType,
	pickAxisId
], filterReferenceElements);
var selectReferenceAreas = (state) => state.referenceElements.areas;
var selectReferenceAreasByAxis = createSelector([
	selectReferenceAreas,
	pickAxisType,
	pickAxisId
], filterReferenceElements);
var selectReferenceLines = (state) => state.referenceElements.lines;
var selectReferenceLinesByAxis = createSelector([
	selectReferenceLines,
	pickAxisType,
	pickAxisId
], filterReferenceElements);
var combineDotsDomain = (dots, axisType) => {
	var allCoords = onlyAllowNumbers(dots.map((dot) => axisType === "xAxis" ? dot.x : dot.y));
	if (allCoords.length === 0) return;
	return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceDotsDomain = createSelector(selectReferenceDotsByAxis, pickAxisType, combineDotsDomain);
var combineAreasDomain = (areas, axisType) => {
	var allCoords = onlyAllowNumbers(areas.flatMap((area) => [axisType === "xAxis" ? area.x1 : area.y1, axisType === "xAxis" ? area.x2 : area.y2]));
	if (allCoords.length === 0) return;
	return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceAreasDomain = createSelector([selectReferenceAreasByAxis, pickAxisType], combineAreasDomain);
var combineLinesDomain = (lines, axisType) => {
	var allCoords = onlyAllowNumbers(lines.map((line) => axisType === "xAxis" ? line.x : line.y));
	if (allCoords.length === 0) return;
	return [Math.min(...allCoords), Math.max(...allCoords)];
};
var selectReferenceLinesDomain = createSelector(selectReferenceLinesByAxis, pickAxisType, combineLinesDomain);
var selectReferenceElementsDomain = createSelector(selectReferenceDotsDomain, selectReferenceLinesDomain, selectReferenceAreasDomain, (dotsDomain, linesDomain, areasDomain) => {
	return mergeDomains(dotsDomain, areasDomain, linesDomain);
});
var combineNumericalDomain = (axisSettings, domainDefinition, domainFromUserPreference, domainOfStackGroups, dataAndErrorBarsDomain, referenceElementsDomain, layout, axisType) => {
	if (domainFromUserPreference != null) return domainFromUserPreference;
	var mergedDomains = layout === "vertical" && axisType === "xAxis" || layout === "horizontal" && axisType === "yAxis" ? mergeDomains(domainOfStackGroups, referenceElementsDomain, dataAndErrorBarsDomain) : mergeDomains(referenceElementsDomain, dataAndErrorBarsDomain);
	return parseNumericalUserDomain(domainDefinition, mergedDomains, axisSettings.allowDataOverflow);
};
var selectNumericalDomain = createSelector([
	selectBaseAxis,
	selectDomainDefinition,
	selectDomainFromUserPreference,
	selectDomainOfStackGroups,
	selectDomainOfAllAppliedNumericalValuesIncludingErrorValues$1,
	selectReferenceElementsDomain,
	selectChartLayout,
	pickAxisType
], combineNumericalDomain, { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck } });
/**
* Expand by design maps everything between 0 and 1,
* there is nothing to compute.
* See https://d3js.org/d3-shape/stack#stack-offsets
*/
var expandDomain = [0, 1];
var combineAxisDomain = (axisSettings, layout, displayedData, allAppliedValues, stackOffsetType, axisType, numericalDomain) => {
	if ((axisSettings == null || displayedData == null || displayedData.length === 0) && numericalDomain === void 0) return;
	var { dataKey, type } = axisSettings;
	var isCategorical = isCategoricalAxis(layout, axisType);
	if (isCategorical && dataKey == null) return (0, import_range$1.default)(0, displayedData.length);
	if (type === "category") return computeDomainOfTypeCategory(allAppliedValues, axisSettings, isCategorical);
	if (stackOffsetType === "expand") return expandDomain;
	return numericalDomain;
};
var selectAxisDomain = createSelector([
	selectBaseAxis,
	selectChartLayout,
	selectDisplayedData$1,
	selectAllAppliedValues,
	selectStackOffsetType,
	pickAxisType,
	selectNumericalDomain
], combineAxisDomain);
var combineRealScaleType = (axisConfig, layout, hasBar, chartType, axisType) => {
	if (axisConfig == null) return;
	var { scale, type } = axisConfig;
	if (scale === "auto") {
		if (layout === "radial" && axisType === "radiusAxis") return "band";
		if (layout === "radial" && axisType === "angleAxis") return "linear";
		if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) return "point";
		if (type === "category") return "band";
		return "linear";
	}
	if (typeof scale === "string") {
		var name = "scale".concat(upperFirst(scale));
		return name in d3_scale_exports ? name : "point";
	}
};
var selectRealScaleType = createSelector([
	selectBaseAxis,
	selectChartLayout,
	selectHasBar,
	selectChartName,
	pickAxisType
], combineRealScaleType);
function getD3ScaleFromType(realScaleType) {
	if (realScaleType == null) return;
	if (realScaleType in d3_scale_exports) return d3_scale_exports[realScaleType]();
	var name = "scale".concat(upperFirst(realScaleType));
	if (name in d3_scale_exports) return d3_scale_exports[name]();
}
function combineScaleFunction(axis, realScaleType, axisDomain, axisRange) {
	if (axisDomain == null || axisRange == null) return;
	if (typeof axis.scale === "function") return axis.scale.copy().domain(axisDomain).range(axisRange);
	var d3ScaleFunction = getD3ScaleFromType(realScaleType);
	if (d3ScaleFunction == null) return;
	var scale = d3ScaleFunction.domain(axisDomain).range(axisRange);
	checkDomainOfScale(scale);
	return scale;
}
var combineNiceTicks = (axisDomain, axisSettings, realScaleType) => {
	var domainDefinition = getDomainDefinition(axisSettings);
	if (realScaleType !== "auto" && realScaleType !== "linear") return;
	if (axisSettings != null && axisSettings.tickCount && Array.isArray(domainDefinition) && (domainDefinition[0] === "auto" || domainDefinition[1] === "auto") && isWellFormedNumberDomain(axisDomain)) return getNiceTickValues(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
	if (axisSettings != null && axisSettings.tickCount && axisSettings.type === "number" && isWellFormedNumberDomain(axisDomain)) return getTickValuesFixedDomain(axisDomain, axisSettings.tickCount, axisSettings.allowDecimals);
};
var selectNiceTicks = createSelector([
	selectAxisDomain,
	selectAxisSettings,
	selectRealScaleType
], combineNiceTicks);
var combineAxisDomainWithNiceTicks = (axisSettings, domain, niceTicks, axisType) => {
	if (axisType !== "angleAxis" && (axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.type) === "number" && isWellFormedNumberDomain(domain) && Array.isArray(niceTicks) && niceTicks.length > 0) {
		var minFromDomain = domain[0];
		var minFromTicks = niceTicks[0];
		var maxFromDomain = domain[1];
		var maxFromTicks = niceTicks[niceTicks.length - 1];
		return [Math.min(minFromDomain, minFromTicks), Math.max(maxFromDomain, maxFromTicks)];
	}
	return domain;
};
var selectAxisDomainIncludingNiceTicks = createSelector([
	selectBaseAxis,
	selectAxisDomain,
	selectNiceTicks,
	pickAxisType
], combineAxisDomainWithNiceTicks);
/**
* Returns the smallest gap, between two numbers in the data, as a ratio of the whole range (max - min).
* Ignores domain provided by user and only considers domain from data.
*
* The result is a number between 0 and 1.
*/
var selectSmallestDistanceBetweenValues = createSelector(selectAllAppliedValues, selectBaseAxis, (allDataSquished, axisSettings) => {
	if (!axisSettings || axisSettings.type !== "number") return;
	var smallestDistanceBetweenValues = Infinity;
	var sortedValues = Array.from(onlyAllowNumbers(allDataSquished.map((d) => d.value))).sort((a$1, b) => a$1 - b);
	if (sortedValues.length < 2) return Infinity;
	var diff = sortedValues[sortedValues.length - 1] - sortedValues[0];
	if (diff === 0) return Infinity;
	for (var i = 0; i < sortedValues.length - 1; i++) {
		var distance = sortedValues[i + 1] - sortedValues[i];
		smallestDistanceBetweenValues = Math.min(smallestDistanceBetweenValues, distance);
	}
	return smallestDistanceBetweenValues / diff;
});
var selectCalculatedPadding = createSelector(selectSmallestDistanceBetweenValues, selectChartLayout, selectBarCategoryGap, selectChartOffsetInternal, (_1, _2, _3, padding) => padding, (smallestDistanceInPercent, layout, barCategoryGap, offset, padding) => {
	if (!isWellBehavedNumber(smallestDistanceInPercent)) return 0;
	var rangeWidth = layout === "vertical" ? offset.height : offset.width;
	if (padding === "gap") return smallestDistanceInPercent * rangeWidth / 2;
	if (padding === "no-gap") {
		var gap = getPercentValue(barCategoryGap, smallestDistanceInPercent * rangeWidth);
		var halfBand = smallestDistanceInPercent * rangeWidth / 2;
		return halfBand - gap - (halfBand - gap) / rangeWidth * gap;
	}
	return 0;
});
var selectCalculatedXAxisPadding = (state, axisId) => {
	var xAxisSettings = selectXAxisSettings(state, axisId);
	if (xAxisSettings == null || typeof xAxisSettings.padding !== "string") return 0;
	return selectCalculatedPadding(state, "xAxis", axisId, xAxisSettings.padding);
};
var selectCalculatedYAxisPadding = (state, axisId) => {
	var yAxisSettings = selectYAxisSettings(state, axisId);
	if (yAxisSettings == null || typeof yAxisSettings.padding !== "string") return 0;
	return selectCalculatedPadding(state, "yAxis", axisId, yAxisSettings.padding);
};
var selectXAxisPadding = createSelector(selectXAxisSettings, selectCalculatedXAxisPadding, (xAxisSettings, calculated) => {
	var _padding$left, _padding$right;
	if (xAxisSettings == null) return {
		left: 0,
		right: 0
	};
	var { padding } = xAxisSettings;
	if (typeof padding === "string") return {
		left: calculated,
		right: calculated
	};
	return {
		left: ((_padding$left = padding.left) !== null && _padding$left !== void 0 ? _padding$left : 0) + calculated,
		right: ((_padding$right = padding.right) !== null && _padding$right !== void 0 ? _padding$right : 0) + calculated
	};
});
var selectYAxisPadding = createSelector(selectYAxisSettings, selectCalculatedYAxisPadding, (yAxisSettings, calculated) => {
	var _padding$top, _padding$bottom;
	if (yAxisSettings == null) return {
		top: 0,
		bottom: 0
	};
	var { padding } = yAxisSettings;
	if (typeof padding === "string") return {
		top: calculated,
		bottom: calculated
	};
	return {
		top: ((_padding$top = padding.top) !== null && _padding$top !== void 0 ? _padding$top : 0) + calculated,
		bottom: ((_padding$bottom = padding.bottom) !== null && _padding$bottom !== void 0 ? _padding$bottom : 0) + calculated
	};
});
var combineXAxisRange = createSelector([
	selectChartOffsetInternal,
	selectXAxisPadding,
	selectBrushDimensions,
	selectBrushSettings,
	(_state, _axisId, isPanorama) => isPanorama
], (offset, padding, brushDimensions, _ref4, isPanorama) => {
	var { padding: brushPadding } = _ref4;
	if (isPanorama) return [brushPadding.left, brushDimensions.width - brushPadding.right];
	return [offset.left + padding.left, offset.left + offset.width - padding.right];
});
var combineYAxisRange = createSelector([
	selectChartOffsetInternal,
	selectChartLayout,
	selectYAxisPadding,
	selectBrushDimensions,
	selectBrushSettings,
	(_state, _axisId, isPanorama) => isPanorama
], (offset, layout, padding, brushDimensions, _ref5, isPanorama) => {
	var { padding: brushPadding } = _ref5;
	if (isPanorama) return [brushDimensions.height - brushPadding.bottom, brushPadding.top];
	if (layout === "horizontal") return [offset.top + offset.height - padding.bottom, offset.top + padding.top];
	return [offset.top + padding.top, offset.top + offset.height - padding.bottom];
});
var selectAxisRange = (state, axisType, axisId, isPanorama) => {
	var _selectZAxisSettings;
	switch (axisType) {
		case "xAxis": return combineXAxisRange(state, axisId, isPanorama);
		case "yAxis": return combineYAxisRange(state, axisId, isPanorama);
		case "zAxis": return (_selectZAxisSettings = selectZAxisSettings(state, axisId)) === null || _selectZAxisSettings === void 0 ? void 0 : _selectZAxisSettings.range;
		case "angleAxis": return selectAngleAxisRange(state);
		case "radiusAxis": return selectRadiusAxisRange(state, axisId);
		default: return;
	}
};
var selectAxisRangeWithReverse = createSelector([selectBaseAxis, selectAxisRange], combineAxisRangeWithReverse);
var selectAxisScale = createSelector([
	selectBaseAxis,
	selectRealScaleType,
	selectAxisDomainIncludingNiceTicks,
	selectAxisRangeWithReverse
], combineScaleFunction);
var selectErrorBarsSettings = createSelector([
	selectCartesianItemsSettings,
	selectAllErrorBarSettings,
	pickAxisType
], combineRelevantErrorBarSettings);
function compareIds(a$1, b) {
	if (a$1.id < b.id) return -1;
	if (a$1.id > b.id) return 1;
	return 0;
}
var pickAxisOrientation = (_state, orientation) => orientation;
var pickMirror = (_state, _orientation, mirror) => mirror;
var selectAllXAxesWithOffsetType = createSelector(selectAllXAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
var selectAllYAxesWithOffsetType = createSelector(selectAllYAxes, pickAxisOrientation, pickMirror, (allAxes, orientation, mirror) => allAxes.filter((axis) => axis.orientation === orientation).filter((axis) => axis.mirror === mirror).sort(compareIds));
var getXAxisSize = (offset, axisSettings) => {
	return {
		width: offset.width,
		height: axisSettings.height
	};
};
var getYAxisSize = (offset, axisSettings) => {
	return {
		width: typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH,
		height: offset.height
	};
};
var selectXAxisSize = createSelector(selectChartOffsetInternal, selectXAxisSettings, getXAxisSize);
var combineXAxisPositionStartingPoint = (offset, orientation, chartHeight) => {
	switch (orientation) {
		case "top": return offset.top;
		case "bottom": return chartHeight - offset.bottom;
		default: return 0;
	}
};
var combineYAxisPositionStartingPoint = (offset, orientation, chartWidth) => {
	switch (orientation) {
		case "left": return offset.left;
		case "right": return chartWidth - offset.right;
		default: return 0;
	}
};
var selectAllXAxesOffsetSteps = createSelector(selectChartHeight, selectChartOffsetInternal, selectAllXAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartHeight, offset, allAxesWithSameOffsetType, orientation, mirror) => {
	var steps = {};
	var position$1;
	allAxesWithSameOffsetType.forEach((axis) => {
		var axisSize = getXAxisSize(offset, axis);
		if (position$1 == null) position$1 = combineXAxisPositionStartingPoint(offset, orientation, chartHeight);
		var needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
		steps[axis.id] = position$1 - Number(needSpace) * axisSize.height;
		position$1 += (needSpace ? -1 : 1) * axisSize.height;
	});
	return steps;
});
var selectAllYAxesOffsetSteps = createSelector(selectChartWidth, selectChartOffsetInternal, selectAllYAxesWithOffsetType, pickAxisOrientation, pickMirror, (chartWidth, offset, allAxesWithSameOffsetType, orientation, mirror) => {
	var steps = {};
	var position$1;
	allAxesWithSameOffsetType.forEach((axis) => {
		var axisSize = getYAxisSize(offset, axis);
		if (position$1 == null) position$1 = combineYAxisPositionStartingPoint(offset, orientation, chartWidth);
		var needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
		steps[axis.id] = position$1 - Number(needSpace) * axisSize.width;
		position$1 += (needSpace ? -1 : 1) * axisSize.width;
	});
	return steps;
});
var selectXAxisOffsetSteps = (state, axisId) => {
	var axisSettings = selectXAxisSettings(state, axisId);
	if (axisSettings == null) return;
	return selectAllXAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
var selectXAxisPosition = createSelector([
	selectChartOffsetInternal,
	selectXAxisSettings,
	selectXAxisOffsetSteps,
	(_, axisId) => axisId
], (offset, axisSettings, allSteps, axisId) => {
	if (axisSettings == null) return;
	var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
	if (stepOfThisAxis == null) return {
		x: offset.left,
		y: 0
	};
	return {
		x: offset.left,
		y: stepOfThisAxis
	};
});
var selectYAxisOffsetSteps = (state, axisId) => {
	var axisSettings = selectYAxisSettings(state, axisId);
	if (axisSettings == null) return;
	return selectAllYAxesOffsetSteps(state, axisSettings.orientation, axisSettings.mirror);
};
var selectYAxisPosition = createSelector([
	selectChartOffsetInternal,
	selectYAxisSettings,
	selectYAxisOffsetSteps,
	(_, axisId) => axisId
], (offset, axisSettings, allSteps, axisId) => {
	if (axisSettings == null) return;
	var stepOfThisAxis = allSteps === null || allSteps === void 0 ? void 0 : allSteps[axisId];
	if (stepOfThisAxis == null) return {
		x: 0,
		y: offset.top
	};
	return {
		x: stepOfThisAxis,
		y: offset.top
	};
});
var selectYAxisSize = createSelector(selectChartOffsetInternal, selectYAxisSettings, (offset, axisSettings) => {
	return {
		width: typeof axisSettings.width === "number" ? axisSettings.width : DEFAULT_Y_AXIS_WIDTH,
		height: offset.height
	};
});
var selectCartesianAxisSize = (state, axisType, axisId) => {
	switch (axisType) {
		case "xAxis": return selectXAxisSize(state, axisId).width;
		case "yAxis": return selectYAxisSize(state, axisId).height;
		default: return;
	}
};
var combineDuplicateDomain = (chartLayout, appliedValues, axis, axisType) => {
	if (axis == null) return;
	var { allowDuplicatedCategory, type, dataKey } = axis;
	var isCategorical = isCategoricalAxis(chartLayout, axisType);
	var allData = appliedValues.map((av) => av.value);
	if (dataKey && isCategorical && type === "category" && allowDuplicatedCategory && hasDuplicate(allData)) return allData;
};
var selectDuplicateDomain = createSelector([
	selectChartLayout,
	selectAllAppliedValues,
	selectBaseAxis,
	pickAxisType
], combineDuplicateDomain);
var combineCategoricalDomain = (layout, appliedValues, axis, axisType) => {
	if (axis == null || axis.dataKey == null) return;
	var { type, scale } = axis;
	if (isCategoricalAxis(layout, axisType) && (type === "number" || scale !== "auto")) return appliedValues.map((d) => d.value);
};
var selectCategoricalDomain = createSelector([
	selectChartLayout,
	selectAllAppliedValues,
	selectAxisSettings,
	pickAxisType
], combineCategoricalDomain);
var selectAxisPropsNeededForCartesianGridTicksGenerator = createSelector([
	selectChartLayout,
	selectCartesianAxisSettings,
	selectRealScaleType,
	selectAxisScale,
	selectDuplicateDomain,
	selectCategoricalDomain,
	selectAxisRange,
	selectNiceTicks,
	pickAxisType
], (layout, axis, realScaleType, scale, duplicateDomain, categoricalDomain, axisRange, niceTicks, axisType) => {
	if (axis == null) return null;
	var isCategorical = isCategoricalAxis(layout, axisType);
	return {
		angle: axis.angle,
		interval: axis.interval,
		minTickGap: axis.minTickGap,
		orientation: axis.orientation,
		tick: axis.tick,
		tickCount: axis.tickCount,
		tickFormatter: axis.tickFormatter,
		ticks: axis.ticks,
		type: axis.type,
		unit: axis.unit,
		axisType,
		categoricalDomain,
		duplicateDomain,
		isCategorical,
		niceTicks,
		range: axisRange,
		realScaleType,
		scale
	};
});
var combineAxisTicks = (layout, axis, realScaleType, scale, niceTicks, axisRange, duplicateDomain, categoricalDomain, axisType) => {
	if (axis == null || scale == null) return;
	var isCategorical = isCategoricalAxis(layout, axisType);
	var { type, ticks: ticks$1, tickCount } = axis;
	var offsetForBand = realScaleType === "scaleBand" && typeof scale.bandwidth === "function" ? scale.bandwidth() / 2 : 2;
	var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
	offset = axisType === "angleAxis" && axisRange != null && axisRange.length >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
	var ticksOrNiceTicks = ticks$1 || niceTicks;
	if (ticksOrNiceTicks) return ticksOrNiceTicks.map((entry, index) => {
		var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
		return {
			index,
			coordinate: scale(scaleContent) + offset,
			value: entry,
			offset
		};
	}).filter((row) => !isNan(row.coordinate));
	if (isCategorical && categoricalDomain) return categoricalDomain.map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		index,
		offset
	}));
	if (scale.ticks) return scale.ticks(tickCount).map((entry) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		offset
	}));
	return scale.domain().map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: duplicateDomain ? duplicateDomain[entry] : entry,
		index,
		offset
	}));
};
var selectTicksOfAxis = createSelector([
	selectChartLayout,
	selectAxisSettings,
	selectRealScaleType,
	selectAxisScale,
	selectNiceTicks,
	selectAxisRange,
	selectDuplicateDomain,
	selectCategoricalDomain,
	pickAxisType
], combineAxisTicks);
var combineGraphicalItemTicks = (layout, axis, scale, axisRange, duplicateDomain, categoricalDomain, axisType) => {
	if (axis == null || scale == null || axisRange == null || axisRange[0] === axisRange[1]) return;
	var isCategorical = isCategoricalAxis(layout, axisType);
	var { tickCount } = axis;
	var offset = 0;
	offset = axisType === "angleAxis" && (axisRange === null || axisRange === void 0 ? void 0 : axisRange.length) >= 2 ? mathSign(axisRange[0] - axisRange[1]) * 2 * offset : offset;
	if (isCategorical && categoricalDomain) return categoricalDomain.map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		index,
		offset
	}));
	if (scale.ticks) return scale.ticks(tickCount).map((entry) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		offset
	}));
	return scale.domain().map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: duplicateDomain ? duplicateDomain[entry] : entry,
		index,
		offset
	}));
};
var selectTicksOfGraphicalItem = createSelector([
	selectChartLayout,
	selectAxisSettings,
	selectAxisScale,
	selectAxisRange,
	selectDuplicateDomain,
	selectCategoricalDomain,
	pickAxisType
], combineGraphicalItemTicks);
var selectAxisWithScale = createSelector(selectBaseAxis, selectAxisScale, (axis, scale) => {
	if (axis == null || scale == null) return;
	return _objectSpread$45(_objectSpread$45({}, axis), {}, { scale });
});
var selectZAxisScale = createSelector([
	selectBaseAxis,
	selectRealScaleType,
	selectAxisDomain,
	selectAxisRangeWithReverse
], combineScaleFunction);
var selectZAxisWithScale = createSelector((state, _axisType, axisId) => selectZAxisSettings(state, axisId), selectZAxisScale, (axis, scale) => {
	if (axis == null || scale == null) return;
	return _objectSpread$45(_objectSpread$45({}, axis), {}, { scale });
});
/**
* We are also going to need to implement polar chart directions if we want to support keyboard controls for those.
*/
var selectChartDirection = createSelector([
	selectChartLayout,
	selectAllXAxes,
	selectAllYAxes
], (layout, allXAxes, allYAxes) => {
	switch (layout) {
		case "horizontal": return allXAxes.some((axis) => axis.reversed) ? "right-to-left" : "left-to-right";
		case "vertical": return allYAxes.some((axis) => axis.reversed) ? "bottom-to-top" : "top-to-bottom";
		case "centric":
		case "radial": return "left-to-right";
		default: return;
	}
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipEventType.js
var selectDefaultTooltipEventType = (state) => state.options.defaultTooltipEventType;
var selectValidateTooltipEventTypes = (state) => state.options.validateTooltipEventTypes;
function combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes) {
	if (shared == null) return defaultTooltipEventType;
	var eventType = shared ? "axis" : "item";
	if (validateTooltipEventTypes == null) return defaultTooltipEventType;
	return validateTooltipEventTypes.includes(eventType) ? eventType : defaultTooltipEventType;
}
function selectTooltipEventType(state, shared) {
	var defaultTooltipEventType = selectDefaultTooltipEventType(state);
	var validateTooltipEventTypes = selectValidateTooltipEventTypes(state);
	return combineTooltipEventType(shared, defaultTooltipEventType, validateTooltipEventTypes);
}
function useTooltipEventType(shared) {
	return useAppSelector((state) => selectTooltipEventType(state, shared));
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineActiveLabel.js
var combineActiveLabel = (tooltipTicks, activeIndex) => {
	var _tooltipTicks$n;
	var n = Number(activeIndex);
	if (isNan(n) || activeIndex == null) return;
	return n >= 0 ? tooltipTicks === null || tooltipTicks === void 0 || (_tooltipTicks$n = tooltipTicks[n]) === null || _tooltipTicks$n === void 0 ? void 0 : _tooltipTicks$n.value : void 0;
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipSettings.js
var selectTooltipSettings = (state) => state.tooltip.settings;

//#endregion
//#region node_modules/recharts/es6/state/tooltipSlice.js
/**
* One Tooltip can display multiple TooltipPayloadEntries at a time.
*/
/**
* So what happens is that the tooltip payload is decided based on the available data, and the dataKey.
* The dataKey can either be defined on the graphical element (like Line, or Bar)
* or on the tooltip itself.
*
* The data can be defined in the chart element, or in the graphical item.
*
* So this type is all the settings, other than the data + dataKey complications.
*/
/**
* This is what Tooltip renders.
*/
/**
* null means no active index
* string means: whichever index from the chart data it is.
* Different charts have different requirements on data shapes,
* and are also responsible for providing a function that will accept this index
* and return data.
*/
/**
* Different items have different data shapes so the state has no opinion on what the data shape should be;
* the only requirement is that the chart also provides a searcher function
* that accepts the data, and a key, and returns whatever the payload in Tooltip should be.
*/
/**
* So this informs the "tooltip event type". Tooltip event type can be either "axis" or "item"
* and it is used for two things:
* 1. Sets the active area
* 2. Sets the background and cursor highlights
*
* Some charts only allow to have one type of tooltip event type, some allow both.
* Those charts that allow both will have one default, and the "shared" prop will be used to switch between them.
* Undefined means "use the chart default".
*
* Charts that only allow one tooltip event type, will ignore the shared prop.
*/
/**
* A generic state for user interaction with the chart.
* User interaction can come through multiple channels: mouse events, keyboard events, or hardcoded in props, or synchronised from other charts.
*
* Each of the interaction states is represented as TooltipInteractionState,
* and then the selectors and Tooltip will decide which of the interaction states to use.
*/
var noInteraction = {
	active: false,
	index: null,
	dataKey: void 0,
	coordinate: void 0
};
/**
* The tooltip interaction state stores:
*
* - Which graphical item is user interacting with at the moment,
* - which axis (or, which part of chart background) is user interacting with at the moment
* - The data that individual graphical items wish to be displayed in case the tooltip gets activated
*/
var initialState$3 = {
	itemInteraction: {
		click: noInteraction,
		hover: noInteraction
	},
	axisInteraction: {
		click: noInteraction,
		hover: noInteraction
	},
	keyboardInteraction: noInteraction,
	syncInteraction: {
		active: false,
		index: null,
		dataKey: void 0,
		label: void 0,
		coordinate: void 0,
		sourceViewBox: void 0
	},
	tooltipItemPayloads: [],
	settings: {
		shared: void 0,
		trigger: "hover",
		axisId: 0,
		active: false,
		defaultIndex: void 0
	}
};
var tooltipSlice = createSlice({
	name: "tooltip",
	initialState: initialState$3,
	reducers: {
		addTooltipEntrySettings: {
			reducer(state, action) {
				state.tooltipItemPayloads.push(castDraft(action.payload));
			},
			prepare: prepareAutoBatched()
		},
		removeTooltipEntrySettings: {
			reducer(state, action) {
				var index = current(state).tooltipItemPayloads.indexOf(castDraft(action.payload));
				if (index > -1) state.tooltipItemPayloads.splice(index, 1);
			},
			prepare: prepareAutoBatched()
		},
		setTooltipSettingsState(state, action) {
			state.settings = action.payload;
		},
		setActiveMouseOverItemIndex(state, action) {
			state.syncInteraction.active = false;
			state.keyboardInteraction.active = false;
			state.itemInteraction.hover.active = true;
			state.itemInteraction.hover.index = action.payload.activeIndex;
			state.itemInteraction.hover.dataKey = action.payload.activeDataKey;
			state.itemInteraction.hover.coordinate = action.payload.activeCoordinate;
		},
		mouseLeaveChart(state) {
			state.itemInteraction.hover.active = false;
			state.axisInteraction.hover.active = false;
		},
		mouseLeaveItem(state) {
			state.itemInteraction.hover.active = false;
		},
		setActiveClickItemIndex(state, action) {
			state.syncInteraction.active = false;
			state.itemInteraction.click.active = true;
			state.keyboardInteraction.active = false;
			state.itemInteraction.click.index = action.payload.activeIndex;
			state.itemInteraction.click.dataKey = action.payload.activeDataKey;
			state.itemInteraction.click.coordinate = action.payload.activeCoordinate;
		},
		setMouseOverAxisIndex(state, action) {
			state.syncInteraction.active = false;
			state.axisInteraction.hover.active = true;
			state.keyboardInteraction.active = false;
			state.axisInteraction.hover.index = action.payload.activeIndex;
			state.axisInteraction.hover.dataKey = action.payload.activeDataKey;
			state.axisInteraction.hover.coordinate = action.payload.activeCoordinate;
		},
		setMouseClickAxisIndex(state, action) {
			state.syncInteraction.active = false;
			state.keyboardInteraction.active = false;
			state.axisInteraction.click.active = true;
			state.axisInteraction.click.index = action.payload.activeIndex;
			state.axisInteraction.click.dataKey = action.payload.activeDataKey;
			state.axisInteraction.click.coordinate = action.payload.activeCoordinate;
		},
		setSyncInteraction(state, action) {
			state.syncInteraction = action.payload;
		},
		setKeyboardInteraction(state, action) {
			state.keyboardInteraction.active = action.payload.active;
			state.keyboardInteraction.index = action.payload.activeIndex;
			state.keyboardInteraction.coordinate = action.payload.activeCoordinate;
			state.keyboardInteraction.dataKey = action.payload.activeDataKey;
		}
	}
});
var { addTooltipEntrySettings, removeTooltipEntrySettings, setTooltipSettingsState, setActiveMouseOverItemIndex, mouseLeaveItem, mouseLeaveChart, setActiveClickItemIndex, setMouseOverAxisIndex, setMouseClickAxisIndex, setSyncInteraction, setKeyboardInteraction } = tooltipSlice.actions;
var tooltipReducer = tooltipSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineTooltipInteractionState.js
function ownKeys$44(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$44(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$44(Object(t), !0).forEach(function(r$2) {
			_defineProperty$46(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$44(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$46(e, r$1, t) {
	return (r$1 = _toPropertyKey$46(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$46(t) {
	var i = _toPrimitive$46(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$46(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger) {
	if (tooltipEventType === "axis") {
		if (trigger === "click") return tooltipState.axisInteraction.click;
		return tooltipState.axisInteraction.hover;
	}
	if (trigger === "click") return tooltipState.itemInteraction.click;
	return tooltipState.itemInteraction.hover;
}
function hasBeenActivePreviously(tooltipInteractionState) {
	return tooltipInteractionState.index != null;
}
var combineTooltipInteractionState = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
	if (tooltipEventType == null) return noInteraction;
	var appropriateMouseInteraction = chooseAppropriateMouseInteraction(tooltipState, tooltipEventType, trigger);
	if (appropriateMouseInteraction == null) return noInteraction;
	if (appropriateMouseInteraction.active) return appropriateMouseInteraction;
	if (tooltipState.keyboardInteraction.active) return tooltipState.keyboardInteraction;
	if (tooltipState.syncInteraction.active && tooltipState.syncInteraction.index != null) return tooltipState.syncInteraction;
	var activeFromProps = tooltipState.settings.active === true;
	if (hasBeenActivePreviously(appropriateMouseInteraction)) {
		if (activeFromProps) return _objectSpread$44(_objectSpread$44({}, appropriateMouseInteraction), {}, { active: true });
	} else if (defaultIndex != null) return {
		active: true,
		coordinate: void 0,
		dataKey: void 0,
		index: defaultIndex
	};
	return _objectSpread$44(_objectSpread$44({}, noInteraction), {}, { coordinate: appropriateMouseInteraction.coordinate });
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineActiveTooltipIndex.js
var combineActiveTooltipIndex = (tooltipInteraction, chartData) => {
	var desiredIndex = tooltipInteraction === null || tooltipInteraction === void 0 ? void 0 : tooltipInteraction.index;
	if (desiredIndex == null) return null;
	var indexAsNumber = Number(desiredIndex);
	if (!isWellBehavedNumber(indexAsNumber)) return desiredIndex;
	var lowerLimit = 0;
	var upperLimit = Infinity;
	if (chartData.length > 0) upperLimit = chartData.length - 1;
	return String(Math.max(lowerLimit, Math.min(indexAsNumber, upperLimit)));
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineCoordinateForDefaultIndex.js
var combineCoordinateForDefaultIndex = (width, height, layout, offset, tooltipTicks, defaultIndex, tooltipConfigurations, tooltipPayloadSearcher) => {
	if (defaultIndex == null || tooltipPayloadSearcher == null) return;
	var firstConfiguration = tooltipConfigurations[0];
	var maybePosition = firstConfiguration == null ? void 0 : tooltipPayloadSearcher(firstConfiguration.positions, defaultIndex);
	if (maybePosition != null) return maybePosition;
	var tick = tooltipTicks === null || tooltipTicks === void 0 ? void 0 : tooltipTicks[Number(defaultIndex)];
	if (!tick) return;
	switch (layout) {
		case "horizontal": return {
			x: tick.coordinate,
			y: (offset.top + height) / 2
		};
		default: return {
			x: (offset.left + width) / 2,
			y: tick.coordinate
		};
	}
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayloadConfigurations.js
var combineTooltipPayloadConfigurations = (tooltipState, tooltipEventType, trigger, defaultIndex) => {
	if (tooltipEventType === "axis") return tooltipState.tooltipItemPayloads;
	if (tooltipState.tooltipItemPayloads.length === 0) return [];
	var filterByDataKey;
	if (trigger === "hover") filterByDataKey = tooltipState.itemInteraction.hover.dataKey;
	else filterByDataKey = tooltipState.itemInteraction.click.dataKey;
	if (filterByDataKey == null && defaultIndex != null) return [tooltipState.tooltipItemPayloads[0]];
	return tooltipState.tooltipItemPayloads.filter((tpc) => {
		var _tpc$settings;
		return ((_tpc$settings = tpc.settings) === null || _tpc$settings === void 0 ? void 0 : _tpc$settings.dataKey) === filterByDataKey;
	});
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipPayloadSearcher.js
var selectTooltipPayloadSearcher = (state) => state.options.tooltipPayloadSearcher;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectTooltipState.js
var selectTooltipState = (state) => state.tooltip;

//#endregion
//#region node_modules/recharts/es6/state/selectors/combiners/combineTooltipPayload.js
function ownKeys$43(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$43(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$43(Object(t), !0).forEach(function(r$2) {
			_defineProperty$45(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$43(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$45(e, r$1, t) {
	return (r$1 = _toPropertyKey$45(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$45(t) {
	var i = _toPrimitive$45(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$45(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function selectFinalData(dataDefinedOnItem, dataDefinedOnChart) {
	if (dataDefinedOnItem != null) return dataDefinedOnItem;
	return dataDefinedOnChart;
}
var combineTooltipPayload = (tooltipPayloadConfigurations, activeIndex, chartDataState, tooltipAxisDataKey, activeLabel, tooltipPayloadSearcher, tooltipEventType) => {
	if (activeIndex == null || tooltipPayloadSearcher == null) return;
	var { chartData, computedData, dataStartIndex, dataEndIndex } = chartDataState;
	return tooltipPayloadConfigurations.reduce((agg, _ref$1) => {
		var _settings$dataKey;
		var { dataDefinedOnItem, settings } = _ref$1;
		var finalData = selectFinalData(dataDefinedOnItem, chartData);
		var sliced = Array.isArray(finalData) ? getSliced(finalData, dataStartIndex, dataEndIndex) : finalData;
		var finalDataKey = (_settings$dataKey = settings === null || settings === void 0 ? void 0 : settings.dataKey) !== null && _settings$dataKey !== void 0 ? _settings$dataKey : tooltipAxisDataKey;
		var finalNameKey = settings === null || settings === void 0 ? void 0 : settings.nameKey;
		var tooltipPayload;
		if (tooltipAxisDataKey && Array.isArray(sliced) && !Array.isArray(sliced[0]) && tooltipEventType === "axis") tooltipPayload = findEntryInArray(sliced, tooltipAxisDataKey, activeLabel);
		else tooltipPayload = tooltipPayloadSearcher(sliced, activeIndex, computedData, finalNameKey);
		if (Array.isArray(tooltipPayload)) tooltipPayload.forEach((item) => {
			var newSettings = _objectSpread$43(_objectSpread$43({}, settings), {}, {
				name: item.name,
				unit: item.unit,
				color: void 0,
				fill: void 0
			});
			agg.push(getTooltipEntry({
				tooltipEntrySettings: newSettings,
				dataKey: item.dataKey,
				payload: item.payload,
				value: getValueByDataKey(item.payload, item.dataKey),
				name: item.name
			}));
		});
		else {
			var _getValueByDataKey;
			agg.push(getTooltipEntry({
				tooltipEntrySettings: settings,
				dataKey: finalDataKey,
				payload: tooltipPayload,
				value: getValueByDataKey(tooltipPayload, finalDataKey),
				name: (_getValueByDataKey = getValueByDataKey(tooltipPayload, finalNameKey)) !== null && _getValueByDataKey !== void 0 ? _getValueByDataKey : settings === null || settings === void 0 ? void 0 : settings.name
			}));
		}
		return agg;
	}, []);
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/tooltipSelectors.js
var selectTooltipAxisRealScaleType = createSelector([
	selectTooltipAxis,
	selectChartLayout,
	selectHasBar,
	selectChartName,
	selectTooltipAxisType
], combineRealScaleType);
var selectAllUnfilteredGraphicalItems = createSelector([(state) => state.graphicalItems.cartesianItems, (state) => state.graphicalItems.polarItems], (cartesianItems, polarItems) => [...cartesianItems, ...polarItems]);
var selectTooltipAxisPredicate = createSelector([selectTooltipAxisType, selectTooltipAxisId], itemAxisPredicate);
var selectAllGraphicalItemsSettings = createSelector([
	selectAllUnfilteredGraphicalItems,
	selectTooltipAxis,
	selectTooltipAxisPredicate
], combineGraphicalItemsSettings, { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck } });
var selectAllStackedGraphicalItemsSettings = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
var selectTooltipGraphicalItemsData = createSelector([selectAllGraphicalItemsSettings], combineGraphicalItemsData, { memoizeOptions: { resultEqualityCheck: arrayEqualityCheck } });
/**
* Data for tooltip always use the data with indexes set by a Brush,
* and never accept the isPanorama flag:
* because Tooltip never displays inside the panorama anyway
* so we don't need to worry what would happen there.
*/
var selectTooltipDisplayedData = createSelector([selectTooltipGraphicalItemsData, selectChartDataWithIndexes], combineDisplayedData);
var selectTooltipStackedData = createSelector([
	selectAllStackedGraphicalItemsSettings,
	selectChartDataWithIndexes,
	selectTooltipAxis
], combineDisplayedStackedData);
var selectAllTooltipAppliedValues = createSelector([
	selectTooltipDisplayedData,
	selectTooltipAxis,
	selectAllGraphicalItemsSettings
], combineAppliedValues);
var selectTooltipAxisDomainDefinition = createSelector([selectTooltipAxis], getDomainDefinition);
var selectTooltipDataOverflow = createSelector([selectTooltipAxis], (axisSettings) => axisSettings.allowDataOverflow);
var selectTooltipDomainFromUserPreferences = createSelector([selectTooltipAxisDomainDefinition, selectTooltipDataOverflow], numericalDomainSpecifiedWithoutRequiringData);
var selectAllStackedGraphicalItems = createSelector([selectAllGraphicalItemsSettings], (graphicalItems) => graphicalItems.filter(isStacked));
var selectTooltipStackGroups = createSelector([
	selectTooltipStackedData,
	selectAllStackedGraphicalItems,
	selectStackOffsetType
], combineStackGroups);
var selectTooltipDomainOfStackGroups = createSelector([
	selectTooltipStackGroups,
	selectChartDataWithIndexes,
	selectTooltipAxisType,
	selectTooltipDomainFromUserPreferences
], combineDomainOfStackGroups);
var selectTooltipItemsSettingsExceptStacked = createSelector([selectAllGraphicalItemsSettings], filterGraphicalNotStackedItems);
var selectDomainOfAllAppliedNumericalValuesIncludingErrorValues = createSelector([
	selectTooltipDisplayedData,
	selectTooltipAxis,
	selectTooltipItemsSettingsExceptStacked,
	selectAllErrorBarSettings,
	selectTooltipAxisType
], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues, { memoizeOptions: { resultEqualityCheck: numberDomainEqualityCheck } });
var selectReferenceDotsByTooltipAxis = createSelector([
	selectReferenceDots,
	selectTooltipAxisType,
	selectTooltipAxisId
], filterReferenceElements);
var selectTooltipReferenceDotsDomain = createSelector([selectReferenceDotsByTooltipAxis, selectTooltipAxisType], combineDotsDomain);
var selectReferenceAreasByTooltipAxis = createSelector([
	selectReferenceAreas,
	selectTooltipAxisType,
	selectTooltipAxisId
], filterReferenceElements);
var selectTooltipReferenceAreasDomain = createSelector([selectReferenceAreasByTooltipAxis, selectTooltipAxisType], combineAreasDomain);
var selectReferenceLinesByTooltipAxis = createSelector([
	selectReferenceLines,
	selectTooltipAxisType,
	selectTooltipAxisId
], filterReferenceElements);
var selectTooltipReferenceLinesDomain = createSelector([selectReferenceLinesByTooltipAxis, selectTooltipAxisType], combineLinesDomain);
var selectTooltipReferenceElementsDomain = createSelector([
	selectTooltipReferenceDotsDomain,
	selectTooltipReferenceLinesDomain,
	selectTooltipReferenceAreasDomain
], mergeDomains);
var selectTooltipNumericalDomain = createSelector([
	selectTooltipAxis,
	selectTooltipAxisDomainDefinition,
	selectTooltipDomainFromUserPreferences,
	selectTooltipDomainOfStackGroups,
	selectDomainOfAllAppliedNumericalValuesIncludingErrorValues,
	selectTooltipReferenceElementsDomain,
	selectChartLayout,
	selectTooltipAxisType
], combineNumericalDomain);
var selectTooltipAxisDomain = createSelector([
	selectTooltipAxis,
	selectChartLayout,
	selectTooltipDisplayedData,
	selectAllTooltipAppliedValues,
	selectStackOffsetType,
	selectTooltipAxisType,
	selectTooltipNumericalDomain
], combineAxisDomain);
var selectTooltipNiceTicks = createSelector([
	selectTooltipAxisDomain,
	selectTooltipAxis,
	selectTooltipAxisRealScaleType
], combineNiceTicks);
var selectTooltipAxisDomainIncludingNiceTicks = createSelector([
	selectTooltipAxis,
	selectTooltipAxisDomain,
	selectTooltipNiceTicks,
	selectTooltipAxisType
], combineAxisDomainWithNiceTicks);
var selectTooltipAxisRange = (state) => {
	var axisType = selectTooltipAxisType(state);
	var axisId = selectTooltipAxisId(state);
	return selectAxisRange(state, axisType, axisId, false);
};
var selectTooltipAxisRangeWithReverse = createSelector([selectTooltipAxis, selectTooltipAxisRange], combineAxisRangeWithReverse);
var selectTooltipAxisScale = createSelector([
	selectTooltipAxis,
	selectTooltipAxisRealScaleType,
	selectTooltipAxisDomainIncludingNiceTicks,
	selectTooltipAxisRangeWithReverse
], combineScaleFunction);
var selectTooltipDuplicateDomain = createSelector([
	selectChartLayout,
	selectAllTooltipAppliedValues,
	selectTooltipAxis,
	selectTooltipAxisType
], combineDuplicateDomain);
var selectTooltipCategoricalDomain = createSelector([
	selectChartLayout,
	selectAllTooltipAppliedValues,
	selectTooltipAxis,
	selectTooltipAxisType
], combineCategoricalDomain);
var combineTicksOfTooltipAxis = (layout, axis, realScaleType, scale, range$5, duplicateDomain, categoricalDomain, axisType) => {
	if (!axis) return;
	var { type } = axis;
	var isCategorical = isCategoricalAxis(layout, axisType);
	if (!scale) return;
	var offsetForBand = realScaleType === "scaleBand" && scale.bandwidth ? scale.bandwidth() / 2 : 2;
	var offset = type === "category" && scale.bandwidth ? scale.bandwidth() / offsetForBand : 0;
	offset = axisType === "angleAxis" && range$5 != null && (range$5 === null || range$5 === void 0 ? void 0 : range$5.length) >= 2 ? mathSign(range$5[0] - range$5[1]) * 2 * offset : offset;
	if (isCategorical && categoricalDomain) return categoricalDomain.map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: entry,
		index,
		offset
	}));
	return scale.domain().map((entry, index) => ({
		coordinate: scale(entry) + offset,
		value: duplicateDomain ? duplicateDomain[entry] : entry,
		index,
		offset
	}));
};
var selectTooltipAxisTicks = createSelector([
	selectChartLayout,
	selectTooltipAxis,
	selectTooltipAxisRealScaleType,
	selectTooltipAxisScale,
	selectTooltipAxisRange,
	selectTooltipDuplicateDomain,
	selectTooltipCategoricalDomain,
	selectTooltipAxisType
], combineTicksOfTooltipAxis);
var selectTooltipEventType$1 = createSelector([
	selectDefaultTooltipEventType,
	selectValidateTooltipEventTypes,
	selectTooltipSettings
], (defaultTooltipEventType, validateTooltipEventType, settings) => combineTooltipEventType(settings.shared, defaultTooltipEventType, validateTooltipEventType));
var selectTooltipTrigger = (state) => state.tooltip.settings.trigger;
var selectDefaultIndex = (state) => state.tooltip.settings.defaultIndex;
var selectTooltipInteractionState$1 = createSelector([
	selectTooltipState,
	selectTooltipEventType$1,
	selectTooltipTrigger,
	selectDefaultIndex
], combineTooltipInteractionState);
var selectActiveTooltipIndex = createSelector([selectTooltipInteractionState$1, selectTooltipDisplayedData], combineActiveTooltipIndex);
var selectActiveLabel = createSelector([selectTooltipAxisTicks, selectActiveTooltipIndex], combineActiveLabel);
var selectActiveTooltipDataKey = createSelector([selectTooltipInteractionState$1], (tooltipInteraction) => {
	if (!tooltipInteraction) return;
	return tooltipInteraction.dataKey;
});
var selectTooltipPayloadConfigurations$1 = createSelector([
	selectTooltipState,
	selectTooltipEventType$1,
	selectTooltipTrigger,
	selectDefaultIndex
], combineTooltipPayloadConfigurations);
var selectTooltipCoordinateForDefaultIndex = createSelector([
	selectChartWidth,
	selectChartHeight,
	selectChartLayout,
	selectChartOffsetInternal,
	selectTooltipAxisTicks,
	selectDefaultIndex,
	selectTooltipPayloadConfigurations$1,
	selectTooltipPayloadSearcher
], combineCoordinateForDefaultIndex);
var selectActiveTooltipCoordinate = createSelector([selectTooltipInteractionState$1, selectTooltipCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
	if (tooltipInteractionState !== null && tooltipInteractionState !== void 0 && tooltipInteractionState.coordinate) return tooltipInteractionState.coordinate;
	return defaultIndexCoordinate;
});
var selectIsTooltipActive = createSelector([selectTooltipInteractionState$1], (tooltipInteractionState) => tooltipInteractionState.active);
var selectActiveTooltipPayload = createSelector([
	selectTooltipPayloadConfigurations$1,
	selectActiveTooltipIndex,
	selectChartDataWithIndexes,
	selectTooltipAxisDataKey,
	selectActiveLabel,
	selectTooltipPayloadSearcher,
	selectTooltipEventType$1
], combineTooltipPayload);
var selectActiveTooltipDataPoints = createSelector([selectActiveTooltipPayload], (payload) => {
	if (payload == null) return;
	var dataPoints = payload.map((p) => p.payload).filter((p) => p != null);
	return Array.from(new Set(dataPoints));
});

//#endregion
//#region node_modules/recharts/es6/context/useTooltipAxis.js
function ownKeys$42(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$42(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$42(Object(t), !0).forEach(function(r$2) {
			_defineProperty$44(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$42(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$44(e, r$1, t) {
	return (r$1 = _toPropertyKey$44(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$44(t) {
	var i = _toPrimitive$44(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$44(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var useTooltipAxis = () => useAppSelector(selectTooltipAxis);
var useTooltipAxisBandSize = () => {
	var tooltipAxis = useTooltipAxis();
	var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
	var tooltipAxisScale = useAppSelector(selectTooltipAxisScale);
	return getBandSizeOfAxis(_objectSpread$42(_objectSpread$42({}, tooltipAxis), {}, { scale: tooltipAxisScale }), tooltipTicks);
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectors.js
var import_sortBy = /* @__PURE__ */ __toESM(require_sortBy());
var useChartName = () => {
	return useAppSelector(selectChartName);
};
var pickTooltipEventType = (_state, tooltipEventType) => tooltipEventType;
var pickTrigger = (_state, _tooltipEventType, trigger) => trigger;
var pickDefaultIndex = (_state, _tooltipEventType, _trigger, defaultIndex) => defaultIndex;
var selectOrderedTooltipTicks = createSelector(selectTooltipAxisTicks, (ticks$1) => (0, import_sortBy.default)(ticks$1, (o) => o.coordinate));
var selectTooltipInteractionState = createSelector([
	selectTooltipState,
	pickTooltipEventType,
	pickTrigger,
	pickDefaultIndex
], combineTooltipInteractionState);
var selectActiveIndex = createSelector([selectTooltipInteractionState, selectTooltipDisplayedData], combineActiveTooltipIndex);
var selectTooltipDataKey = (state, tooltipEventType, trigger) => {
	if (tooltipEventType == null) return;
	var tooltipState = selectTooltipState(state);
	if (tooltipEventType === "axis") {
		if (trigger === "hover") return tooltipState.axisInteraction.hover.dataKey;
		return tooltipState.axisInteraction.click.dataKey;
	}
	if (trigger === "hover") return tooltipState.itemInteraction.hover.dataKey;
	return tooltipState.itemInteraction.click.dataKey;
};
var selectTooltipPayloadConfigurations = createSelector([
	selectTooltipState,
	pickTooltipEventType,
	pickTrigger,
	pickDefaultIndex
], combineTooltipPayloadConfigurations);
var selectCoordinateForDefaultIndex = createSelector([
	selectChartWidth,
	selectChartHeight,
	selectChartLayout,
	selectChartOffsetInternal,
	selectTooltipAxisTicks,
	pickDefaultIndex,
	selectTooltipPayloadConfigurations,
	selectTooltipPayloadSearcher
], combineCoordinateForDefaultIndex);
var selectActiveCoordinate = createSelector([selectTooltipInteractionState, selectCoordinateForDefaultIndex], (tooltipInteractionState, defaultIndexCoordinate) => {
	var _tooltipInteractionSt;
	return (_tooltipInteractionSt = tooltipInteractionState.coordinate) !== null && _tooltipInteractionSt !== void 0 ? _tooltipInteractionSt : defaultIndexCoordinate;
});
var selectActiveLabel$1 = createSelector(selectTooltipAxisTicks, selectActiveIndex, combineActiveLabel);
var selectTooltipPayload = createSelector([
	selectTooltipPayloadConfigurations,
	selectActiveIndex,
	selectChartDataWithIndexes,
	selectTooltipAxisDataKey,
	selectActiveLabel$1,
	selectTooltipPayloadSearcher,
	pickTooltipEventType
], combineTooltipPayload);
var selectIsTooltipActive$1 = createSelector([selectTooltipInteractionState], (tooltipInteractionState) => {
	return {
		isActive: tooltipInteractionState.active,
		activeIndex: tooltipInteractionState.index
	};
});
var combineActiveProps = (chartEvent, layout, polarViewBox, tooltipAxisType, tooltipAxisRange, tooltipTicks, orderedTooltipTicks, offset) => {
	if (!chartEvent || !layout || !tooltipAxisType || !tooltipAxisRange || !tooltipTicks) return;
	var rangeObj = inRange(chartEvent.chartX, chartEvent.chartY, layout, polarViewBox, offset);
	if (!rangeObj) return;
	var pos = calculateTooltipPos(rangeObj, layout);
	var activeIndex = calculateActiveTickIndex(pos, orderedTooltipTicks, tooltipTicks, tooltipAxisType, tooltipAxisRange);
	var activeCoordinate = getActiveCoordinate(layout, tooltipTicks, activeIndex, rangeObj);
	return {
		activeIndex: String(activeIndex),
		activeCoordinate
	};
};

//#endregion
//#region node_modules/recharts/es6/component/Cursor.js
function _extends$37() {
	return _extends$37 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$37.apply(null, arguments);
}
function ownKeys$41(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$41(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$41(Object(t), !0).forEach(function(r$2) {
			_defineProperty$43(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$41(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$43(e, r$1, t) {
	return (r$1 = _toPropertyKey$43(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$43(t) {
	var i = _toPrimitive$43(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$43(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* If set false, no cursor will be drawn when tooltip is active.
* If set an object, the option is the configuration of cursor.
* If set a React element, the option is the custom react element of drawing cursor
*/
function CursorInternal(props) {
	var { coordinate, payload, index, offset, tooltipAxisBandSize, layout, cursor, tooltipEventType, chartName } = props;
	var activeCoordinate = coordinate;
	var activePayload = payload;
	var activeTooltipIndex = index;
	if (!cursor || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") return null;
	var restProps, cursorComp;
	if (chartName === "ScatterChart") {
		restProps = activeCoordinate;
		cursorComp = Cross;
	} else if (chartName === "BarChart") {
		restProps = getCursorRectangle(layout, activeCoordinate, offset, tooltipAxisBandSize);
		cursorComp = Rectangle;
	} else if (layout === "radial") {
		var { cx, cy, radius, startAngle, endAngle } = getRadialCursorPoints(activeCoordinate);
		restProps = {
			cx,
			cy,
			startAngle,
			endAngle,
			innerRadius: radius,
			outerRadius: radius
		};
		cursorComp = Sector;
	} else {
		restProps = { points: getCursorPoints(layout, activeCoordinate, offset) };
		cursorComp = Curve;
	}
	var extraClassName = typeof cursor === "object" && "className" in cursor ? cursor.className : void 0;
	var cursorProps = _objectSpread$41(_objectSpread$41(_objectSpread$41(_objectSpread$41({
		stroke: "#ccc",
		pointerEvents: "none"
	}, offset), restProps), svgPropertiesNoEventsFromUnknown(cursor)), {}, {
		payload: activePayload,
		payloadIndex: activeTooltipIndex,
		className: clsx("recharts-tooltip-cursor", extraClassName)
	});
	if (/* @__PURE__ */ (0, import_react.isValidElement)(cursor)) return /* @__PURE__ */ (0, import_react.cloneElement)(cursor, cursorProps);
	return /* @__PURE__ */ (0, import_react.createElement)(cursorComp, cursorProps);
}
function Cursor(props) {
	var tooltipAxisBandSize = useTooltipAxisBandSize();
	var offset = useOffsetInternal();
	var layout = useChartLayout();
	var chartName = useChartName();
	return /* @__PURE__ */ import_react.createElement(CursorInternal, _extends$37({}, props, {
		coordinate: props.coordinate,
		index: props.index,
		payload: props.payload,
		offset,
		layout,
		tooltipAxisBandSize,
		chartName
	}));
}

//#endregion
//#region node_modules/recharts/es6/context/tooltipPortalContext.js
var TooltipPortalContext = /* @__PURE__ */ (0, import_react.createContext)(null);
var useTooltipPortal = () => (0, import_react.useContext)(TooltipPortalContext);

//#endregion
//#region node_modules/eventemitter3/index.js
var require_eventemitter3 = /* @__PURE__ */ __commonJS({ "node_modules/eventemitter3/index.js": ((exports, module) => {
	var has = Object.prototype.hasOwnProperty, prefix$1 = "~";
	/**
	* Constructor to create a storage for our `EE` objects.
	* An `Events` instance is a plain object whose properties are event names.
	*
	* @constructor
	* @private
	*/
	function Events() {}
	if (Object.create) {
		Events.prototype = Object.create(null);
		if (!new Events().__proto__) prefix$1 = false;
	}
	/**
	* Representation of a single event listener.
	*
	* @param {Function} fn The listener function.
	* @param {*} context The context to invoke the listener with.
	* @param {Boolean} [once=false] Specify if the listener is a one-time listener.
	* @constructor
	* @private
	*/
	function EE(fn, context, once) {
		this.fn = fn;
		this.context = context;
		this.once = once || false;
	}
	/**
	* Add a listener for a given event.
	*
	* @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} context The context to invoke the listener with.
	* @param {Boolean} once Specify if the listener is a one-time listener.
	* @returns {EventEmitter}
	* @private
	*/
	function addListener(emitter, event, fn, context, once) {
		if (typeof fn !== "function") throw new TypeError("The listener must be a function");
		var listener$1 = new EE(fn, context || emitter, once), evt = prefix$1 ? prefix$1 + event : event;
		if (!emitter._events[evt]) emitter._events[evt] = listener$1, emitter._eventsCount++;
		else if (!emitter._events[evt].fn) emitter._events[evt].push(listener$1);
		else emitter._events[evt] = [emitter._events[evt], listener$1];
		return emitter;
	}
	/**
	* Clear event by name.
	*
	* @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
	* @param {(String|Symbol)} evt The Event name.
	* @private
	*/
	function clearEvent(emitter, evt) {
		if (--emitter._eventsCount === 0) emitter._events = new Events();
		else delete emitter._events[evt];
	}
	/**
	* Minimal `EventEmitter` interface that is molded against the Node.js
	* `EventEmitter` interface.
	*
	* @constructor
	* @public
	*/
	function EventEmitter$1() {
		this._events = new Events();
		this._eventsCount = 0;
	}
	/**
	* Return an array listing the events for which the emitter has registered
	* listeners.
	*
	* @returns {Array}
	* @public
	*/
	EventEmitter$1.prototype.eventNames = function eventNames() {
		var names = [], events, name;
		if (this._eventsCount === 0) return names;
		for (name in events = this._events) if (has.call(events, name)) names.push(prefix$1 ? name.slice(1) : name);
		if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
		return names;
	};
	/**
	* Return the listeners registered for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Array} The registered listeners.
	* @public
	*/
	EventEmitter$1.prototype.listeners = function listeners(event) {
		var evt = prefix$1 ? prefix$1 + event : event, handlers = this._events[evt];
		if (!handlers) return [];
		if (handlers.fn) return [handlers.fn];
		for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) ee[i] = handlers[i].fn;
		return ee;
	};
	/**
	* Return the number of listeners listening to a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Number} The number of listeners.
	* @public
	*/
	EventEmitter$1.prototype.listenerCount = function listenerCount(event) {
		var evt = prefix$1 ? prefix$1 + event : event, listeners = this._events[evt];
		if (!listeners) return 0;
		if (listeners.fn) return 1;
		return listeners.length;
	};
	/**
	* Calls each of the listeners registered for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @returns {Boolean} `true` if the event had listeners, else `false`.
	* @public
	*/
	EventEmitter$1.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
		var evt = prefix$1 ? prefix$1 + event : event;
		if (!this._events[evt]) return false;
		var listeners = this._events[evt], len = arguments.length, args, i;
		if (listeners.fn) {
			if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
			switch (len) {
				case 1: return listeners.fn.call(listeners.context), true;
				case 2: return listeners.fn.call(listeners.context, a1), true;
				case 3: return listeners.fn.call(listeners.context, a1, a2), true;
				case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
				case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
				case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
			}
			for (i = 1, args = new Array(len - 1); i < len; i++) args[i - 1] = arguments[i];
			listeners.fn.apply(listeners.context, args);
		} else {
			var length = listeners.length, j;
			for (i = 0; i < length; i++) {
				if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
				switch (len) {
					case 1:
						listeners[i].fn.call(listeners[i].context);
						break;
					case 2:
						listeners[i].fn.call(listeners[i].context, a1);
						break;
					case 3:
						listeners[i].fn.call(listeners[i].context, a1, a2);
						break;
					case 4:
						listeners[i].fn.call(listeners[i].context, a1, a2, a3);
						break;
					default:
						if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) args[j - 1] = arguments[j];
						listeners[i].fn.apply(listeners[i].context, args);
				}
			}
		}
		return true;
	};
	/**
	* Add a listener for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} [context=this] The context to invoke the listener with.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$1.prototype.on = function on(event, fn, context) {
		return addListener(this, event, fn, context, false);
	};
	/**
	* Add a one-time listener for a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn The listener function.
	* @param {*} [context=this] The context to invoke the listener with.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$1.prototype.once = function once(event, fn, context) {
		return addListener(this, event, fn, context, true);
	};
	/**
	* Remove the listeners of a given event.
	*
	* @param {(String|Symbol)} event The event name.
	* @param {Function} fn Only remove the listeners that match this function.
	* @param {*} context Only remove the listeners that have this context.
	* @param {Boolean} once Only remove one-time listeners.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$1.prototype.removeListener = function removeListener$1(event, fn, context, once) {
		var evt = prefix$1 ? prefix$1 + event : event;
		if (!this._events[evt]) return this;
		if (!fn) {
			clearEvent(this, evt);
			return this;
		}
		var listeners = this._events[evt];
		if (listeners.fn) {
			if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
		} else {
			for (var i = 0, events = [], length = listeners.length; i < length; i++) if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
			if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
			else clearEvent(this, evt);
		}
		return this;
	};
	/**
	* Remove all listeners, or those of the specified event.
	*
	* @param {(String|Symbol)} [event] The event name.
	* @returns {EventEmitter} `this`.
	* @public
	*/
	EventEmitter$1.prototype.removeAllListeners = function removeAllListeners(event) {
		var evt;
		if (event) {
			evt = prefix$1 ? prefix$1 + event : event;
			if (this._events[evt]) clearEvent(this, evt);
		} else {
			this._events = new Events();
			this._eventsCount = 0;
		}
		return this;
	};
	EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
	EventEmitter$1.prototype.addListener = EventEmitter$1.prototype.on;
	EventEmitter$1.prefixed = prefix$1;
	EventEmitter$1.EventEmitter = EventEmitter$1;
	if ("undefined" !== typeof module) module.exports = EventEmitter$1;
}) });

//#endregion
//#region node_modules/eventemitter3/index.mjs
var import_eventemitter3 = /* @__PURE__ */ __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_eventemitter3.default;

//#endregion
//#region node_modules/recharts/es6/util/Events.js
var eventCenter = new eventemitter3_default();
var TOOLTIP_SYNC_EVENT = "recharts.syncEvent.tooltip";
var BRUSH_SYNC_EVENT = "recharts.syncEvent.brush";

//#endregion
//#region node_modules/recharts/es6/state/optionsSlice.js
/**
* These chart options are decided internally, by Recharts,
* and will not change during the lifetime of the chart.
*
* Changing these options can be done by swapping the root element
* which will make a brand-new Redux store.
*
* If you want to store options that can be changed by the user,
* use UpdatableChartOptions in rootPropsSlice.ts.
*/
function arrayTooltipSearcher(data, strIndex) {
	if (!strIndex) return void 0;
	var numIndex = Number.parseInt(strIndex, 10);
	if (isNan(numIndex)) return;
	return data === null || data === void 0 ? void 0 : data[numIndex];
}
var optionsSlice = createSlice({
	name: "options",
	initialState: {
		chartName: "",
		tooltipPayloadSearcher: void 0,
		eventEmitter: void 0,
		defaultTooltipEventType: "axis"
	},
	reducers: { createEventEmitter: (state) => {
		if (state.eventEmitter == null) state.eventEmitter = Symbol("rechartsEventEmitter");
	} }
});
var optionsReducer = optionsSlice.reducer;
var { createEventEmitter } = optionsSlice.actions;

//#endregion
//#region node_modules/recharts/es6/synchronisation/syncSelectors.js
function selectSynchronisedTooltipState(state) {
	return state.tooltip.syncInteraction;
}

//#endregion
//#region node_modules/recharts/es6/state/chartDataSlice.js
/**
* This is the data that's coming through main chart `data` prop
* Recharts is very flexible in what it accepts so the type is very flexible too.
* This will typically be an object, and various components will provide various `dataKey`
* that dictates how to pull data from that object.
*
* TL;DR: before dataKey
*/
/**
* So this is the same unknown type as ChartData but this is after the dataKey has been applied.
* We still don't know what the type is - that depends on what exactly it was before the dataKey application,
* and the dataKey can return whatever anyway - but let's keep it separate as a form of documentation.
*
* TL;DR: ChartData after dataKey.
*/
var initialChartDataState = {
	chartData: void 0,
	computedData: void 0,
	dataStartIndex: 0,
	dataEndIndex: 0
};
var chartDataSlice = createSlice({
	name: "chartData",
	initialState: initialChartDataState,
	reducers: {
		setChartData(state, action) {
			state.chartData = action.payload;
			if (action.payload == null) {
				state.dataStartIndex = 0;
				state.dataEndIndex = 0;
				return;
			}
			if (action.payload.length > 0 && state.dataEndIndex !== action.payload.length - 1) state.dataEndIndex = action.payload.length - 1;
		},
		setComputedData(state, action) {
			state.computedData = action.payload;
		},
		setDataStartEndIndexes(state, action) {
			var { startIndex, endIndex } = action.payload;
			if (startIndex != null) state.dataStartIndex = startIndex;
			if (endIndex != null) state.dataEndIndex = endIndex;
		}
	}
});
var { setChartData, setDataStartEndIndexes, setComputedData } = chartDataSlice.actions;
var chartDataReducer = chartDataSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/synchronisation/useChartSynchronisation.js
var _excluded$30 = ["x", "y"];
function ownKeys$40(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$40(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$40(Object(t), !0).forEach(function(r$2) {
			_defineProperty$42(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$40(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$42(e, r$1, t) {
	return (r$1 = _toPropertyKey$42(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$42(t) {
	var i = _toPrimitive$42(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$42(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$30(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$30(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$30(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var noop$2 = () => {};
function useTooltipSyncEventsListener() {
	var mySyncId = useAppSelector(selectSyncId);
	var myEventEmitter = useAppSelector(selectEventEmitter);
	var dispatch = useAppDispatch();
	var syncMethod = useAppSelector(selectSyncMethod);
	var tooltipTicks = useAppSelector(selectTooltipAxisTicks);
	var layout = useChartLayout();
	var viewBox = useViewBox();
	var className = useAppSelector((state) => state.rootProps.className);
	(0, import_react.useEffect)(() => {
		if (mySyncId == null) return noop$2;
		var listener$1 = (incomingSyncId, action, emitter) => {
			if (myEventEmitter === emitter) return;
			if (mySyncId !== incomingSyncId) return;
			if (syncMethod === "index") {
				var _action$payload;
				if (viewBox && action !== null && action !== void 0 && (_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.coordinate && action.payload.sourceViewBox) {
					var _action$payload$coord = action.payload.coordinate, { x: _x, y: _y } = _action$payload$coord, otherCoordinateProps = _objectWithoutProperties$30(_action$payload$coord, _excluded$30);
					var { x: sourceX, y: sourceY, width: sourceWidth, height: sourceHeight } = action.payload.sourceViewBox;
					var scaledCoordinate = _objectSpread$40(_objectSpread$40({}, otherCoordinateProps), {}, {
						x: viewBox.x + (sourceWidth ? (_x - sourceX) / sourceWidth : 0) * viewBox.width,
						y: viewBox.y + (sourceHeight ? (_y - sourceY) / sourceHeight : 0) * viewBox.height
					});
					dispatch(_objectSpread$40(_objectSpread$40({}, action), {}, { payload: _objectSpread$40(_objectSpread$40({}, action.payload), {}, { coordinate: scaledCoordinate }) }));
				} else dispatch(action);
				return;
			}
			if (tooltipTicks == null) return;
			var activeTick;
			if (typeof syncMethod === "function") {
				var syncMethodParam = {
					activeTooltipIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
					isTooltipActive: action.payload.active,
					activeIndex: action.payload.index == null ? void 0 : Number(action.payload.index),
					activeLabel: action.payload.label,
					activeDataKey: action.payload.dataKey,
					activeCoordinate: action.payload.coordinate
				};
				var activeTooltipIndex = syncMethod(tooltipTicks, syncMethodParam);
				activeTick = tooltipTicks[activeTooltipIndex];
			} else if (syncMethod === "value") activeTick = tooltipTicks.find((tick) => String(tick.value) === action.payload.label);
			var { coordinate } = action.payload;
			if (activeTick == null || action.payload.active === false || coordinate == null || viewBox == null) {
				dispatch(setSyncInteraction({
					active: false,
					coordinate: void 0,
					dataKey: void 0,
					index: null,
					label: void 0,
					sourceViewBox: void 0
				}));
				return;
			}
			var { x: x$1, y: y$1 } = coordinate;
			var validateChartX = Math.min(x$1, viewBox.x + viewBox.width);
			var validateChartY = Math.min(y$1, viewBox.y + viewBox.height);
			var activeCoordinate = {
				x: layout === "horizontal" ? activeTick.coordinate : validateChartX,
				y: layout === "horizontal" ? validateChartY : activeTick.coordinate
			};
			var syncAction = setSyncInteraction({
				active: action.payload.active,
				coordinate: activeCoordinate,
				dataKey: action.payload.dataKey,
				index: String(activeTick.index),
				label: action.payload.label,
				sourceViewBox: action.payload.sourceViewBox
			});
			dispatch(syncAction);
		};
		eventCenter.on(TOOLTIP_SYNC_EVENT, listener$1);
		return () => {
			eventCenter.off(TOOLTIP_SYNC_EVENT, listener$1);
		};
	}, [
		className,
		dispatch,
		myEventEmitter,
		mySyncId,
		syncMethod,
		tooltipTicks,
		layout,
		viewBox
	]);
}
function useBrushSyncEventsListener() {
	var mySyncId = useAppSelector(selectSyncId);
	var myEventEmitter = useAppSelector(selectEventEmitter);
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		if (mySyncId == null) return noop$2;
		var listener$1 = (incomingSyncId, action, emitter) => {
			if (myEventEmitter === emitter) return;
			if (mySyncId === incomingSyncId) dispatch(setDataStartEndIndexes(action));
		};
		eventCenter.on(BRUSH_SYNC_EVENT, listener$1);
		return () => {
			eventCenter.off(BRUSH_SYNC_EVENT, listener$1);
		};
	}, [
		dispatch,
		myEventEmitter,
		mySyncId
	]);
}
/**
* Will receive synchronisation events from other charts.
*
* Reads syncMethod from state and decides how to synchronise the tooltip based on that.
*
* @returns void
*/
function useSynchronisedEventsFromOtherCharts() {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(createEventEmitter());
	}, [dispatch]);
	useTooltipSyncEventsListener();
	useBrushSyncEventsListener();
}
/**
* Will send events to other charts.
* If syncId is undefined, no events will be sent.
*
* This ignores the syncMethod, because that is set and computed on the receiving end.
*
* @param tooltipEventType from Tooltip
* @param trigger from Tooltip
* @param activeCoordinate from state
* @param activeLabel from state
* @param activeIndex from state
* @param isTooltipActive from state
* @returns void
*/
function useTooltipChartSynchronisation(tooltipEventType, trigger, activeCoordinate, activeLabel, activeIndex, isTooltipActive) {
	var activeDataKey = useAppSelector((state) => selectTooltipDataKey(state, tooltipEventType, trigger));
	var eventEmitterSymbol = useAppSelector(selectEventEmitter);
	var syncId = useAppSelector(selectSyncId);
	var syncMethod = useAppSelector(selectSyncMethod);
	var tooltipState = useAppSelector(selectSynchronisedTooltipState);
	var isReceivingSynchronisation = tooltipState === null || tooltipState === void 0 ? void 0 : tooltipState.active;
	var viewBox = useViewBox();
	(0, import_react.useEffect)(() => {
		if (isReceivingSynchronisation) return;
		if (syncId == null) return;
		if (eventEmitterSymbol == null) return;
		var syncAction = setSyncInteraction({
			active: isTooltipActive,
			coordinate: activeCoordinate,
			dataKey: activeDataKey,
			index: activeIndex,
			label: typeof activeLabel === "number" ? String(activeLabel) : activeLabel,
			sourceViewBox: viewBox
		});
		eventCenter.emit(TOOLTIP_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
	}, [
		isReceivingSynchronisation,
		activeCoordinate,
		activeDataKey,
		activeIndex,
		activeLabel,
		eventEmitterSymbol,
		syncId,
		syncMethod,
		isTooltipActive,
		viewBox
	]);
}
function useBrushChartSynchronisation() {
	var syncId = useAppSelector(selectSyncId);
	var eventEmitterSymbol = useAppSelector(selectEventEmitter);
	var brushStartIndex = useAppSelector((state) => state.chartData.dataStartIndex);
	var brushEndIndex = useAppSelector((state) => state.chartData.dataEndIndex);
	(0, import_react.useEffect)(() => {
		if (syncId == null || brushStartIndex == null || brushEndIndex == null || eventEmitterSymbol == null) return;
		var syncAction = {
			startIndex: brushStartIndex,
			endIndex: brushEndIndex
		};
		eventCenter.emit(BRUSH_SYNC_EVENT, syncId, syncAction, eventEmitterSymbol);
	}, [
		brushEndIndex,
		brushStartIndex,
		eventEmitterSymbol,
		syncId
	]);
}

//#endregion
//#region node_modules/recharts/es6/component/Tooltip.js
var import_react_dom = /* @__PURE__ */ __toESM(require_react_dom());
function ownKeys$39(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$39(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$39(Object(t), !0).forEach(function(r$2) {
			_defineProperty$41(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$39(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$41(e, r$1, t) {
	return (r$1 = _toPropertyKey$41(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$41(t) {
	var i = _toPrimitive$41(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$41(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function defaultUniqBy(entry) {
	return entry.dataKey;
}
function renderContent(content, props) {
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.cloneElement(content, props);
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(content, props);
	return /* @__PURE__ */ import_react.createElement(DefaultTooltipContent, props);
}
var emptyPayload = [];
var defaultTooltipProps = {
	allowEscapeViewBox: {
		x: false,
		y: false
	},
	animationDuration: 400,
	animationEasing: "ease",
	axisId: 0,
	contentStyle: {},
	cursor: true,
	filterNull: true,
	isAnimationActive: !Global.isSsr,
	itemSorter: "name",
	itemStyle: {},
	labelStyle: {},
	offset: 10,
	reverseDirection: {
		x: false,
		y: false
	},
	separator: " : ",
	trigger: "hover",
	useTranslate3d: false,
	wrapperStyle: {}
};
function Tooltip(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultTooltipProps);
	var { active: activeFromProps, allowEscapeViewBox, animationDuration, animationEasing, content, filterNull, isAnimationActive, offset, payloadUniqBy, position: position$1, reverseDirection, useTranslate3d, wrapperStyle, cursor, shared, trigger, defaultIndex, portal: portalFromProps, axisId } = props;
	var dispatch = useAppDispatch();
	var defaultIndexAsString = typeof defaultIndex === "number" ? String(defaultIndex) : defaultIndex;
	(0, import_react.useEffect)(() => {
		dispatch(setTooltipSettingsState({
			shared,
			trigger,
			axisId,
			active: activeFromProps,
			defaultIndex: defaultIndexAsString
		}));
	}, [
		dispatch,
		shared,
		trigger,
		axisId,
		activeFromProps,
		defaultIndexAsString
	]);
	var viewBox = useViewBox();
	var accessibilityLayer = useAccessibilityLayer();
	var tooltipEventType = useTooltipEventType(shared);
	var { activeIndex, isActive } = useAppSelector((state) => selectIsTooltipActive$1(state, tooltipEventType, trigger, defaultIndexAsString));
	var payloadFromRedux = useAppSelector((state) => selectTooltipPayload(state, tooltipEventType, trigger, defaultIndexAsString));
	var labelFromRedux = useAppSelector((state) => selectActiveLabel$1(state, tooltipEventType, trigger, defaultIndexAsString));
	var coordinate = useAppSelector((state) => selectActiveCoordinate(state, tooltipEventType, trigger, defaultIndexAsString));
	var payload = payloadFromRedux;
	var tooltipPortalFromContext = useTooltipPortal();
	var finalIsActive = activeFromProps !== null && activeFromProps !== void 0 ? activeFromProps : isActive;
	var [lastBoundingBox, updateBoundingBox] = useElementOffset([payload, finalIsActive]);
	var finalLabel = tooltipEventType === "axis" ? labelFromRedux : void 0;
	useTooltipChartSynchronisation(tooltipEventType, trigger, coordinate, finalLabel, activeIndex, finalIsActive);
	var tooltipPortal = portalFromProps !== null && portalFromProps !== void 0 ? portalFromProps : tooltipPortalFromContext;
	if (tooltipPortal == null) return null;
	var finalPayload = payload !== null && payload !== void 0 ? payload : emptyPayload;
	if (!finalIsActive) finalPayload = emptyPayload;
	if (filterNull && finalPayload.length) finalPayload = getUniqPayload(payload.filter((entry) => entry.value != null && (entry.hide !== true || props.includeHidden)), payloadUniqBy, defaultUniqBy);
	var hasPayload = finalPayload.length > 0;
	var tooltipElement = /* @__PURE__ */ import_react.createElement(TooltipBoundingBox, {
		allowEscapeViewBox,
		animationDuration,
		animationEasing,
		isAnimationActive,
		active: finalIsActive,
		coordinate,
		hasPayload,
		offset,
		position: position$1,
		reverseDirection,
		useTranslate3d,
		viewBox,
		wrapperStyle,
		lastBoundingBox,
		innerRef: updateBoundingBox,
		hasPortalFromProps: Boolean(portalFromProps)
	}, renderContent(content, _objectSpread$39(_objectSpread$39({}, props), {}, {
		payload: finalPayload,
		label: finalLabel,
		active: finalIsActive,
		coordinate,
		accessibilityLayer
	})));
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ (0, import_react_dom.createPortal)(tooltipElement, tooltipPortal), finalIsActive && /* @__PURE__ */ import_react.createElement(Cursor, {
		cursor,
		tooltipEventType,
		coordinate,
		payload,
		index: activeIndex
	}));
}

//#endregion
//#region node_modules/recharts/es6/component/Cell.js
/**
* @fileOverview Cross
*/
var Cell = (_props) => null;
Cell.displayName = "Cell";

//#endregion
//#region node_modules/recharts/es6/util/LRUCache.js
function _defineProperty$40(e, r$1, t) {
	return (r$1 = _toPropertyKey$40(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$40(t) {
	var i = _toPrimitive$40(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$40(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* Simple LRU (Least Recently Used) cache implementation
*/
var LRUCache = class {
	constructor(maxSize) {
		_defineProperty$40(this, "cache", /* @__PURE__ */ new Map());
		this.maxSize = maxSize;
	}
	get(key) {
		var value = this.cache.get(key);
		if (value !== void 0) {
			this.cache.delete(key);
			this.cache.set(key, value);
		}
		return value;
	}
	set(key, value) {
		if (this.cache.has(key)) this.cache.delete(key);
		else if (this.cache.size >= this.maxSize) {
			var firstKey = this.cache.keys().next().value;
			this.cache.delete(firstKey);
		}
		this.cache.set(key, value);
	}
	clear() {
		this.cache.clear();
	}
	size() {
		return this.cache.size;
	}
};

//#endregion
//#region node_modules/recharts/es6/util/DOMUtils.js
function ownKeys$38(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$38(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$38(Object(t), !0).forEach(function(r$2) {
			_defineProperty$39(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$38(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$39(e, r$1, t) {
	return (r$1 = _toPropertyKey$39(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$39(t) {
	var i = _toPrimitive$39(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$39(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var currentConfig = _objectSpread$38({}, {
	cacheSize: 2e3,
	enableCache: true
});
var stringCache = new LRUCache(currentConfig.cacheSize);
var SPAN_STYLE = {
	position: "absolute",
	top: "-20000px",
	left: 0,
	padding: 0,
	margin: 0,
	border: "none",
	whiteSpace: "pre"
};
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function createCacheKey(text, style) {
	var fontSize = style.fontSize || "";
	var fontFamily = style.fontFamily || "";
	var fontWeight = style.fontWeight || "";
	var fontStyle = style.fontStyle || "";
	var letterSpacing = style.letterSpacing || "";
	var textTransform = style.textTransform || "";
	return "".concat(text, "|").concat(fontSize, "|").concat(fontFamily, "|").concat(fontWeight, "|").concat(fontStyle, "|").concat(letterSpacing, "|").concat(textTransform);
}
/**
* Measure text using DOM (accurate but slower)
* @param text - The text to measure
* @param style - CSS style properties to apply
* @returns The size of the text
*/
var measureTextWithDOM = (text, style) => {
	try {
		var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
		if (!measurementSpan) {
			measurementSpan = document.createElement("span");
			measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
			measurementSpan.setAttribute("aria-hidden", "true");
			document.body.appendChild(measurementSpan);
		}
		Object.assign(measurementSpan.style, SPAN_STYLE, style);
		measurementSpan.textContent = "".concat(text);
		var rect = measurementSpan.getBoundingClientRect();
		return {
			width: rect.width,
			height: rect.height
		};
	} catch (_unused) {
		return {
			width: 0,
			height: 0
		};
	}
};
var getStringSize = function getStringSize$1(text) {
	var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
	if (text === void 0 || text === null || Global.isSsr) return {
		width: 0,
		height: 0
	};
	if (!currentConfig.enableCache) return measureTextWithDOM(text, style);
	var cacheKey = createCacheKey(text, style);
	var cachedResult = stringCache.get(cacheKey);
	if (cachedResult) return cachedResult;
	var result = measureTextWithDOM(text, style);
	stringCache.set(cacheKey, result);
	return result;
};

//#endregion
//#region node_modules/recharts/es6/util/ReduceCSSCalc.js
var MULTIPLY_OR_DIVIDE_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([*/])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var ADD_OR_SUBTRACT_REGEX = /(-?\d+(?:\.\d+)?[a-zA-Z%]*)([+-])(-?\d+(?:\.\d+)?[a-zA-Z%]*)/;
var CSS_LENGTH_UNIT_REGEX = /^px|cm|vh|vw|em|rem|%|mm|in|pt|pc|ex|ch|vmin|vmax|Q$/;
var NUM_SPLIT_REGEX = /(-?\d+(?:\.\d+)?)([a-zA-Z%]+)?/;
var CONVERSION_RATES = {
	cm: 96 / 2.54,
	mm: 96 / 25.4,
	pt: 96 / 72,
	pc: 96 / 6,
	in: 96,
	Q: 96 / (2.54 * 40),
	px: 1
};
var FIXED_CSS_LENGTH_UNITS = Object.keys(CONVERSION_RATES);
var STR_NAN = "NaN";
function convertToPx(value, unit$1) {
	return value * CONVERSION_RATES[unit$1];
}
var DecimalCSS = class DecimalCSS {
	static parse(str) {
		var _NUM_SPLIT_REGEX$exec;
		var [, numStr, unit$1] = (_NUM_SPLIT_REGEX$exec = NUM_SPLIT_REGEX.exec(str)) !== null && _NUM_SPLIT_REGEX$exec !== void 0 ? _NUM_SPLIT_REGEX$exec : [];
		return new DecimalCSS(parseFloat(numStr), unit$1 !== null && unit$1 !== void 0 ? unit$1 : "");
	}
	constructor(num, unit$1) {
		this.num = num;
		this.unit = unit$1;
		this.num = num;
		this.unit = unit$1;
		if (isNan(num)) this.unit = "";
		if (unit$1 !== "" && !CSS_LENGTH_UNIT_REGEX.test(unit$1)) {
			this.num = NaN;
			this.unit = "";
		}
		if (FIXED_CSS_LENGTH_UNITS.includes(unit$1)) {
			this.num = convertToPx(num, unit$1);
			this.unit = "px";
		}
	}
	add(other) {
		if (this.unit !== other.unit) return new DecimalCSS(NaN, "");
		return new DecimalCSS(this.num + other.num, this.unit);
	}
	subtract(other) {
		if (this.unit !== other.unit) return new DecimalCSS(NaN, "");
		return new DecimalCSS(this.num - other.num, this.unit);
	}
	multiply(other) {
		if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS(NaN, "");
		return new DecimalCSS(this.num * other.num, this.unit || other.unit);
	}
	divide(other) {
		if (this.unit !== "" && other.unit !== "" && this.unit !== other.unit) return new DecimalCSS(NaN, "");
		return new DecimalCSS(this.num / other.num, this.unit || other.unit);
	}
	toString() {
		return "".concat(this.num).concat(this.unit);
	}
	isNaN() {
		return isNan(this.num);
	}
};
function calculateArithmetic(expr) {
	if (expr.includes(STR_NAN)) return STR_NAN;
	var newExpr = expr;
	while (newExpr.includes("*") || newExpr.includes("/")) {
		var _MULTIPLY_OR_DIVIDE_R;
		var [, leftOperand, operator, rightOperand] = (_MULTIPLY_OR_DIVIDE_R = MULTIPLY_OR_DIVIDE_REGEX.exec(newExpr)) !== null && _MULTIPLY_OR_DIVIDE_R !== void 0 ? _MULTIPLY_OR_DIVIDE_R : [];
		var lTs = DecimalCSS.parse(leftOperand !== null && leftOperand !== void 0 ? leftOperand : "");
		var rTs = DecimalCSS.parse(rightOperand !== null && rightOperand !== void 0 ? rightOperand : "");
		var result = operator === "*" ? lTs.multiply(rTs) : lTs.divide(rTs);
		if (result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(MULTIPLY_OR_DIVIDE_REGEX, result.toString());
	}
	while (newExpr.includes("+") || /.-\d+(?:\.\d+)?/.test(newExpr)) {
		var _ADD_OR_SUBTRACT_REGE;
		var [, _leftOperand, _operator, _rightOperand] = (_ADD_OR_SUBTRACT_REGE = ADD_OR_SUBTRACT_REGEX.exec(newExpr)) !== null && _ADD_OR_SUBTRACT_REGE !== void 0 ? _ADD_OR_SUBTRACT_REGE : [];
		var _lTs = DecimalCSS.parse(_leftOperand !== null && _leftOperand !== void 0 ? _leftOperand : "");
		var _rTs = DecimalCSS.parse(_rightOperand !== null && _rightOperand !== void 0 ? _rightOperand : "");
		var _result = _operator === "+" ? _lTs.add(_rTs) : _lTs.subtract(_rTs);
		if (_result.isNaN()) return STR_NAN;
		newExpr = newExpr.replace(ADD_OR_SUBTRACT_REGEX, _result.toString());
	}
	return newExpr;
}
var PARENTHESES_REGEX = /\(([^()]*)\)/;
function calculateParentheses(expr) {
	var newExpr = expr;
	var match;
	while ((match = PARENTHESES_REGEX.exec(newExpr)) != null) {
		var [, parentheticalExpression] = match;
		newExpr = newExpr.replace(PARENTHESES_REGEX, calculateArithmetic(parentheticalExpression));
	}
	return newExpr;
}
function evaluateExpression(expression) {
	var newExpr = expression.replace(/\s+/g, "");
	newExpr = calculateParentheses(newExpr);
	newExpr = calculateArithmetic(newExpr);
	return newExpr;
}
function safeEvaluateExpression(expression) {
	try {
		return evaluateExpression(expression);
	} catch (_unused) {
		return STR_NAN;
	}
}
function reduceCSSCalc(expression) {
	var result = safeEvaluateExpression(expression.slice(5, -1));
	if (result === STR_NAN) return "";
	return result;
}

//#endregion
//#region node_modules/recharts/es6/component/Text.js
var _excluded$29 = [
	"x",
	"y",
	"lineHeight",
	"capHeight",
	"scaleToFit",
	"textAnchor",
	"verticalAnchor",
	"fill"
], _excluded2$14 = [
	"dx",
	"dy",
	"angle",
	"className",
	"breakAll"
];
function _extends$36() {
	return _extends$36 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$36.apply(null, arguments);
}
function _objectWithoutProperties$29(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$29(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$29(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = (_ref$1) => {
	var { children, breakAll, style } = _ref$1;
	try {
		var words = [];
		if (!isNullish(children)) if (breakAll) words = children.toString().split("");
		else words = children.toString().split(BREAKING_SPACES);
		var wordsWithComputedWidth = words.map((word) => ({
			word,
			width: getStringSize(word, style).width
		}));
		var spaceWidth = breakAll ? 0 : getStringSize("\xA0", style).width;
		return {
			wordsWithComputedWidth,
			spaceWidth
		};
	} catch (_unused) {
		return null;
	}
};
var calculateWordsByLines = (_ref2, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) => {
	var { maxLines, children, style, breakAll } = _ref2;
	var shouldLimitLines = isNumber(maxLines);
	var text = children;
	var calculate = function calculate$1() {
		return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).reduce((result$1, _ref3) => {
			var { word, width } = _ref3;
			var currentLine = result$1[result$1.length - 1];
			if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < Number(lineWidth))) {
				currentLine.words.push(word);
				currentLine.width += width + spaceWidth;
			} else {
				var newLine = {
					words: [word],
					width
				};
				result$1.push(newLine);
			}
			return result$1;
		}, []);
	};
	var originalResult = calculate(initialWordsWithComputedWith);
	var findLongestLine = (words) => words.reduce((a$1, b) => a$1.width > b.width ? a$1 : b);
	if (!shouldLimitLines || scaleToFit) return originalResult;
	if (!(originalResult.length > maxLines || findLongestLine(originalResult).width > Number(lineWidth))) return originalResult;
	var suffix = "";
	var checkOverflow = (index) => {
		var tempText = text.slice(0, index);
		var words = calculateWordWidths({
			breakAll,
			style,
			children: tempText + suffix
		}).wordsWithComputedWidth;
		var result$1 = calculate(words);
		return [result$1.length > maxLines || findLongestLine(result$1).width > Number(lineWidth), result$1];
	};
	var start = 0;
	var end = text.length - 1;
	var iterations = 0;
	var trimmedResult;
	while (start <= end && iterations <= text.length - 1) {
		var middle = Math.floor((start + end) / 2);
		var prev = middle - 1;
		var [doesPrevOverflow, result] = checkOverflow(prev);
		var [doesMiddleOverflow] = checkOverflow(middle);
		if (!doesPrevOverflow && !doesMiddleOverflow) start = middle + 1;
		if (doesPrevOverflow && doesMiddleOverflow) end = middle - 1;
		if (!doesPrevOverflow && doesMiddleOverflow) {
			trimmedResult = result;
			break;
		}
		iterations++;
	}
	return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = (children) => {
	return [{ words: !isNullish(children) ? children.toString().split(BREAKING_SPACES) : [] }];
};
var getWordsByLines = (_ref4) => {
	var { width, scaleToFit, children, style, breakAll, maxLines } = _ref4;
	if ((width || scaleToFit) && !Global.isSsr) {
		var wordsWithComputedWidth, spaceWidth;
		var wordWidths = calculateWordWidths({
			breakAll,
			children,
			style
		});
		if (wordWidths) {
			var { wordsWithComputedWidth: wcw, spaceWidth: sw } = wordWidths;
			wordsWithComputedWidth = wcw;
			spaceWidth = sw;
		} else return getWordsWithoutCalculate(children);
		return calculateWordsByLines({
			breakAll,
			children,
			maxLines,
			style
		}, wordsWithComputedWidth, spaceWidth, width, scaleToFit);
	}
	return getWordsWithoutCalculate(children);
};
var DEFAULT_FILL = "#808080";
var Text = /* @__PURE__ */ (0, import_react.forwardRef)((_ref5, ref) => {
	var { x: propsX = 0, y: propsY = 0, lineHeight = "1em", capHeight = "0.71em", scaleToFit = false, textAnchor = "start", verticalAnchor = "end", fill = DEFAULT_FILL } = _ref5, props = _objectWithoutProperties$29(_ref5, _excluded$29);
	var wordsByLines = (0, import_react.useMemo)(() => {
		return getWordsByLines({
			breakAll: props.breakAll,
			children: props.children,
			maxLines: props.maxLines,
			scaleToFit,
			style: props.style,
			width: props.width
		});
	}, [
		props.breakAll,
		props.children,
		props.maxLines,
		scaleToFit,
		props.style,
		props.width
	]);
	var { dx, dy, angle, className, breakAll } = props, textProps = _objectWithoutProperties$29(props, _excluded2$14);
	if (!isNumOrStr(propsX) || !isNumOrStr(propsY) || wordsByLines.length === 0) return null;
	var x$1 = propsX + (isNumber(dx) ? dx : 0);
	var y$1 = propsY + (isNumber(dy) ? dy : 0);
	var startDy;
	switch (verticalAnchor) {
		case "start":
			startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
			break;
		case "middle":
			startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
			break;
		default:
			startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
			break;
	}
	var transforms = [];
	if (scaleToFit) {
		var lineWidth = wordsByLines[0].width;
		var { width } = props;
		transforms.push("scale(".concat(isNumber(width) ? width / lineWidth : 1, ")"));
	}
	if (angle) transforms.push("rotate(".concat(angle, ", ").concat(x$1, ", ").concat(y$1, ")"));
	if (transforms.length) textProps.transform = transforms.join(" ");
	return /* @__PURE__ */ import_react.createElement("text", _extends$36({}, svgPropertiesAndEvents(textProps), {
		ref,
		x: x$1,
		y: y$1,
		className: clsx("recharts-text", className),
		textAnchor,
		fill: fill.includes("url") ? DEFAULT_FILL : fill
	}), wordsByLines.map((line, index) => {
		var words = line.words.join(breakAll ? "" : " ");
		return /* @__PURE__ */ import_react.createElement("tspan", {
			x: x$1,
			dy: index === 0 ? startDy : lineHeight,
			key: "".concat(words, "-").concat(index)
		}, words);
	}));
});
Text.displayName = "Text";

//#endregion
//#region node_modules/recharts/es6/component/Label.js
var _excluded$28 = ["labelRef"];
function _objectWithoutProperties$28(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$28(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$28(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$37(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$37(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$37(Object(t), !0).forEach(function(r$2) {
			_defineProperty$38(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$37(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$38(e, r$1, t) {
	return (r$1 = _toPropertyKey$38(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$38(t) {
	var i = _toPrimitive$38(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$38(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$35() {
	return _extends$35 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$35.apply(null, arguments);
}
var CartesianLabelContext = /* @__PURE__ */ (0, import_react.createContext)(null);
var CartesianLabelContextProvider = (_ref$1) => {
	var { x: x$1, y: y$1, width, height, children } = _ref$1;
	var viewBox = (0, import_react.useMemo)(() => ({
		x: x$1,
		y: y$1,
		width,
		height
	}), [
		x$1,
		y$1,
		width,
		height
	]);
	return /* @__PURE__ */ import_react.createElement(CartesianLabelContext.Provider, { value: viewBox }, children);
};
var useCartesianLabelContext = () => {
	var labelChildContext = (0, import_react.useContext)(CartesianLabelContext);
	var chartContext = useViewBox();
	return labelChildContext || chartContext;
};
var PolarLabelContext = /* @__PURE__ */ (0, import_react.createContext)(null);
var PolarLabelContextProvider = (_ref2) => {
	var { cx, cy, innerRadius, outerRadius, startAngle, endAngle, clockWise, children } = _ref2;
	var viewBox = (0, import_react.useMemo)(() => ({
		cx,
		cy,
		innerRadius,
		outerRadius,
		startAngle,
		endAngle,
		clockWise
	}), [
		cx,
		cy,
		innerRadius,
		outerRadius,
		startAngle,
		endAngle,
		clockWise
	]);
	return /* @__PURE__ */ import_react.createElement(PolarLabelContext.Provider, { value: viewBox }, children);
};
var usePolarLabelContext = () => {
	var labelChildContext = (0, import_react.useContext)(PolarLabelContext);
	var chartContext = useAppSelector(selectPolarViewBox);
	return labelChildContext || chartContext;
};
var getLabel = (props) => {
	var { value, formatter } = props;
	var label = isNullish(props.children) ? value : props.children;
	if (typeof formatter === "function") return formatter(label);
	return label;
};
var isLabelContentAFunction = (content) => {
	return content != null && typeof content === "function";
};
var getDeltaAngle = (startAngle, endAngle) => {
	var sign$1 = mathSign(endAngle - startAngle);
	var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
	return sign$1 * deltaAngle;
};
var renderRadialLabel = (labelProps, position$1, label, attrs, viewBox) => {
	var { offset, className } = labelProps;
	var { cx, cy, innerRadius, outerRadius, startAngle, endAngle, clockWise } = viewBox;
	var radius = (innerRadius + outerRadius) / 2;
	var deltaAngle = getDeltaAngle(startAngle, endAngle);
	var sign$1 = deltaAngle >= 0 ? 1 : -1;
	var labelAngle, direction;
	switch (position$1) {
		case "insideStart":
			labelAngle = startAngle + sign$1 * offset;
			direction = clockWise;
			break;
		case "insideEnd":
			labelAngle = endAngle - sign$1 * offset;
			direction = !clockWise;
			break;
		case "end":
			labelAngle = endAngle + sign$1 * offset;
			direction = clockWise;
			break;
		default: throw new Error("Unsupported position ".concat(position$1));
	}
	direction = deltaAngle <= 0 ? direction : !direction;
	var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
	var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
	var path$1 = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
	var id = isNullish(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
	return /* @__PURE__ */ import_react.createElement("text", _extends$35({}, attrs, {
		dominantBaseline: "central",
		className: clsx("recharts-radial-bar-label", className)
	}), /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("path", {
		id,
		d: path$1
	})), /* @__PURE__ */ import_react.createElement("textPath", { xlinkHref: "#".concat(id) }, label));
};
var getAttrsOfPolarLabel = (viewBox, offset, position$1) => {
	var { cx, cy, innerRadius, outerRadius, startAngle, endAngle } = viewBox;
	var midAngle = (startAngle + endAngle) / 2;
	if (position$1 === "outside") {
		var { x: _x, y: _y } = polarToCartesian(cx, cy, outerRadius + offset, midAngle);
		return {
			x: _x,
			y: _y,
			textAnchor: _x >= cx ? "start" : "end",
			verticalAnchor: "middle"
		};
	}
	if (position$1 === "center") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
	if (position$1 === "centerTop") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "start"
	};
	if (position$1 === "centerBottom") return {
		x: cx,
		y: cy,
		textAnchor: "middle",
		verticalAnchor: "end"
	};
	var r$1 = (innerRadius + outerRadius) / 2;
	var { x: x$1, y: y$1 } = polarToCartesian(cx, cy, r$1, midAngle);
	return {
		x: x$1,
		y: y$1,
		textAnchor: "middle",
		verticalAnchor: "middle"
	};
};
var isPolar = (viewBox) => "cx" in viewBox && isNumber(viewBox.cx);
var getAttrsOfCartesianLabel = (props, viewBox) => {
	var { parentViewBox: parentViewBoxFromProps, offset, position: position$1 } = props;
	var parentViewBox;
	if (parentViewBoxFromProps != null && !isPolar(parentViewBoxFromProps)) parentViewBox = parentViewBoxFromProps;
	var { x: x$1, y: y$1, width, height } = viewBox;
	var verticalSign = height >= 0 ? 1 : -1;
	var verticalOffset = verticalSign * offset;
	var verticalEnd = verticalSign > 0 ? "end" : "start";
	var verticalStart = verticalSign > 0 ? "start" : "end";
	var horizontalSign = width >= 0 ? 1 : -1;
	var horizontalOffset = horizontalSign * offset;
	var horizontalEnd = horizontalSign > 0 ? "end" : "start";
	var horizontalStart = horizontalSign > 0 ? "start" : "end";
	if (position$1 === "top") {
		var attrs = {
			x: x$1 + width / 2,
			y: y$1 - verticalSign * offset,
			textAnchor: "middle",
			verticalAnchor: verticalEnd
		};
		return _objectSpread$37(_objectSpread$37({}, attrs), parentViewBox ? {
			height: Math.max(y$1 - parentViewBox.y, 0),
			width
		} : {});
	}
	if (position$1 === "bottom") {
		var _attrs = {
			x: x$1 + width / 2,
			y: y$1 + height + verticalOffset,
			textAnchor: "middle",
			verticalAnchor: verticalStart
		};
		return _objectSpread$37(_objectSpread$37({}, _attrs), parentViewBox ? {
			height: Math.max(parentViewBox.y + parentViewBox.height - (y$1 + height), 0),
			width
		} : {});
	}
	if (position$1 === "left") {
		var _attrs2 = {
			x: x$1 - horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalEnd,
			verticalAnchor: "middle"
		};
		return _objectSpread$37(_objectSpread$37({}, _attrs2), parentViewBox ? {
			width: Math.max(_attrs2.x - parentViewBox.x, 0),
			height
		} : {});
	}
	if (position$1 === "right") {
		var _attrs3 = {
			x: x$1 + width + horizontalOffset,
			y: y$1 + height / 2,
			textAnchor: horizontalStart,
			verticalAnchor: "middle"
		};
		return _objectSpread$37(_objectSpread$37({}, _attrs3), parentViewBox ? {
			width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
			height
		} : {});
	}
	var sizeAttrs = parentViewBox ? {
		width,
		height
	} : {};
	if (position$1 === "insideLeft") return _objectSpread$37({
		x: x$1 + horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalStart,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position$1 === "insideRight") return _objectSpread$37({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height / 2,
		textAnchor: horizontalEnd,
		verticalAnchor: "middle"
	}, sizeAttrs);
	if (position$1 === "insideTop") return _objectSpread$37({
		x: x$1 + width / 2,
		y: y$1 + verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position$1 === "insideBottom") return _objectSpread$37({
		x: x$1 + width / 2,
		y: y$1 + height - verticalOffset,
		textAnchor: "middle",
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position$1 === "insideTopLeft") return _objectSpread$37({
		x: x$1 + horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position$1 === "insideTopRight") return _objectSpread$37({
		x: x$1 + width - horizontalOffset,
		y: y$1 + verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalStart
	}, sizeAttrs);
	if (position$1 === "insideBottomLeft") return _objectSpread$37({
		x: x$1 + horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalStart,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (position$1 === "insideBottomRight") return _objectSpread$37({
		x: x$1 + width - horizontalOffset,
		y: y$1 + height - verticalOffset,
		textAnchor: horizontalEnd,
		verticalAnchor: verticalEnd
	}, sizeAttrs);
	if (!!position$1 && typeof position$1 === "object" && (isNumber(position$1.x) || isPercent(position$1.x)) && (isNumber(position$1.y) || isPercent(position$1.y))) return _objectSpread$37({
		x: x$1 + getPercentValue(position$1.x, width),
		y: y$1 + getPercentValue(position$1.y, height),
		textAnchor: "end",
		verticalAnchor: "end"
	}, sizeAttrs);
	return _objectSpread$37({
		x: x$1 + width / 2,
		y: y$1 + height / 2,
		textAnchor: "middle",
		verticalAnchor: "middle"
	}, sizeAttrs);
};
var defaultLabelProps = { offset: 5 };
function Label(outerProps) {
	var props = resolveDefaultProps(outerProps, defaultLabelProps);
	var { viewBox: viewBoxFromProps, position: position$1, value, children, content, className = "", textBreakAll, labelRef } = props;
	var polarViewBox = usePolarLabelContext();
	var cartesianViewBox = useCartesianLabelContext();
	var viewBox = viewBoxFromProps || (position$1 === "center" ? cartesianViewBox : polarViewBox !== null && polarViewBox !== void 0 ? polarViewBox : cartesianViewBox);
	if (!viewBox || isNullish(value) && isNullish(children) && !/* @__PURE__ */ (0, import_react.isValidElement)(content) && typeof content !== "function") return null;
	var propsWithViewBox = _objectSpread$37(_objectSpread$37({}, props), {}, { viewBox });
	if (/* @__PURE__ */ (0, import_react.isValidElement)(content)) {
		var { labelRef: _ } = propsWithViewBox, propsWithoutLabelRef = _objectWithoutProperties$28(propsWithViewBox, _excluded$28);
		return /* @__PURE__ */ (0, import_react.cloneElement)(content, propsWithoutLabelRef);
	}
	var label;
	if (typeof content === "function") {
		label = /* @__PURE__ */ (0, import_react.createElement)(content, propsWithViewBox);
		if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) return label;
	} else label = getLabel(props);
	var isPolarLabel = isPolar(viewBox);
	var attrs = svgPropertiesAndEvents(props);
	if (isPolarLabel && (position$1 === "insideStart" || position$1 === "insideEnd" || position$1 === "end")) return renderRadialLabel(props, position$1, label, attrs, viewBox);
	var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(viewBox, props.offset, props.position) : getAttrsOfCartesianLabel(props, viewBox);
	return /* @__PURE__ */ import_react.createElement(Text, _extends$35({
		ref: labelRef,
		className: clsx("recharts-label", className)
	}, attrs, positionAttrs, { breakAll: textBreakAll }), label);
}
Label.displayName = "Label";
var parseLabel = (label, viewBox, labelRef) => {
	if (!label) return null;
	var commonProps = {
		viewBox,
		labelRef
	};
	if (label === true) return /* @__PURE__ */ import_react.createElement(Label, _extends$35({ key: "label-implicit" }, commonProps));
	if (isNumOrStr(label)) return /* @__PURE__ */ import_react.createElement(Label, _extends$35({
		key: "label-implicit",
		value: label
	}, commonProps));
	if (/* @__PURE__ */ (0, import_react.isValidElement)(label)) {
		if (label.type === Label) return /* @__PURE__ */ (0, import_react.cloneElement)(label, _objectSpread$37({ key: "label-implicit" }, commonProps));
		return /* @__PURE__ */ import_react.createElement(Label, _extends$35({
			key: "label-implicit",
			content: label
		}, commonProps));
	}
	if (isLabelContentAFunction(label)) return /* @__PURE__ */ import_react.createElement(Label, _extends$35({
		key: "label-implicit",
		content: label
	}, commonProps));
	if (label && typeof label === "object") return /* @__PURE__ */ import_react.createElement(Label, _extends$35({}, label, { key: "label-implicit" }, commonProps));
	return null;
};
function CartesianLabelFromLabelProp(_ref3) {
	var { label, labelRef } = _ref3;
	var viewBox = useCartesianLabelContext();
	return parseLabel(label, viewBox, labelRef) || null;
}
function PolarLabelFromLabelProp(_ref4) {
	var { label } = _ref4;
	var viewBox = usePolarLabelContext();
	return parseLabel(label, viewBox) || null;
}

//#endregion
//#region node_modules/es-toolkit/dist/array/last.js
var require_last$2 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/array/last.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function last$3(arr) {
		return arr[arr.length - 1];
	}
	exports.last = last$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/toArray.js
var require_toArray = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/toArray.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function toArray$2(value) {
		return Array.isArray(value) ? value : Array.from(value);
	}
	exports.toArray = toArray$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/array/last.js
var require_last$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/array/last.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var last$1$1 = require_last$2();
	var toArray$1 = require_toArray();
	var isArrayLike$2 = require_isArrayLike();
	function last$2(array) {
		if (!isArrayLike$2.isArrayLike(array)) return;
		return last$1$1.last(toArray$1.toArray(array));
	}
	exports.last = last$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/last.js
var require_last = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/last.js": ((exports, module) => {
	module.exports = require_last$1().last;
}) });

//#endregion
//#region node_modules/recharts/es6/component/LabelList.js
var import_last$1 = /* @__PURE__ */ __toESM(require_last());
var _excluded$27 = ["valueAccessor"], _excluded2$13 = [
	"dataKey",
	"clockWise",
	"id",
	"textBreakAll"
];
function _extends$34() {
	return _extends$34 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$34.apply(null, arguments);
}
function _objectWithoutProperties$27(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$27(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$27(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
/**
* This is public API because we expose it as the valueAccessor parameter.
*
* The properties of "viewBox" are repeated as the root props of the entry object.
* So it doesn't matter if you read entry.x or entry.viewBox.x, they are the same.
*
* It's not necessary to pass redundant data, but we keep it for backward compatibility.
*/
/**
* LabelList props do not allow refs because the same props are reused in multiple elements so we don't have a good single place to ref to.
*/
/**
* This is the type accepted for the `label` prop on various graphical items.
* It accepts:
*
* boolean:
*    true = labels show,
*    false = labels don't show
* React element:
*    will be cloned with extra props
* function:
*    is used as <Label content={function} />, so this will be called once for each individual label (so typically once for each data point)
* object:
*    the props to be passed to a LabelList component
*/
var defaultAccessor = (entry) => Array.isArray(entry.value) ? (0, import_last$1.default)(entry.value) : entry.value;
var CartesianLabelListContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var CartesianLabelListContextProvider = CartesianLabelListContext.Provider;
var PolarLabelListContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var PolarLabelListContextProvider = PolarLabelListContext.Provider;
function useCartesianLabelListContext() {
	return (0, import_react.useContext)(CartesianLabelListContext);
}
function usePolarLabelListContext() {
	return (0, import_react.useContext)(PolarLabelListContext);
}
function LabelList(_ref$1) {
	var { valueAccessor = defaultAccessor } = _ref$1, restProps = _objectWithoutProperties$27(_ref$1, _excluded$27);
	var { dataKey, clockWise, id, textBreakAll } = restProps, others = _objectWithoutProperties$27(restProps, _excluded2$13);
	var cartesianData = useCartesianLabelListContext();
	var polarData = usePolarLabelListContext();
	var data = cartesianData || polarData;
	if (!data || !data.length) return null;
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-label-list" }, data.map((entry, index) => {
		var _restProps$fill;
		var value = isNullish(dataKey) ? valueAccessor(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
		var idProps = isNullish(id) ? {} : { id: "".concat(id, "-").concat(index) };
		return /* @__PURE__ */ import_react.createElement(Label, _extends$34({ key: "label-".concat(index) }, svgPropertiesAndEvents(entry), others, idProps, {
			fill: (_restProps$fill = restProps.fill) !== null && _restProps$fill !== void 0 ? _restProps$fill : entry.fill,
			parentViewBox: entry.parentViewBox,
			value,
			textBreakAll,
			viewBox: entry.viewBox,
			index
		}));
	}));
}
LabelList.displayName = "LabelList";
function LabelListFromLabelProp(_ref2) {
	var { label } = _ref2;
	if (!label) return null;
	if (label === true) return /* @__PURE__ */ import_react.createElement(LabelList, { key: "labelList-implicit" });
	if (/* @__PURE__ */ import_react.isValidElement(label) || isLabelContentAFunction(label)) return /* @__PURE__ */ import_react.createElement(LabelList, {
		key: "labelList-implicit",
		content: label
	});
	if (typeof label === "object") return /* @__PURE__ */ import_react.createElement(LabelList, _extends$34({ key: "labelList-implicit" }, label, { type: String(label.type) }));
	return null;
}

//#endregion
//#region node_modules/recharts/es6/component/Customized.js
var _excluded$26 = ["component"];
function _objectWithoutProperties$26(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$26(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$26(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
/**
* custom svg elements by rechart instance props and state.
* @returns {Object}   svg elements
*/
function Customized(_ref$1) {
	var { component } = _ref$1, props = _objectWithoutProperties$26(_ref$1, _excluded$26);
	var child;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(component)) child = /* @__PURE__ */ (0, import_react.cloneElement)(component, props);
	else if (typeof component === "function") child = /* @__PURE__ */ (0, import_react.createElement)(component, props);
	else warn(false, "Customized's props `component` must be React.element or Function, but got %s.", typeof component);
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-customized-wrapper" }, child);
}
Customized.displayName = "Customized";

//#endregion
//#region node_modules/recharts/es6/shape/Polygon.js
var _excluded$25 = [
	"points",
	"className",
	"baseLinePoints",
	"connectNulls"
];
function _extends$33() {
	return _extends$33 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$33.apply(null, arguments);
}
function _objectWithoutProperties$25(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$25(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$25(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var isValidatePoint = (point$3) => {
	return point$3 && point$3.x === +point$3.x && point$3.y === +point$3.y;
};
var getParsedPoints = function getParsedPoints$1() {
	var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
	var segmentPoints = [[]];
	points.forEach((entry) => {
		if (isValidatePoint(entry)) segmentPoints[segmentPoints.length - 1].push(entry);
		else if (segmentPoints[segmentPoints.length - 1].length > 0) segmentPoints.push([]);
	});
	if (isValidatePoint(points[0])) segmentPoints[segmentPoints.length - 1].push(points[0]);
	if (segmentPoints[segmentPoints.length - 1].length <= 0) segmentPoints = segmentPoints.slice(0, -1);
	return segmentPoints;
};
var getSinglePolygonPath = (points, connectNulls) => {
	var segmentPoints = getParsedPoints(points);
	if (connectNulls) segmentPoints = [segmentPoints.reduce((res, segPoints) => {
		return [...res, ...segPoints];
	}, [])];
	var polygonPath = segmentPoints.map((segPoints) => {
		return segPoints.reduce((path$1, point$3, index) => {
			return "".concat(path$1).concat(index === 0 ? "M" : "L").concat(point$3.x, ",").concat(point$3.y);
		}, "");
	}).join("");
	return segmentPoints.length === 1 ? "".concat(polygonPath, "Z") : polygonPath;
};
var getRanglePath = (points, baseLinePoints, connectNulls) => {
	var outerPath = getSinglePolygonPath(points, connectNulls);
	return "".concat(outerPath.slice(-1) === "Z" ? outerPath.slice(0, -1) : outerPath, "L").concat(getSinglePolygonPath(Array.from(baseLinePoints).reverse(), connectNulls).slice(1));
};
var Polygon = (props) => {
	var { points, className, baseLinePoints, connectNulls } = props, others = _objectWithoutProperties$25(props, _excluded$25);
	if (!points || !points.length) return null;
	var layerClass = clsx("recharts-polygon", className);
	if (baseLinePoints && baseLinePoints.length) {
		var hasStroke = others.stroke && others.stroke !== "none";
		var rangePath = getRanglePath(points, baseLinePoints, connectNulls);
		return /* @__PURE__ */ import_react.createElement("g", { className: layerClass }, /* @__PURE__ */ import_react.createElement("path", _extends$33({}, svgPropertiesAndEvents(others), {
			fill: rangePath.slice(-1) === "Z" ? others.fill : "none",
			stroke: "none",
			d: rangePath
		})), hasStroke ? /* @__PURE__ */ import_react.createElement("path", _extends$33({}, svgPropertiesAndEvents(others), {
			fill: "none",
			d: getSinglePolygonPath(points, connectNulls)
		})) : null, hasStroke ? /* @__PURE__ */ import_react.createElement("path", _extends$33({}, svgPropertiesAndEvents(others), {
			fill: "none",
			d: getSinglePolygonPath(baseLinePoints, connectNulls)
		})) : null);
	}
	var singlePath = getSinglePolygonPath(points, connectNulls);
	return /* @__PURE__ */ import_react.createElement("path", _extends$33({}, svgPropertiesAndEvents(others), {
		fill: singlePath.slice(-1) === "Z" ? others.fill : "none",
		className: layerClass,
		d: singlePath
	}));
};

//#endregion
//#region node_modules/recharts/es6/shape/Dot.js
function _extends$32() {
	return _extends$32 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$32.apply(null, arguments);
}
var Dot = (props) => {
	var { cx, cy, r: r$1, className } = props;
	var layerClass = clsx("recharts-dot", className);
	if (cx === +cx && cy === +cy && r$1 === +r$1) return /* @__PURE__ */ import_react.createElement("circle", _extends$32({}, svgPropertiesNoEvents(props), adaptEventHandlers(props), {
		className: layerClass,
		cx,
		cy,
		r: r$1
	}));
	return null;
};

//#endregion
//#region node_modules/recharts/es6/state/selectors/polarSelectors.js
var selectUnfilteredPolarItems = (state) => state.graphicalItems.polarItems;
var selectAxisPredicate = createSelector([pickAxisType, pickAxisId], itemAxisPredicate);
var selectPolarItemsSettings = createSelector([
	selectUnfilteredPolarItems,
	selectBaseAxis,
	selectAxisPredicate
], combineGraphicalItemsSettings);
var selectPolarGraphicalItemsData = createSelector([selectPolarItemsSettings], combineGraphicalItemsData);
var selectPolarDisplayedData = createSelector([selectPolarGraphicalItemsData, selectChartDataAndAlwaysIgnoreIndexes], combineDisplayedData);
var selectPolarAppliedValues = createSelector([
	selectPolarDisplayedData,
	selectBaseAxis,
	selectPolarItemsSettings
], combineAppliedValues);
var selectAllPolarAppliedNumericalValues = createSelector([
	selectPolarDisplayedData,
	selectBaseAxis,
	selectPolarItemsSettings
], (data, axisSettings, items) => {
	if (items.length > 0) return data.flatMap((entry) => {
		return items.flatMap((item) => {
			var _axisSettings$dataKey;
			return {
				value: getValueByDataKey(entry, (_axisSettings$dataKey = axisSettings.dataKey) !== null && _axisSettings$dataKey !== void 0 ? _axisSettings$dataKey : item.dataKey),
				errorDomain: []
			};
		});
	}).filter(Boolean);
	if ((axisSettings === null || axisSettings === void 0 ? void 0 : axisSettings.dataKey) != null) return data.map((item) => ({
		value: getValueByDataKey(item, axisSettings.dataKey),
		errorDomain: []
	}));
	return data.map((entry) => ({
		value: entry,
		errorDomain: []
	}));
});
var unsupportedInPolarChart = () => void 0;
var selectDomainOfAllPolarAppliedNumericalValues = createSelector([
	selectPolarDisplayedData,
	selectBaseAxis,
	selectPolarItemsSettings,
	selectAllErrorBarSettings,
	pickAxisType
], combineDomainOfAllAppliedNumericalValuesIncludingErrorValues);
var selectPolarNumericalDomain = createSelector([
	selectBaseAxis,
	selectDomainDefinition,
	selectDomainFromUserPreference,
	unsupportedInPolarChart,
	selectDomainOfAllPolarAppliedNumericalValues,
	unsupportedInPolarChart,
	selectChartLayout,
	pickAxisType
], combineNumericalDomain);
var selectPolarAxisDomain = createSelector([
	selectBaseAxis,
	selectChartLayout,
	selectPolarDisplayedData,
	selectPolarAppliedValues,
	selectStackOffsetType,
	pickAxisType,
	selectPolarNumericalDomain
], combineAxisDomain);
var selectPolarNiceTicks = createSelector([
	selectPolarAxisDomain,
	selectBaseAxis,
	selectRealScaleType
], combineNiceTicks);
var selectPolarAxisDomainIncludingNiceTicks = createSelector([
	selectBaseAxis,
	selectPolarAxisDomain,
	selectPolarNiceTicks,
	pickAxisType
], combineAxisDomainWithNiceTicks);

//#endregion
//#region node_modules/recharts/es6/state/selectors/polarScaleSelectors.js
var selectPolarAxis = (state, axisType, axisId) => {
	switch (axisType) {
		case "angleAxis": return selectAngleAxis(state, axisId);
		case "radiusAxis": return selectRadiusAxis(state, axisId);
		default: throw new Error("Unexpected axis type: ".concat(axisType));
	}
};
var selectPolarAxisRangeWithReversed = (state, axisType, axisId) => {
	switch (axisType) {
		case "angleAxis": return selectAngleAxisRangeWithReversed(state, axisId);
		case "radiusAxis": return selectRadiusAxisRangeWithReversed(state, axisId);
		default: throw new Error("Unexpected axis type: ".concat(axisType));
	}
};
var selectPolarAxisScale = createSelector([
	selectPolarAxis,
	selectRealScaleType,
	selectPolarAxisDomainIncludingNiceTicks,
	selectPolarAxisRangeWithReversed
], combineScaleFunction);
var selectPolarCategoricalDomain = createSelector([
	selectChartLayout,
	selectPolarAppliedValues,
	selectAxisSettings,
	pickAxisType
], combineCategoricalDomain);
var selectPolarAxisTicks = createSelector([
	selectChartLayout,
	selectPolarAxis,
	selectRealScaleType,
	selectPolarAxisScale,
	selectPolarNiceTicks,
	selectPolarAxisRangeWithReversed,
	selectDuplicateDomain,
	selectPolarCategoricalDomain,
	pickAxisType
], combineAxisTicks);
var selectPolarGraphicalItemAxisTicks = createSelector([
	selectChartLayout,
	selectPolarAxis,
	selectPolarAxisScale,
	selectPolarAxisRangeWithReversed,
	selectDuplicateDomain,
	selectPolarCategoricalDomain,
	pickAxisType
], combineGraphicalItemTicks);

//#endregion
//#region node_modules/recharts/es6/state/selectors/polarGridSelectors.js
var selectAngleAxisTicks$2 = (state, anglexisId) => selectPolarAxisTicks(state, "angleAxis", anglexisId, false);
var selectPolarGridAngles = createSelector([selectAngleAxisTicks$2], (ticks$1) => {
	if (!ticks$1) return;
	return ticks$1.map((tick) => tick.coordinate);
});
var selectRadiusAxisTicks$2 = (state, radiusAxisId) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false);
var selectPolarGridRadii = createSelector([selectRadiusAxisTicks$2], (ticks$1) => {
	if (!ticks$1) return;
	return ticks$1.map((tick) => tick.coordinate);
});

//#endregion
//#region node_modules/recharts/es6/polar/PolarGrid.js
var _excluded$24 = [
	"gridType",
	"radialLines",
	"angleAxisId",
	"radiusAxisId",
	"cx",
	"cy",
	"innerRadius",
	"outerRadius"
];
function _objectWithoutProperties$24(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$24(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$24(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$31() {
	return _extends$31 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$31.apply(null, arguments);
}
function ownKeys$36(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$36(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$36(Object(t), !0).forEach(function(r$2) {
			_defineProperty$37(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$36(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$37(e, r$1, t) {
	return (r$1 = _toPropertyKey$37(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$37(t) {
	var i = _toPrimitive$37(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$37(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var getPolygonPath = (radius, cx, cy, polarAngles) => {
	var path$1 = "";
	polarAngles.forEach((angle, i) => {
		var point$3 = polarToCartesian(cx, cy, radius, angle);
		if (i) path$1 += "L ".concat(point$3.x, ",").concat(point$3.y);
		else path$1 += "M ".concat(point$3.x, ",").concat(point$3.y);
	});
	path$1 += "Z";
	return path$1;
};
var PolarAngles = (props) => {
	var { cx, cy, innerRadius, outerRadius, polarAngles, radialLines } = props;
	if (!polarAngles || !polarAngles.length || !radialLines) return null;
	var polarAnglesProps = _objectSpread$36({ stroke: "#ccc" }, svgPropertiesNoEvents(props));
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-polar-grid-angle" }, polarAngles.map((entry) => {
		var start = polarToCartesian(cx, cy, innerRadius, entry);
		var end = polarToCartesian(cx, cy, outerRadius, entry);
		return /* @__PURE__ */ import_react.createElement("line", _extends$31({ key: "line-".concat(entry) }, polarAnglesProps, {
			x1: start.x,
			y1: start.y,
			x2: end.x,
			y2: end.y
		}));
	}));
};
var ConcentricCircle = (props) => {
	var { cx, cy, radius } = props;
	var concentricCircleProps = _objectSpread$36({
		stroke: "#ccc",
		fill: "none"
	}, svgPropertiesNoEvents(props));
	return /* @__PURE__ */ import_react.createElement("circle", _extends$31({}, concentricCircleProps, {
		className: clsx("recharts-polar-grid-concentric-circle", props.className),
		cx,
		cy,
		r: radius
	}));
};
var ConcentricPolygon = (props) => {
	var { radius } = props;
	var concentricPolygonProps = _objectSpread$36({
		stroke: "#ccc",
		fill: "none"
	}, svgPropertiesNoEvents(props));
	return /* @__PURE__ */ import_react.createElement("path", _extends$31({}, concentricPolygonProps, {
		className: clsx("recharts-polar-grid-concentric-polygon", props.className),
		d: getPolygonPath(radius, props.cx, props.cy, props.polarAngles)
	}));
};
var ConcentricGridPath = (props) => {
	var { polarRadius, gridType } = props;
	if (!polarRadius || !polarRadius.length) return null;
	var maxPolarRadius = Math.max(...polarRadius);
	var renderBackground = props.fill && props.fill !== "none";
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-polar-grid-concentric" }, renderBackground && gridType === "circle" && /* @__PURE__ */ import_react.createElement(ConcentricCircle, _extends$31({}, props, { radius: maxPolarRadius })), renderBackground && gridType !== "circle" && /* @__PURE__ */ import_react.createElement(ConcentricPolygon, _extends$31({}, props, { radius: maxPolarRadius })), polarRadius.map((entry, i) => {
		var key = i;
		if (gridType === "circle") return /* @__PURE__ */ import_react.createElement(ConcentricCircle, _extends$31({ key }, props, {
			fill: "none",
			radius: entry
		}));
		return /* @__PURE__ */ import_react.createElement(ConcentricPolygon, _extends$31({ key }, props, {
			fill: "none",
			radius: entry
		}));
	}));
};
var PolarGrid = (_ref$1) => {
	var _ref2, _polarViewBox$cx, _ref3, _polarViewBox$cy, _ref4, _polarViewBox$innerRa, _ref5, _polarViewBox$outerRa;
	var { gridType = "polygon", radialLines = true, angleAxisId = 0, radiusAxisId = 0, cx: cxFromOutside, cy: cyFromOutside, innerRadius: innerRadiusFromOutside, outerRadius: outerRadiusFromOutside } = _ref$1, inputs = _objectWithoutProperties$24(_ref$1, _excluded$24);
	var polarViewBox = useAppSelector(selectPolarViewBox);
	var props = _objectSpread$36({
		cx: (_ref2 = (_polarViewBox$cx = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cx) !== null && _polarViewBox$cx !== void 0 ? _polarViewBox$cx : cxFromOutside) !== null && _ref2 !== void 0 ? _ref2 : 0,
		cy: (_ref3 = (_polarViewBox$cy = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.cy) !== null && _polarViewBox$cy !== void 0 ? _polarViewBox$cy : cyFromOutside) !== null && _ref3 !== void 0 ? _ref3 : 0,
		innerRadius: (_ref4 = (_polarViewBox$innerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.innerRadius) !== null && _polarViewBox$innerRa !== void 0 ? _polarViewBox$innerRa : innerRadiusFromOutside) !== null && _ref4 !== void 0 ? _ref4 : 0,
		outerRadius: (_ref5 = (_polarViewBox$outerRa = polarViewBox === null || polarViewBox === void 0 ? void 0 : polarViewBox.outerRadius) !== null && _polarViewBox$outerRa !== void 0 ? _polarViewBox$outerRa : outerRadiusFromOutside) !== null && _ref5 !== void 0 ? _ref5 : 0
	}, inputs);
	var { polarAngles: polarAnglesInput, polarRadius: polarRadiusInput, outerRadius } = props;
	var polarAnglesFromRedux = useAppSelector((state) => selectPolarGridAngles(state, angleAxisId));
	var polarRadiiFromRedux = useAppSelector((state) => selectPolarGridRadii(state, radiusAxisId));
	var polarAngles = Array.isArray(polarAnglesInput) ? polarAnglesInput : polarAnglesFromRedux;
	var polarRadius = Array.isArray(polarRadiusInput) ? polarRadiusInput : polarRadiiFromRedux;
	if (outerRadius <= 0 || polarAngles == null || polarRadius == null) return null;
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-polar-grid" }, /* @__PURE__ */ import_react.createElement(ConcentricGridPath, _extends$31({
		gridType,
		radialLines
	}, props, {
		polarAngles,
		polarRadius
	})), /* @__PURE__ */ import_react.createElement(PolarAngles, _extends$31({
		gridType,
		radialLines
	}, props, {
		polarAngles,
		polarRadius
	})));
};
PolarGrid.displayName = "PolarGrid";

//#endregion
//#region node_modules/es-toolkit/dist/array/maxBy.js
var require_maxBy$2 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/array/maxBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function maxBy$3(items, getValue$1) {
		if (items.length === 0) return;
		let maxElement = items[0];
		let max$1 = getValue$1(maxElement);
		for (let i = 1; i < items.length; i++) {
			const element = items[i];
			const value = getValue$1(element);
			if (value > max$1) {
				max$1 = value;
				maxElement = element;
			}
		}
		return maxElement;
	}
	exports.maxBy = maxBy$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/math/maxBy.js
var require_maxBy$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/math/maxBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var maxBy$1$1 = require_maxBy$2();
	var identity$1 = require_identity();
	var iteratee$2 = require_iteratee();
	function maxBy$2(items, iteratee$1$1) {
		if (items == null) return;
		return maxBy$1$1.maxBy(Array.from(items), iteratee$2.iteratee(iteratee$1$1 ?? identity$1.identity));
	}
	exports.maxBy = maxBy$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/maxBy.js
var require_maxBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/maxBy.js": ((exports, module) => {
	module.exports = require_maxBy$1().maxBy;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/array/minBy.js
var require_minBy$2 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/array/minBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function minBy$3(items, getValue$1) {
		if (items.length === 0) return;
		let minElement = items[0];
		let min$1 = getValue$1(minElement);
		for (let i = 1; i < items.length; i++) {
			const element = items[i];
			const value = getValue$1(element);
			if (value < min$1) {
				min$1 = value;
				minElement = element;
			}
		}
		return minElement;
	}
	exports.minBy = minBy$3;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/math/minBy.js
var require_minBy$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/math/minBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var minBy$1 = require_minBy$2();
	var identity = require_identity();
	var iteratee$1 = require_iteratee();
	function minBy$2(items, iteratee$1$1) {
		if (items == null) return;
		return minBy$1.minBy(Array.from(items), iteratee$1.iteratee(iteratee$1$1 ?? identity.identity));
	}
	exports.minBy = minBy$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/minBy.js
var require_minBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/minBy.js": ((exports, module) => {
	module.exports = require_minBy$1().minBy;
}) });

//#endregion
//#region node_modules/recharts/es6/state/polarAxisSlice.js
var import_minBy = /* @__PURE__ */ __toESM(require_minBy());
var import_maxBy$1 = /* @__PURE__ */ __toESM(require_maxBy());
var polarAxisSlice = createSlice({
	name: "polarAxis",
	initialState: {
		radiusAxis: {},
		angleAxis: {}
	},
	reducers: {
		addRadiusAxis(state, action) {
			state.radiusAxis[action.payload.id] = castDraft(action.payload);
		},
		removeRadiusAxis(state, action) {
			delete state.radiusAxis[action.payload.id];
		},
		addAngleAxis(state, action) {
			state.angleAxis[action.payload.id] = castDraft(action.payload);
		},
		removeAngleAxis(state, action) {
			delete state.angleAxis[action.payload.id];
		}
	}
});
var { addRadiusAxis, removeRadiusAxis, addAngleAxis, removeAngleAxis } = polarAxisSlice.actions;
var polarAxisReducer = polarAxisSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/polar/PolarRadiusAxis.js
var _excluded$23 = [
	"cx",
	"cy",
	"angle",
	"axisLine"
], _excluded2$12 = [
	"angle",
	"tickFormatter",
	"stroke",
	"tick"
];
function _extends$30() {
	return _extends$30 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$30.apply(null, arguments);
}
function ownKeys$35(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$35(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$35(Object(t), !0).forEach(function(r$2) {
			_defineProperty$36(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$35(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$36(e, r$1, t) {
	return (r$1 = _toPropertyKey$36(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$36(t) {
	var i = _toPrimitive$36(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$36(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$23(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$23(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$23(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var AXIS_TYPE$1 = "radiusAxis";
function SetRadiusAxisSettings(settings) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(addRadiusAxis(settings));
		return () => {
			dispatch(removeRadiusAxis(settings));
		};
	});
	return null;
}
/**
* Calculate the coordinate of tick
* @param coordinate The radius of tick
* @param angle from props
* @param cx from chart
* @param cy from chart
* @return (x, y)
*/
var getTickValueCoord = (_ref$1, angle, cx, cy) => {
	var { coordinate } = _ref$1;
	return polarToCartesian(cx, cy, coordinate, angle);
};
var getTickTextAnchor$2 = (orientation) => {
	var textAnchor;
	switch (orientation) {
		case "left":
			textAnchor = "end";
			break;
		case "right":
			textAnchor = "start";
			break;
		default:
			textAnchor = "middle";
			break;
	}
	return textAnchor;
};
var getViewBox = (angle, cx, cy, ticks$1) => {
	var maxRadiusTick = (0, import_maxBy$1.default)(ticks$1, (entry) => entry.coordinate || 0);
	var minRadiusTick = (0, import_minBy.default)(ticks$1, (entry) => entry.coordinate || 0);
	return {
		cx,
		cy,
		startAngle: angle,
		endAngle: angle,
		innerRadius: minRadiusTick.coordinate || 0,
		outerRadius: maxRadiusTick.coordinate || 0,
		clockWise: false
	};
};
var renderAxisLine = (props, ticks$1) => {
	var { cx, cy, angle, axisLine } = props, others = _objectWithoutProperties$23(props, _excluded$23);
	var extent = ticks$1.reduce((result, entry) => [Math.min(result[0], entry.coordinate), Math.max(result[1], entry.coordinate)], [Infinity, -Infinity]);
	var point0 = polarToCartesian(cx, cy, extent[0], angle);
	var point1 = polarToCartesian(cx, cy, extent[1], angle);
	var axisLineProps = _objectSpread$35(_objectSpread$35(_objectSpread$35({}, svgPropertiesNoEvents(others)), {}, { fill: "none" }, svgPropertiesNoEvents(axisLine)), {}, {
		x1: point0.x,
		y1: point0.y,
		x2: point1.x,
		y2: point1.y
	});
	return /* @__PURE__ */ import_react.createElement("line", _extends$30({ className: "recharts-polar-radius-axis-line" }, axisLineProps));
};
var renderTickItem = (option, tickProps, value) => {
	var tickItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) tickItem = /* @__PURE__ */ import_react.cloneElement(option, tickProps);
	else if (typeof option === "function") tickItem = option(tickProps);
	else tickItem = /* @__PURE__ */ import_react.createElement(Text, _extends$30({}, tickProps, { className: "recharts-polar-radius-axis-tick-value" }), value);
	return tickItem;
};
var renderTicks = (props, ticks$1) => {
	var { angle, tickFormatter, stroke, tick } = props, others = _objectWithoutProperties$23(props, _excluded2$12);
	var textAnchor = getTickTextAnchor$2(props.orientation);
	var axisProps = svgPropertiesNoEvents(others);
	var customTickProps = svgPropertiesNoEventsFromUnknown(tick);
	var items = ticks$1.map((entry, i) => {
		var coord = getTickValueCoord(entry, props.angle, props.cx, props.cy);
		var tickProps = _objectSpread$35(_objectSpread$35(_objectSpread$35(_objectSpread$35({
			textAnchor,
			transform: "rotate(".concat(90 - angle, ", ").concat(coord.x, ", ").concat(coord.y, ")")
		}, axisProps), {}, {
			stroke: "none",
			fill: stroke
		}, customTickProps), {}, { index: i }, coord), {}, { payload: entry });
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$30({
			className: clsx("recharts-polar-radius-axis-tick", getTickClassName(tick)),
			key: "tick-".concat(entry.coordinate)
		}, adaptEventsOfChild(props, entry, i)), renderTickItem(tick, tickProps, tickFormatter ? tickFormatter(entry.value, i) : entry.value));
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-polar-radius-axis-ticks" }, items);
};
var PolarRadiusAxisWrapper = (defaultsAndInputs) => {
	var { radiusAxisId } = defaultsAndInputs;
	var viewBox = useAppSelector(selectPolarViewBox);
	var scale = useAppSelector((state) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId));
	var ticks$1 = useAppSelector((state) => selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, false));
	if (viewBox == null || !ticks$1 || !ticks$1.length) return null;
	var props = _objectSpread$35(_objectSpread$35(_objectSpread$35({}, defaultsAndInputs), {}, { scale }, viewBox), {}, { radius: viewBox.outerRadius });
	var { tick, axisLine } = props;
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx("recharts-polar-radius-axis", AXIS_TYPE$1, props.className) }, axisLine && renderAxisLine(props, ticks$1), tick && renderTicks(props, ticks$1), /* @__PURE__ */ import_react.createElement(PolarLabelContextProvider, getViewBox(props.angle, props.cx, props.cy, ticks$1), /* @__PURE__ */ import_react.createElement(PolarLabelFromLabelProp, { label: props.label }), props.children));
};
var PolarRadiusAxis = class extends import_react.PureComponent {
	render() {
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetRadiusAxisSettings, {
			domain: this.props.domain,
			id: this.props.radiusAxisId,
			scale: this.props.scale,
			type: this.props.type,
			dataKey: this.props.dataKey,
			unit: void 0,
			name: this.props.name,
			allowDuplicatedCategory: this.props.allowDuplicatedCategory,
			allowDataOverflow: this.props.allowDataOverflow,
			reversed: this.props.reversed,
			includeHidden: this.props.includeHidden,
			allowDecimals: this.props.allowDecimals,
			tickCount: this.props.tickCount,
			ticks: this.props.ticks,
			tick: this.props.tick
		}), /* @__PURE__ */ import_react.createElement(PolarRadiusAxisWrapper, this.props));
	}
};
_defineProperty$36(PolarRadiusAxis, "displayName", "PolarRadiusAxis");
_defineProperty$36(PolarRadiusAxis, "axisType", AXIS_TYPE$1);
_defineProperty$36(PolarRadiusAxis, "defaultProps", defaultPolarRadiusAxisProps);

//#endregion
//#region node_modules/recharts/es6/polar/PolarAngleAxis.js
var _excluded$22 = ["children"];
function _extends$29() {
	return _extends$29 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$29.apply(null, arguments);
}
function ownKeys$34(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$34(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$34(Object(t), !0).forEach(function(r$2) {
			_defineProperty$35(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$34(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$35(e, r$1, t) {
	return (r$1 = _toPropertyKey$35(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$35(t) {
	var i = _toPrimitive$35(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$35(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$22(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$22(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$22(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var eps = 1e-5;
var COS_45 = Math.cos(degreeToRadian(45));
/**
* These are injected from Redux, are required, but cannot be set by user.
*/
var AXIS_TYPE = "angleAxis";
function SetAngleAxisSettings(props) {
	var dispatch = useAppDispatch();
	var settings = (0, import_react.useMemo)(() => {
		var { children } = props;
		return _objectWithoutProperties$22(props, _excluded$22);
	}, [props]);
	var synchronizedSettings = useAppSelector((state) => selectAngleAxis(state, settings.id));
	var settingsAreSynchronized = settings === synchronizedSettings;
	(0, import_react.useEffect)(() => {
		dispatch(addAngleAxis(settings));
		return () => {
			dispatch(removeAngleAxis(settings));
		};
	}, [dispatch, settings]);
	if (settingsAreSynchronized) return props.children;
	return null;
}
/**
* Calculate the coordinate of line endpoint
* @param data The data if there are ticks
* @param props axis settings
* @return (x1, y1): The point close to text,
*         (x2, y2): The point close to axis
*/
var getTickLineCoord$1 = (data, props) => {
	var { cx, cy, radius, orientation, tickSize } = props;
	var tickLineSize = tickSize || 8;
	var p1 = polarToCartesian(cx, cy, radius, data.coordinate);
	var p2 = polarToCartesian(cx, cy, radius + (orientation === "inner" ? -1 : 1) * tickLineSize, data.coordinate);
	return {
		x1: p1.x,
		y1: p1.y,
		x2: p2.x,
		y2: p2.y
	};
};
/**
* Get the text-anchor of each tick
* @param data Data of ticks
* @param orientation of the axis ticks
* @return text-anchor
*/
var getTickTextAnchor$1 = (data, orientation) => {
	var cos$1 = Math.cos(degreeToRadian(-data.coordinate));
	if (cos$1 > eps) return orientation === "outer" ? "start" : "end";
	if (cos$1 < -eps) return orientation === "outer" ? "end" : "start";
	return "middle";
};
/**
* Get the text vertical anchor of each tick
* @param data Data of a tick
* @return text vertical anchor
*/
var getTickTextVerticalAnchor = (data) => {
	var cos$1 = Math.cos(degreeToRadian(-data.coordinate));
	var sin$1 = Math.sin(degreeToRadian(-data.coordinate));
	if (Math.abs(cos$1) <= COS_45) return sin$1 > 0 ? "start" : "end";
	return "middle";
};
var AxisLine$1 = (props) => {
	var { cx, cy, radius, axisLineType, axisLine, ticks: ticks$1 } = props;
	if (!axisLine) return null;
	var axisLineProps = _objectSpread$34(_objectSpread$34({}, svgPropertiesNoEvents(props)), {}, { fill: "none" }, svgPropertiesNoEvents(axisLine));
	if (axisLineType === "circle") return /* @__PURE__ */ import_react.createElement(Dot, _extends$29({ className: "recharts-polar-angle-axis-line" }, axisLineProps, {
		cx,
		cy,
		r: radius
	}));
	var points = ticks$1.map((entry) => polarToCartesian(cx, cy, radius, entry.coordinate));
	return /* @__PURE__ */ import_react.createElement(Polygon, _extends$29({ className: "recharts-polar-angle-axis-line" }, axisLineProps, { points }));
};
var TickItemText = (_ref$1) => {
	var { tick, tickProps, value } = _ref$1;
	if (!tick) return null;
	if (/* @__PURE__ */ import_react.isValidElement(tick)) return /* @__PURE__ */ import_react.cloneElement(tick, tickProps);
	if (typeof tick === "function") return tick(tickProps);
	return /* @__PURE__ */ import_react.createElement(Text, _extends$29({}, tickProps, { className: "recharts-polar-angle-axis-tick-value" }), value);
};
var Ticks$1 = (props) => {
	var { tick, tickLine, tickFormatter, stroke, ticks: ticks$1 } = props;
	var axisProps = svgPropertiesNoEvents(props);
	var customTickProps = svgPropertiesNoEventsFromUnknown(tick);
	var tickLineProps = _objectSpread$34(_objectSpread$34({}, axisProps), {}, { fill: "none" }, svgPropertiesNoEvents(tickLine));
	var items = ticks$1.map((entry, i) => {
		var lineCoord = getTickLineCoord$1(entry, props);
		var textAnchor = getTickTextAnchor$1(entry, props.orientation);
		var verticalAnchor = getTickTextVerticalAnchor(entry);
		var tickProps = _objectSpread$34(_objectSpread$34(_objectSpread$34({}, axisProps), {}, {
			textAnchor,
			verticalAnchor,
			stroke: "none",
			fill: stroke
		}, customTickProps), {}, {
			index: i,
			payload: entry,
			x: lineCoord.x2,
			y: lineCoord.y2
		});
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$29({
			className: clsx("recharts-polar-angle-axis-tick", getTickClassName(tick)),
			key: "tick-".concat(entry.coordinate)
		}, adaptEventsOfChild(props, entry, i)), tickLine && /* @__PURE__ */ import_react.createElement("line", _extends$29({ className: "recharts-polar-angle-axis-tick-line" }, tickLineProps, lineCoord)), /* @__PURE__ */ import_react.createElement(TickItemText, {
			tick,
			tickProps,
			value: tickFormatter ? tickFormatter(entry.value, i) : entry.value
		}));
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-polar-angle-axis-ticks" }, items);
};
var PolarAngleAxisWrapper = (defaultsAndInputs) => {
	var { angleAxisId } = defaultsAndInputs;
	var viewBox = useAppSelector(selectPolarViewBox);
	var scale = useAppSelector((state) => selectPolarAxisScale(state, "angleAxis", angleAxisId));
	var isPanorama = useIsPanorama();
	var ticks$1 = useAppSelector((state) => selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama));
	if (viewBox == null || !ticks$1 || !ticks$1.length) return null;
	var props = _objectSpread$34(_objectSpread$34(_objectSpread$34({}, defaultsAndInputs), {}, { scale }, viewBox), {}, { radius: viewBox.outerRadius });
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx("recharts-polar-angle-axis", AXIS_TYPE, props.className) }, /* @__PURE__ */ import_react.createElement(AxisLine$1, _extends$29({}, props, { ticks: ticks$1 })), /* @__PURE__ */ import_react.createElement(Ticks$1, _extends$29({}, props, { ticks: ticks$1 })));
};
var PolarAngleAxis = class extends import_react.PureComponent {
	render() {
		if (this.props.radius <= 0) return null;
		return /* @__PURE__ */ import_react.createElement(SetAngleAxisSettings, {
			id: this.props.angleAxisId,
			scale: this.props.scale,
			type: this.props.type,
			dataKey: this.props.dataKey,
			unit: void 0,
			name: this.props.name,
			allowDuplicatedCategory: false,
			allowDataOverflow: false,
			reversed: this.props.reversed,
			includeHidden: false,
			allowDecimals: this.props.allowDecimals,
			tickCount: this.props.tickCount,
			ticks: this.props.ticks,
			tick: this.props.tick,
			domain: this.props.domain
		}, /* @__PURE__ */ import_react.createElement(PolarAngleAxisWrapper, this.props));
	}
};
_defineProperty$35(PolarAngleAxis, "displayName", "PolarAngleAxis");
_defineProperty$35(PolarAngleAxis, "axisType", AXIS_TYPE);
_defineProperty$35(PolarAngleAxis, "defaultProps", defaultPolarAngleAxisProps);

//#endregion
//#region node_modules/recharts/es6/state/selectors/pieSelectors.js
function ownKeys$33(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$33(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$33(Object(t), !0).forEach(function(r$2) {
			_defineProperty$34(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$33(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$34(e, r$1, t) {
	return (r$1 = _toPropertyKey$34(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$34(t) {
	var i = _toPrimitive$34(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$34(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var pickId$1 = (_state, id) => id;
var selectSynchronisedPieSettings = createSelector([selectUnfilteredPolarItems, pickId$1], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "pie").find((item) => item.id === id));
var emptyArray = [];
var pickCells$3 = (_state, _id, cells) => {
	if ((cells === null || cells === void 0 ? void 0 : cells.length) === 0) return emptyArray;
	return cells;
};
var selectDisplayedData = createSelector([
	selectChartDataAndAlwaysIgnoreIndexes,
	selectSynchronisedPieSettings,
	pickCells$3
], (_ref$1, pieSettings, cells) => {
	var { chartData } = _ref$1;
	if (pieSettings == null) return;
	var displayedData;
	if ((pieSettings === null || pieSettings === void 0 ? void 0 : pieSettings.data) != null && pieSettings.data.length > 0) displayedData = pieSettings.data;
	else displayedData = chartData;
	if ((!displayedData || !displayedData.length) && cells != null) displayedData = cells.map((cell) => _objectSpread$33(_objectSpread$33({}, pieSettings.presentationProps), cell.props));
	if (displayedData == null) return;
	return displayedData;
});
var selectPieLegend = createSelector([
	selectDisplayedData,
	selectSynchronisedPieSettings,
	pickCells$3
], (displayedData, pieSettings, cells) => {
	if (displayedData == null || pieSettings == null) return;
	return displayedData.map((entry, i) => {
		var _cells$i;
		var name = getValueByDataKey(entry, pieSettings.nameKey, pieSettings.name);
		var color$1;
		if (cells !== null && cells !== void 0 && (_cells$i = cells[i]) !== null && _cells$i !== void 0 && (_cells$i = _cells$i.props) !== null && _cells$i !== void 0 && _cells$i.fill) color$1 = cells[i].props.fill;
		else if (typeof entry === "object" && entry != null && "fill" in entry) color$1 = entry.fill;
		else color$1 = pieSettings.fill;
		return {
			value: getTooltipNameProp(name, pieSettings.dataKey),
			color: color$1,
			payload: entry,
			type: pieSettings.legendType
		};
	});
});
var selectPieSectors = createSelector([
	selectDisplayedData,
	selectSynchronisedPieSettings,
	pickCells$3,
	selectChartOffsetInternal
], (displayedData, pieSettings, cells, offset) => {
	if (pieSettings == null || displayedData == null) return;
	return computePieSectors({
		offset,
		pieSettings,
		displayedData,
		cells
	});
});

//#endregion
//#region node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = /* @__PURE__ */ __commonJS({ "node_modules/react-is/cjs/react-is.development.js": ((exports) => {
	(function() {
		function typeOf(object) {
			if ("object" === typeof object && null !== object) {
				var $$typeof = object.$$typeof;
				switch ($$typeof) {
					case REACT_ELEMENT_TYPE: switch (object = object.type, object) {
						case REACT_FRAGMENT_TYPE:
						case REACT_PROFILER_TYPE:
						case REACT_STRICT_MODE_TYPE:
						case REACT_SUSPENSE_TYPE:
						case REACT_SUSPENSE_LIST_TYPE:
						case REACT_VIEW_TRANSITION_TYPE: return object;
						default: switch (object = object && object.$$typeof, object) {
							case REACT_CONTEXT_TYPE:
							case REACT_FORWARD_REF_TYPE$1:
							case REACT_LAZY_TYPE:
							case REACT_MEMO_TYPE$1: return object;
							case REACT_CONSUMER_TYPE: return object;
							default: return $$typeof;
						}
					}
					case REACT_PORTAL_TYPE: return $$typeof;
				}
			}
		}
		var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE$1 = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE$1 = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
		exports.ContextConsumer = REACT_CONSUMER_TYPE;
		exports.ContextProvider = REACT_CONTEXT_TYPE;
		exports.Element = REACT_ELEMENT_TYPE;
		exports.ForwardRef = REACT_FORWARD_REF_TYPE$1;
		exports.Fragment = REACT_FRAGMENT_TYPE;
		exports.Lazy = REACT_LAZY_TYPE;
		exports.Memo = REACT_MEMO_TYPE$1;
		exports.Portal = REACT_PORTAL_TYPE;
		exports.Profiler = REACT_PROFILER_TYPE;
		exports.StrictMode = REACT_STRICT_MODE_TYPE;
		exports.Suspense = REACT_SUSPENSE_TYPE;
		exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
		exports.isContextConsumer = function(object) {
			return typeOf(object) === REACT_CONSUMER_TYPE;
		};
		exports.isContextProvider = function(object) {
			return typeOf(object) === REACT_CONTEXT_TYPE;
		};
		exports.isElement = function(object) {
			return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
		};
		exports.isForwardRef = function(object) {
			return typeOf(object) === REACT_FORWARD_REF_TYPE$1;
		};
		exports.isFragment = function(object) {
			return typeOf(object) === REACT_FRAGMENT_TYPE;
		};
		exports.isLazy = function(object) {
			return typeOf(object) === REACT_LAZY_TYPE;
		};
		exports.isMemo = function(object) {
			return typeOf(object) === REACT_MEMO_TYPE$1;
		};
		exports.isPortal = function(object) {
			return typeOf(object) === REACT_PORTAL_TYPE;
		};
		exports.isProfiler = function(object) {
			return typeOf(object) === REACT_PROFILER_TYPE;
		};
		exports.isStrictMode = function(object) {
			return typeOf(object) === REACT_STRICT_MODE_TYPE;
		};
		exports.isSuspense = function(object) {
			return typeOf(object) === REACT_SUSPENSE_TYPE;
		};
		exports.isSuspenseList = function(object) {
			return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
		};
		exports.isValidElementType = function(type) {
			return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE$1 || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE$1 || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? !0 : !1;
		};
		exports.typeOf = typeOf;
	})();
}) });

//#endregion
//#region node_modules/react-is/index.js
var require_react_is = /* @__PURE__ */ __commonJS({ "node_modules/react-is/index.js": ((exports, module) => {
	module.exports = require_react_is_development();
}) });

//#endregion
//#region node_modules/recharts/es6/util/ReactUtils.js
var import_get$5 = /* @__PURE__ */ __toESM(require_get());
var import_react_is = /* @__PURE__ */ __toESM(require_react_is());
/**
* @deprecated instead find another approach that does not depend on displayName.
* Get the display name of a component
* @param  {Object} Comp Specified Component
* @return {String}      Display name of Component
*/
var getDisplayName = (Comp) => {
	if (typeof Comp === "string") return Comp;
	if (!Comp) return "";
	return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
/**
* @deprecated instead find another approach that does not require reading React Elements from DOM.
*
* @param children do not use
* @return deprecated do not use
*/
var toArray = (children) => {
	if (children === lastChildren && Array.isArray(lastResult)) return lastResult;
	var result = [];
	import_react.Children.forEach(children, (child) => {
		if (isNullish(child)) return;
		if ((0, import_react_is.isFragment)(child)) result = result.concat(toArray(child.props.children));
		else result.push(child);
	});
	lastResult = result;
	lastChildren = children;
	return result;
};
/**
* @deprecated instead find another approach that does not require reading React Elements from DOM.
*
* Find and return all matched children by type.
* `type` must be a React.ComponentType
*
* @param children do not use
* @param type do not use
* @return deprecated do not use
*/
function findAllByType(children, type) {
	var result = [];
	var types = [];
	if (Array.isArray(type)) types = type.map((t) => getDisplayName(t));
	else types = [getDisplayName(type)];
	toArray(children).forEach((child) => {
		var childType = (0, import_get$5.default)(child, "type.displayName") || (0, import_get$5.default)(child, "type.name");
		if (types.indexOf(childType) !== -1) result.push(child);
	});
	return result;
}
var isClipDot = (dot) => {
	if (dot && typeof dot === "object" && "clipDot" in dot) return Boolean(dot.clipDot);
	return true;
};

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js
var require_isPlainObject$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isPlainObject.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isPlainObject$2(object) {
		if (typeof object !== "object") return false;
		if (object == null) return false;
		if (Object.getPrototypeOf(object) === null) return true;
		if (Object.prototype.toString.call(object) !== "[object Object]") {
			const tag = object[Symbol.toStringTag];
			if (tag == null) return false;
			if (!Object.getOwnPropertyDescriptor(object, Symbol.toStringTag)?.writable) return false;
			return object.toString() === `[object ${tag}]`;
		}
		let proto$1 = object;
		while (Object.getPrototypeOf(proto$1) !== null) proto$1 = Object.getPrototypeOf(proto$1);
		return Object.getPrototypeOf(object) === proto$1;
	}
	exports.isPlainObject = isPlainObject$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/isPlainObject.js
var require_isPlainObject = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/isPlainObject.js": ((exports, module) => {
	module.exports = require_isPlainObject$1().isPlainObject;
}) });

//#endregion
//#region node_modules/recharts/es6/shape/Trapezoid.js
var import_isPlainObject = /* @__PURE__ */ __toESM(require_isPlainObject());
function ownKeys$32(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$32(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$32(Object(t), !0).forEach(function(r$2) {
			_defineProperty$33(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$32(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$33(e, r$1, t) {
	return (r$1 = _toPropertyKey$33(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$33(t) {
	var i = _toPrimitive$33(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$33(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$28() {
	return _extends$28 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$28.apply(null, arguments);
}
var getTrapezoidPath = (x$1, y$1, upperWidth, lowerWidth, height) => {
	var widthGap = upperWidth - lowerWidth;
	var path$1 = "M ".concat(x$1, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth, ",").concat(y$1);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1 + upperWidth - widthGap / 2 - lowerWidth, ",").concat(y$1 + height);
	path$1 += "L ".concat(x$1, ",").concat(y$1, " Z");
	return path$1;
};
var defaultProps$7 = {
	x: 0,
	y: 0,
	upperWidth: 0,
	lowerWidth: 0,
	height: 0,
	isUpdateAnimationActive: false,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var Trapezoid = (outsideProps) => {
	var trapezoidProps = resolveDefaultProps(outsideProps, defaultProps$7);
	var { x: x$1, y: y$1, upperWidth, lowerWidth, height, className } = trapezoidProps;
	var { animationEasing, animationDuration, animationBegin, isUpdateAnimationActive } = trapezoidProps;
	var pathRef = (0, import_react.useRef)(null);
	var [totalLength, setTotalLength] = (0, import_react.useState)(-1);
	var prevUpperWidthRef = (0, import_react.useRef)(upperWidth);
	var prevLowerWidthRef = (0, import_react.useRef)(lowerWidth);
	var prevHeightRef = (0, import_react.useRef)(height);
	var prevXRef = (0, import_react.useRef)(x$1);
	var prevYRef = (0, import_react.useRef)(y$1);
	var animationId = useAnimationId(outsideProps, "trapezoid-");
	(0, import_react.useEffect)(() => {
		if (pathRef.current && pathRef.current.getTotalLength) try {
			var pathTotalLength = pathRef.current.getTotalLength();
			if (pathTotalLength) setTotalLength(pathTotalLength);
		} catch (_unused) {}
	}, []);
	if (x$1 !== +x$1 || y$1 !== +y$1 || upperWidth !== +upperWidth || lowerWidth !== +lowerWidth || height !== +height || upperWidth === 0 && lowerWidth === 0 || height === 0) return null;
	var layerClass = clsx("recharts-trapezoid", className);
	if (!isUpdateAnimationActive) return /* @__PURE__ */ import_react.createElement("g", null, /* @__PURE__ */ import_react.createElement("path", _extends$28({}, svgPropertiesAndEvents(trapezoidProps), {
		className: layerClass,
		d: getTrapezoidPath(x$1, y$1, upperWidth, lowerWidth, height)
	})));
	var prevUpperWidth = prevUpperWidthRef.current;
	var prevLowerWidth = prevLowerWidthRef.current;
	var prevHeight = prevHeightRef.current;
	var prevX = prevXRef.current;
	var prevY = prevYRef.current;
	var from$1 = "0px ".concat(totalLength === -1 ? 1 : totalLength, "px");
	var to$1 = "".concat(totalLength, "px 0px");
	var transition = getTransitionVal(["strokeDasharray"], animationDuration, animationEasing);
	return /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		key: animationId,
		canBegin: totalLength > 0,
		duration: animationDuration,
		easing: animationEasing,
		isActive: isUpdateAnimationActive,
		begin: animationBegin
	}, (t) => {
		var currUpperWidth = interpolate(prevUpperWidth, upperWidth, t);
		var currLowerWidth = interpolate(prevLowerWidth, lowerWidth, t);
		var currHeight = interpolate(prevHeight, height, t);
		var currX = interpolate(prevX, x$1, t);
		var currY = interpolate(prevY, y$1, t);
		if (pathRef.current) {
			prevUpperWidthRef.current = currUpperWidth;
			prevLowerWidthRef.current = currLowerWidth;
			prevHeightRef.current = currHeight;
			prevXRef.current = currX;
			prevYRef.current = currY;
		}
		var animationStyle = t > 0 ? {
			transition,
			strokeDasharray: to$1
		} : { strokeDasharray: from$1 };
		return /* @__PURE__ */ import_react.createElement("path", _extends$28({}, svgPropertiesAndEvents(trapezoidProps), {
			className: layerClass,
			d: getTrapezoidPath(currX, currY, currUpperWidth, currLowerWidth, currHeight),
			ref: pathRef,
			style: _objectSpread$32(_objectSpread$32({}, animationStyle), trapezoidProps.style)
		}));
	});
};

//#endregion
//#region node_modules/recharts/es6/util/ActiveShapeUtils.js
var _excluded$21 = [
	"option",
	"shapeType",
	"propTransformer",
	"activeClassName",
	"isActive"
];
function _objectWithoutProperties$21(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$21(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$21(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$31(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$31(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$31(Object(t), !0).forEach(function(r$2) {
			_defineProperty$32(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$31(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$32(e, r$1, t) {
	return (r$1 = _toPropertyKey$32(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$32(t) {
	var i = _toPrimitive$32(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$32(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* This is an abstraction for rendering a user defined prop for a customized shape in several forms.
*
* <Shape /> is the root and will handle taking in:
*  - an object of svg properties
*  - a boolean
*  - a render prop(inline function that returns jsx)
*  - a React element
*
* <ShapeSelector /> is a subcomponent of <Shape /> and used to match a component
* to the value of props.shapeType that is passed to the root.
*
*/
function defaultPropTransformer(option, props) {
	return _objectSpread$31(_objectSpread$31({}, props), option);
}
function isSymbolsProps(shapeType, _elementProps) {
	return shapeType === "symbols";
}
function ShapeSelector(_ref$1) {
	var { shapeType, elementProps } = _ref$1;
	switch (shapeType) {
		case "rectangle": return /* @__PURE__ */ import_react.createElement(Rectangle, elementProps);
		case "trapezoid": return /* @__PURE__ */ import_react.createElement(Trapezoid, elementProps);
		case "sector": return /* @__PURE__ */ import_react.createElement(Sector, elementProps);
		case "symbols":
			if (isSymbolsProps(shapeType, elementProps)) return /* @__PURE__ */ import_react.createElement(Symbols, elementProps);
			break;
		default: return null;
	}
}
function getPropsFromShapeOption(option) {
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) return option.props;
	return option;
}
function Shape(_ref2) {
	var { option, shapeType, propTransformer = defaultPropTransformer, activeClassName = "recharts-active-shape", isActive } = _ref2, props = _objectWithoutProperties$21(_ref2, _excluded$21);
	var shape;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(option)) shape = /* @__PURE__ */ (0, import_react.cloneElement)(option, _objectSpread$31(_objectSpread$31({}, props), getPropsFromShapeOption(option)));
	else if (typeof option === "function") shape = option(props);
	else if ((0, import_isPlainObject.default)(option) && typeof option !== "boolean") {
		var nextProps = propTransformer(option, props);
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps: nextProps
		});
	} else {
		var elementProps = props;
		shape = /* @__PURE__ */ import_react.createElement(ShapeSelector, {
			shapeType,
			elementProps
		});
	}
	if (isActive) return /* @__PURE__ */ import_react.createElement(Layer, { className: activeClassName }, shape);
	return shape;
}

//#endregion
//#region node_modules/recharts/es6/context/tooltipContext.js
var useMouseEnterItemDispatch = (onMouseEnterFromProps, dataKey) => {
	var dispatch = useAppDispatch();
	return (data, index) => (event) => {
		onMouseEnterFromProps === null || onMouseEnterFromProps === void 0 || onMouseEnterFromProps(data, index, event);
		dispatch(setActiveMouseOverItemIndex({
			activeIndex: String(index),
			activeDataKey: dataKey,
			activeCoordinate: data.tooltipPosition
		}));
	};
};
var useMouseLeaveItemDispatch = (onMouseLeaveFromProps) => {
	var dispatch = useAppDispatch();
	return (data, index) => (event) => {
		onMouseLeaveFromProps === null || onMouseLeaveFromProps === void 0 || onMouseLeaveFromProps(data, index, event);
		dispatch(mouseLeaveItem());
	};
};
var useMouseClickItemDispatch = (onMouseClickFromProps, dataKey) => {
	var dispatch = useAppDispatch();
	return (data, index) => (event) => {
		onMouseClickFromProps === null || onMouseClickFromProps === void 0 || onMouseClickFromProps(data, index, event);
		dispatch(setActiveClickItemIndex({
			activeIndex: String(index),
			activeDataKey: dataKey,
			activeCoordinate: data.tooltipPosition
		}));
	};
};

//#endregion
//#region node_modules/recharts/es6/state/SetTooltipEntrySettings.js
function SetTooltipEntrySettings(_ref$1) {
	var { fn, args } = _ref$1;
	var dispatch = useAppDispatch();
	var isPanorama = useIsPanorama();
	(0, import_react.useLayoutEffect)(() => {
		if (isPanorama) return;
		var tooltipEntrySettings = fn(args);
		dispatch(addTooltipEntrySettings(tooltipEntrySettings));
		return () => {
			dispatch(removeTooltipEntrySettings(tooltipEntrySettings));
		};
	}, [
		fn,
		args,
		dispatch,
		isPanorama
	]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/state/SetLegendPayload.js
var noop$1 = () => {};
function SetLegendPayload(_ref$1) {
	var { legendPayload } = _ref$1;
	var dispatch = useAppDispatch();
	var isPanorama = useIsPanorama();
	(0, import_react.useLayoutEffect)(() => {
		if (isPanorama) return noop$1;
		dispatch(addLegendPayload(legendPayload));
		return () => {
			dispatch(removeLegendPayload(legendPayload));
		};
	}, [
		dispatch,
		isPanorama,
		legendPayload
	]);
	return null;
}
function SetPolarLegendPayload(_ref2) {
	var { legendPayload } = _ref2;
	var dispatch = useAppDispatch();
	var layout = useAppSelector(selectChartLayout);
	(0, import_react.useLayoutEffect)(() => {
		if (layout !== "centric" && layout !== "radial") return noop$1;
		dispatch(addLegendPayload(legendPayload));
		return () => {
			dispatch(removeLegendPayload(legendPayload));
		};
	}, [
		dispatch,
		layout,
		legendPayload
	]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/util/useId.js
var _ref;
/**
* Fallback for React.useId() for versions prior to React 18.
* Generates a unique ID using a simple counter and a prefix.
*
* @returns A unique ID that remains consistent across renders.
*/
var useIdFallback = () => {
	var [id] = import_react.useState(() => uniqueId("uid-"));
	return id;
};
var useId = (_ref = import_react["useId".toString()]) !== null && _ref !== void 0 ? _ref : useIdFallback;

//#endregion
//#region node_modules/recharts/es6/util/useUniqueId.js
/**
* A hook that generates a unique ID. It uses React.useId() in React 18+ for SSR safety
* and falls back to a client-side-only unique ID generator for older versions.
*
* The ID will stay the same across renders, and you can optionally provide a prefix.
*
* @param [prefix] - An optional prefix for the generated ID.
* @param [customId] - An optional custom ID to override the generated one.
* @returns The unique ID.
*/
function useUniqueId(prefix$2, customId) {
	var generatedId = useId();
	if (customId) return customId;
	return prefix$2 ? "".concat(prefix$2, "-").concat(generatedId) : generatedId;
}
/**
* The useUniqueId hook returns a unique ID that is either reused from external props or generated internally.
* Either way the ID is now guaranteed to be present so no more nulls or undefined.
*/
//#endregion
//#region node_modules/recharts/es6/context/RegisterGraphicalItemId.js
var GraphicalItemIdContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
var RegisterGraphicalItemId = (_ref$1) => {
	var { id, type, children } = _ref$1;
	var resolvedId = useUniqueId("recharts-".concat(type), id);
	return /* @__PURE__ */ import_react.createElement(GraphicalItemIdContext.Provider, { value: resolvedId }, children(resolvedId));
};
function useGraphicalItemId() {
	return (0, import_react.useContext)(GraphicalItemIdContext);
}

//#endregion
//#region node_modules/recharts/es6/state/graphicalItemsSlice.js
var graphicalItemsSlice = createSlice({
	name: "graphicalItems",
	initialState: {
		cartesianItems: [],
		polarItems: []
	},
	reducers: {
		addCartesianGraphicalItem: {
			reducer(state, action) {
				state.cartesianItems.push(castDraft(action.payload));
			},
			prepare: prepareAutoBatched()
		},
		replaceCartesianGraphicalItem: {
			reducer(state, action) {
				var { prev, next } = action.payload;
				var index = current(state).cartesianItems.indexOf(castDraft(prev));
				if (index > -1) state.cartesianItems[index] = castDraft(next);
			},
			prepare: prepareAutoBatched()
		},
		removeCartesianGraphicalItem: {
			reducer(state, action) {
				var index = current(state).cartesianItems.indexOf(castDraft(action.payload));
				if (index > -1) state.cartesianItems.splice(index, 1);
			},
			prepare: prepareAutoBatched()
		},
		addPolarGraphicalItem: {
			reducer(state, action) {
				state.polarItems.push(castDraft(action.payload));
			},
			prepare: prepareAutoBatched()
		},
		removePolarGraphicalItem: {
			reducer(state, action) {
				var index = current(state).polarItems.indexOf(castDraft(action.payload));
				if (index > -1) state.polarItems.splice(index, 1);
			},
			prepare: prepareAutoBatched()
		}
	}
});
var { addCartesianGraphicalItem, replaceCartesianGraphicalItem, removeCartesianGraphicalItem, addPolarGraphicalItem, removePolarGraphicalItem } = graphicalItemsSlice.actions;
var graphicalItemsReducer = graphicalItemsSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/state/SetGraphicalItem.js
function SetCartesianGraphicalItem(props) {
	var dispatch = useAppDispatch();
	var prevPropsRef = (0, import_react.useRef)(null);
	(0, import_react.useLayoutEffect)(() => {
		if (prevPropsRef.current === null) dispatch(addCartesianGraphicalItem(props));
		else if (prevPropsRef.current !== props) dispatch(replaceCartesianGraphicalItem({
			prev: prevPropsRef.current,
			next: props
		}));
		prevPropsRef.current = props;
	}, [dispatch, props]);
	(0, import_react.useLayoutEffect)(() => {
		return () => {
			if (prevPropsRef.current) {
				dispatch(removeCartesianGraphicalItem(prevPropsRef.current));
				prevPropsRef.current = null;
			}
		};
	}, [dispatch]);
	return null;
}
function SetPolarGraphicalItem(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useLayoutEffect)(() => {
		dispatch(addPolarGraphicalItem(props));
		return () => {
			dispatch(removePolarGraphicalItem(props));
		};
	}, [dispatch, props]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/polar/Pie.js
var import_get$4 = /* @__PURE__ */ __toESM(require_get());
var _excluded$20 = [
	"onMouseEnter",
	"onClick",
	"onMouseLeave"
], _excluded2$11 = ["id"], _excluded3$8 = ["id"];
function _objectWithoutProperties$20(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$20(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$20(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$30(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$30(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$30(Object(t), !0).forEach(function(r$2) {
			_defineProperty$31(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$30(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$31(e, r$1, t) {
	return (r$1 = _toPropertyKey$31(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$31(t) {
	var i = _toPrimitive$31(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$31(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$27() {
	return _extends$27 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$27.apply(null, arguments);
}
/**
* The `label` prop in Pie accepts a variety of alternatives.
*/
/**
* Internal props, combination of external props + defaultProps + private Recharts state
*/
function SetPiePayloadLegend(props) {
	var cells = (0, import_react.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
	var legendPayload = useAppSelector((state) => selectPieLegend(state, props.id, cells));
	if (legendPayload == null) return null;
	return /* @__PURE__ */ import_react.createElement(SetPolarLegendPayload, { legendPayload });
}
function getTooltipEntrySettings$10(props) {
	var { dataKey, nameKey, sectors, stroke, strokeWidth, fill, name, hide, tooltipType } = props;
	return {
		dataDefinedOnItem: sectors.map((p) => p.tooltipPayload),
		positions: sectors.map((p) => p.tooltipPosition),
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			nameKey,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: tooltipType,
			color: fill,
			unit: ""
		}
	};
}
var getTextAnchor = (x$1, cx) => {
	if (x$1 > cx) return "start";
	if (x$1 < cx) return "end";
	return "middle";
};
var getOuterRadius = (dataPoint, outerRadius, maxPieRadius) => {
	if (typeof outerRadius === "function") return getPercentValue(outerRadius(dataPoint), maxPieRadius, maxPieRadius * .8);
	return getPercentValue(outerRadius, maxPieRadius, maxPieRadius * .8);
};
var parseCoordinateOfPie = (pieSettings, offset, dataPoint) => {
	var { top, left, width, height } = offset;
	var maxPieRadius = getMaxRadius(width, height);
	var cx = left + getPercentValue(pieSettings.cx, width, width / 2);
	var cy = top + getPercentValue(pieSettings.cy, height, height / 2);
	var innerRadius = getPercentValue(pieSettings.innerRadius, maxPieRadius, 0);
	var outerRadius = getOuterRadius(dataPoint, pieSettings.outerRadius, maxPieRadius);
	var maxRadius = pieSettings.maxRadius || Math.sqrt(width * width + height * height) / 2;
	return {
		cx,
		cy,
		innerRadius,
		outerRadius,
		maxRadius
	};
};
var parseDeltaAngle = (startAngle, endAngle) => {
	var sign$1 = mathSign(endAngle - startAngle);
	var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
	return sign$1 * deltaAngle;
};
function getClassNamePropertyIfExists(u) {
	if (u && typeof u === "object" && "className" in u && typeof u.className === "string") return u.className;
	return "";
}
var renderLabelLineItem = (option, props) => {
	if (/* @__PURE__ */ import_react.isValidElement(option)) return /* @__PURE__ */ import_react.cloneElement(option, props);
	if (typeof option === "function") return option(props);
	var className = clsx("recharts-pie-label-line", typeof option !== "boolean" ? option.className : "");
	return /* @__PURE__ */ import_react.createElement(Curve, _extends$27({}, props, {
		type: "linear",
		className
	}));
};
var renderLabelItem = (option, props, value) => {
	if (/* @__PURE__ */ import_react.isValidElement(option)) return /* @__PURE__ */ import_react.cloneElement(option, props);
	var label = value;
	if (typeof option === "function") {
		label = option(props);
		if (/* @__PURE__ */ import_react.isValidElement(label)) return label;
	}
	var className = clsx("recharts-pie-label-text", getClassNamePropertyIfExists(option));
	return /* @__PURE__ */ import_react.createElement(Text, _extends$27({}, props, {
		alignmentBaseline: "middle",
		className
	}), label);
};
function PieLabels(_ref$1) {
	var { sectors, props, showLabels } = _ref$1;
	var { label, labelLine, dataKey } = props;
	if (!showLabels || !label || !sectors) return null;
	var pieProps = svgPropertiesNoEvents(props);
	var customLabelProps = svgPropertiesNoEventsFromUnknown(label);
	var customLabelLineProps = svgPropertiesNoEventsFromUnknown(labelLine);
	var offsetRadius = typeof label === "object" && "offsetRadius" in label && typeof label.offsetRadius === "number" && label.offsetRadius || 20;
	var labels = sectors.map((entry, i) => {
		var midAngle = (entry.startAngle + entry.endAngle) / 2;
		var endPoint = polarToCartesian(entry.cx, entry.cy, entry.outerRadius + offsetRadius, midAngle);
		var labelProps = _objectSpread$30(_objectSpread$30(_objectSpread$30(_objectSpread$30({}, pieProps), entry), {}, { stroke: "none" }, customLabelProps), {}, {
			index: i,
			textAnchor: getTextAnchor(endPoint.x, entry.cx)
		}, endPoint);
		var lineProps = _objectSpread$30(_objectSpread$30(_objectSpread$30(_objectSpread$30({}, pieProps), entry), {}, {
			fill: "none",
			stroke: entry.fill
		}, customLabelLineProps), {}, {
			index: i,
			points: [polarToCartesian(entry.cx, entry.cy, entry.outerRadius, midAngle), endPoint],
			key: "line"
		});
		return /* @__PURE__ */ import_react.createElement(Layer, { key: "label-".concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(entry.midAngle, "-").concat(i) }, labelLine && renderLabelLineItem(labelLine, lineProps), renderLabelItem(label, labelProps, getValueByDataKey(entry, dataKey)));
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-pie-labels" }, labels);
}
function PieLabelList(_ref2) {
	var { sectors, props, showLabels } = _ref2;
	var { label } = props;
	if (typeof label === "object" && label != null && "position" in label) return /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label });
	return /* @__PURE__ */ import_react.createElement(PieLabels, {
		sectors,
		props,
		showLabels
	});
}
function PieSectors(props) {
	var { sectors, activeShape, inactiveShape: inactiveShapeProp, allOtherPieProps } = props;
	var activeIndex = useAppSelector(selectActiveTooltipIndex);
	var { onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps } = allOtherPieProps, restOfAllOtherProps = _objectWithoutProperties$20(allOtherPieProps, _excluded$20);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherPieProps.dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherPieProps.dataKey);
	if (sectors == null || sectors.length === 0) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, sectors.map((entry, i) => {
		if ((entry === null || entry === void 0 ? void 0 : entry.startAngle) === 0 && (entry === null || entry === void 0 ? void 0 : entry.endAngle) === 0 && sectors.length !== 1) return null;
		var isSectorActive = activeShape && String(i) === activeIndex;
		var sectorOptions = isSectorActive ? activeShape : activeIndex ? inactiveShapeProp : null;
		var sectorProps = _objectSpread$30(_objectSpread$30({}, entry), {}, {
			stroke: entry.stroke,
			tabIndex: -1,
			[DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
			[DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: allOtherPieProps.dataKey
		});
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$27({
			key: "sector-".concat(entry === null || entry === void 0 ? void 0 : entry.startAngle, "-").concat(entry === null || entry === void 0 ? void 0 : entry.endAngle, "-").concat(entry.midAngle, "-").concat(i),
			tabIndex: -1,
			className: "recharts-pie-sector"
		}, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
			onMouseEnter: onMouseEnterFromContext(entry, i),
			onMouseLeave: onMouseLeaveFromContext(entry, i),
			onClick: onClickFromContext(entry, i)
		}), /* @__PURE__ */ import_react.createElement(Shape, _extends$27({
			option: sectorOptions,
			isActive: isSectorActive,
			shapeType: "sector"
		}, sectorProps)));
	}));
}
function computePieSectors(_ref3) {
	var _pieSettings$paddingA;
	var { pieSettings, displayedData, cells, offset } = _ref3;
	var { cornerRadius, startAngle, endAngle, dataKey, nameKey, tooltipType } = pieSettings;
	var minAngle = Math.abs(pieSettings.minAngle);
	var deltaAngle = parseDeltaAngle(startAngle, endAngle);
	var absDeltaAngle = Math.abs(deltaAngle);
	var paddingAngle = displayedData.length <= 1 ? 0 : (_pieSettings$paddingA = pieSettings.paddingAngle) !== null && _pieSettings$paddingA !== void 0 ? _pieSettings$paddingA : 0;
	var notZeroItemCount = displayedData.filter((entry) => getValueByDataKey(entry, dataKey, 0) !== 0).length;
	var totalPaddingAngle = (absDeltaAngle >= 360 ? notZeroItemCount : notZeroItemCount - 1) * paddingAngle;
	var realTotalAngle = absDeltaAngle - notZeroItemCount * minAngle - totalPaddingAngle;
	var sum = displayedData.reduce((result, entry) => {
		var val = getValueByDataKey(entry, dataKey, 0);
		return result + (isNumber(val) ? val : 0);
	}, 0);
	var sectors;
	if (sum > 0) {
		var prev;
		sectors = displayedData.map((entry, i) => {
			var val = getValueByDataKey(entry, dataKey, 0);
			var name = getValueByDataKey(entry, nameKey, i);
			var coordinate = parseCoordinateOfPie(pieSettings, offset, entry);
			var percent = (isNumber(val) ? val : 0) / sum;
			var tempStartAngle;
			var entryWithCellInfo = _objectSpread$30(_objectSpread$30({}, entry), cells && cells[i] && cells[i].props);
			if (i) tempStartAngle = prev.endAngle + mathSign(deltaAngle) * paddingAngle * (val !== 0 ? 1 : 0);
			else tempStartAngle = startAngle;
			var tempEndAngle = tempStartAngle + mathSign(deltaAngle) * ((val !== 0 ? minAngle : 0) + percent * realTotalAngle);
			var midAngle = (tempStartAngle + tempEndAngle) / 2;
			var middleRadius = (coordinate.innerRadius + coordinate.outerRadius) / 2;
			var tooltipPayload = [{
				name,
				value: val,
				payload: entryWithCellInfo,
				dataKey,
				type: tooltipType
			}];
			var tooltipPosition = polarToCartesian(coordinate.cx, coordinate.cy, middleRadius, midAngle);
			prev = _objectSpread$30(_objectSpread$30(_objectSpread$30(_objectSpread$30({}, pieSettings.presentationProps), {}, {
				percent,
				cornerRadius,
				name,
				tooltipPayload,
				midAngle,
				middleRadius,
				tooltipPosition
			}, entryWithCellInfo), coordinate), {}, {
				value: val,
				startAngle: tempStartAngle,
				endAngle: tempEndAngle,
				payload: entryWithCellInfo,
				paddingAngle: mathSign(deltaAngle) * paddingAngle
			});
			return prev;
		});
	}
	return sectors;
}
function PieLabelListProvider(_ref4) {
	var { showLabels, sectors, children } = _ref4;
	var labelListEntries = (0, import_react.useMemo)(() => {
		if (!showLabels || !sectors) return [];
		return sectors.map((entry) => ({
			value: entry.value,
			payload: entry.payload,
			clockWise: false,
			parentViewBox: void 0,
			viewBox: {
				cx: entry.cx,
				cy: entry.cy,
				innerRadius: entry.innerRadius,
				outerRadius: entry.outerRadius,
				startAngle: entry.startAngle,
				endAngle: entry.endAngle,
				clockWise: false
			},
			fill: entry.fill
		}));
	}, [sectors, showLabels]);
	return /* @__PURE__ */ import_react.createElement(PolarLabelListContextProvider, { value: showLabels ? labelListEntries : void 0 }, children);
}
function SectorsWithAnimation$1(_ref5) {
	var { props, previousSectorsRef } = _ref5;
	var { sectors, isAnimationActive, animationBegin, animationDuration, animationEasing, activeShape, inactiveShape, onAnimationStart, onAnimationEnd } = props;
	var animationId = useAnimationId(props, "recharts-pie-");
	var prevSectors = previousSectorsRef.current;
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(PieLabelListProvider, {
		showLabels: !isAnimating,
		sectors
	}, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationStart: handleAnimationStart,
		onAnimationEnd: handleAnimationEnd,
		key: animationId
	}, (t) => {
		var stepData = [];
		var first = sectors && sectors[0];
		var curAngle = first === null || first === void 0 ? void 0 : first.startAngle;
		sectors === null || sectors === void 0 || sectors.forEach((entry, index) => {
			var prev = prevSectors && prevSectors[index];
			var paddingAngle = index > 0 ? (0, import_get$4.default)(entry, "paddingAngle", 0) : 0;
			if (prev) {
				var angle = interpolate(prev.endAngle - prev.startAngle, entry.endAngle - entry.startAngle, t);
				var latest$1 = _objectSpread$30(_objectSpread$30({}, entry), {}, {
					startAngle: curAngle + paddingAngle,
					endAngle: curAngle + angle + paddingAngle
				});
				stepData.push(latest$1);
				curAngle = latest$1.endAngle;
			} else {
				var { endAngle, startAngle } = entry;
				var deltaAngle = interpolate(0, endAngle - startAngle, t);
				var _latest = _objectSpread$30(_objectSpread$30({}, entry), {}, {
					startAngle: curAngle + paddingAngle,
					endAngle: curAngle + deltaAngle + paddingAngle
				});
				stepData.push(_latest);
				curAngle = _latest.endAngle;
			}
		});
		previousSectorsRef.current = stepData;
		return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement(PieSectors, {
			sectors: stepData,
			activeShape,
			inactiveShape,
			allOtherPieProps: props
		}));
	}), /* @__PURE__ */ import_react.createElement(PieLabelList, {
		showLabels: !isAnimating,
		sectors,
		props
	}), props.children);
}
var defaultPieProps = {
	animationBegin: 400,
	animationDuration: 1500,
	animationEasing: "ease",
	cx: "50%",
	cy: "50%",
	dataKey: "value",
	endAngle: 360,
	fill: "#808080",
	hide: false,
	innerRadius: 0,
	isAnimationActive: !Global.isSsr,
	labelLine: true,
	legendType: "rect",
	minAngle: 0,
	nameKey: "name",
	outerRadius: "80%",
	paddingAngle: 0,
	rootTabIndex: 0,
	startAngle: 0,
	stroke: "#fff"
};
function PieImpl(props) {
	var { id } = props, propsWithoutId = _objectWithoutProperties$20(props, _excluded2$11);
	var { hide, className, rootTabIndex } = props;
	var cells = (0, import_react.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
	var sectors = useAppSelector((state) => selectPieSectors(state, id, cells));
	var previousSectorsRef = (0, import_react.useRef)(null);
	var layerClass = clsx("recharts-pie", className);
	if (hide || sectors == null) {
		previousSectorsRef.current = null;
		return /* @__PURE__ */ import_react.createElement(Layer, {
			tabIndex: rootTabIndex,
			className: layerClass
		});
	}
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$10,
		args: _objectSpread$30(_objectSpread$30({}, props), {}, { sectors })
	}), /* @__PURE__ */ import_react.createElement(Layer, {
		tabIndex: rootTabIndex,
		className: layerClass
	}, /* @__PURE__ */ import_react.createElement(SectorsWithAnimation$1, {
		props: _objectSpread$30(_objectSpread$30({}, propsWithoutId), {}, { sectors }),
		previousSectorsRef
	})));
}
function Pie(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultPieProps);
	var { id: externalId } = props, propsWithoutId = _objectWithoutProperties$20(props, _excluded3$8);
	var presentationProps = svgPropertiesNoEvents(propsWithoutId);
	return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
		id: externalId,
		type: "pie"
	}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetPolarGraphicalItem, {
		type: "pie",
		id,
		data: propsWithoutId.data,
		dataKey: propsWithoutId.dataKey,
		hide: propsWithoutId.hide,
		angleAxisId: 0,
		radiusAxisId: 0,
		name: propsWithoutId.name,
		nameKey: propsWithoutId.nameKey,
		tooltipType: propsWithoutId.tooltipType,
		legendType: propsWithoutId.legendType,
		fill: propsWithoutId.fill,
		cx: propsWithoutId.cx,
		cy: propsWithoutId.cy,
		startAngle: propsWithoutId.startAngle,
		endAngle: propsWithoutId.endAngle,
		paddingAngle: propsWithoutId.paddingAngle,
		minAngle: propsWithoutId.minAngle,
		innerRadius: propsWithoutId.innerRadius,
		outerRadius: propsWithoutId.outerRadius,
		cornerRadius: propsWithoutId.cornerRadius,
		presentationProps,
		maxRadius: props.maxRadius
	}), /* @__PURE__ */ import_react.createElement(SetPiePayloadLegend, _extends$27({}, propsWithoutId, { id })), /* @__PURE__ */ import_react.createElement(PieImpl, _extends$27({}, propsWithoutId, { id }))));
}
Pie.displayName = "Pie";

//#endregion
//#region node_modules/recharts/es6/state/cartesianAxisSlice.js
function ownKeys$29(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$29(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$29(Object(t), !0).forEach(function(r$2) {
			_defineProperty$30(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$29(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$30(e, r$1, t) {
	return (r$1 = _toPropertyKey$30(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$30(t) {
	var i = _toPrimitive$30(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$30(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var defaultAxisId = 0;
/**
* This is the slice where each individual Axis element pushes its own configuration.
* Prefer to use this one instead of axisSlice.
*/
var cartesianAxisSlice = createSlice({
	name: "cartesianAxis",
	initialState: {
		xAxis: {},
		yAxis: {},
		zAxis: {}
	},
	reducers: {
		addXAxis: {
			reducer(state, action) {
				state.xAxis[action.payload.id] = castDraft(action.payload);
			},
			prepare: prepareAutoBatched()
		},
		removeXAxis: {
			reducer(state, action) {
				delete state.xAxis[action.payload.id];
			},
			prepare: prepareAutoBatched()
		},
		addYAxis: {
			reducer(state, action) {
				state.yAxis[action.payload.id] = castDraft(action.payload);
			},
			prepare: prepareAutoBatched()
		},
		removeYAxis: {
			reducer(state, action) {
				delete state.yAxis[action.payload.id];
			},
			prepare: prepareAutoBatched()
		},
		addZAxis: {
			reducer(state, action) {
				state.zAxis[action.payload.id] = castDraft(action.payload);
			},
			prepare: prepareAutoBatched()
		},
		removeZAxis: {
			reducer(state, action) {
				delete state.zAxis[action.payload.id];
			},
			prepare: prepareAutoBatched()
		},
		updateYAxisWidth(state, action) {
			var { id, width } = action.payload;
			var axis = state.yAxis[id];
			if (axis) {
				var history = axis.widthHistory || [];
				if (history.length === 3 && history[0] === history[2] && width === history[1] && width !== axis.width && Math.abs(width - history[0]) <= 1) return;
				var newHistory = [...history, width].slice(-3);
				state.yAxis[id] = _objectSpread$29(_objectSpread$29({}, state.yAxis[id]), {}, {
					width,
					widthHistory: newHistory
				});
			}
		}
	}
});
var { addXAxis, removeXAxis, addYAxis, removeYAxis, addZAxis, removeZAxis, updateYAxisWidth } = cartesianAxisSlice.actions;
var cartesianAxisReducer = cartesianAxisSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectChartOffset.js
var selectChartOffset = createSelector([selectChartOffsetInternal], (offsetInternal) => {
	if (!offsetInternal) return;
	return {
		top: offsetInternal.top,
		bottom: offsetInternal.bottom,
		left: offsetInternal.left,
		right: offsetInternal.right
	};
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectPlotArea.js
var selectPlotArea = createSelector([
	selectChartOffset,
	selectChartWidth,
	selectChartHeight
], (offset, chartWidth, chartHeight) => {
	if (!offset || chartWidth == null || chartHeight == null) return;
	return {
		x: offset.left,
		y: offset.top,
		width: Math.max(0, chartWidth - offset.left - offset.right),
		height: Math.max(0, chartHeight - offset.top - offset.bottom)
	};
});

//#endregion
//#region node_modules/recharts/es6/hooks.js
var useXAxis = (xAxisId) => {
	var isPanorama = useIsPanorama();
	return useAppSelector((state) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama));
};
var useYAxis = (yAxisId) => {
	var isPanorama = useIsPanorama();
	return useAppSelector((state) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama));
};
/**
* Returns the active tooltip label. The label is one of the values from the chart data,
* and is used to display in the tooltip content.
*
* Returns undefined if there is no active user interaction or if used outside a chart context
*
* @returns string | undefined
*/
var useActiveTooltipLabel = () => {
	return useAppSelector(selectActiveLabel);
};
/**
* Offset defines the blank space between the chart and the plot area.
* This blank space is occupied by supporting elements like axes, legends, and brushes.
* This also includes any margins that might be applied to the chart.
* If you are interested in the margin alone, use `useMargin` instead.
*
* @returns Offset of the chart in pixels, or undefined if used outside a chart context.
*/
var useOffset = () => {
	return useAppSelector(selectChartOffset);
};
/**
* Plot area is the area where the actual chart data is rendered.
* This means: bars, lines, scatter points, etc.
*
* The plot area is calculated based on the chart dimensions and the offset.
*
* @returns Plot area of the chart in pixels, or undefined if used outside a chart context.
*/
var usePlotArea = () => {
	return useAppSelector(selectPlotArea);
};
/**
* Returns the currently active data points being displayed in the Tooltip.
* Active means that it is currently visible; this hook will return `undefined` if there is no current interaction.
*
* This follows the `<Tooltip />` props, if the Tooltip element is present in the chart.
* If there is no `<Tooltip />` then this hook will follow the default Tooltip props.
*
* Data point is whatever you pass as an input to the chart using the `data={}` prop.
*
* This returns an array because a chart can have multiple graphical items in it (multiple Lines for example)
* and tooltip with `shared={true}` will display all items at the same time.
*
* Returns undefined when used outside a chart context.
*
* @returns Data points that are currently visible in a Tooltip
*/
var useActiveTooltipDataPoints = () => {
	return useAppSelector(selectActiveTooltipDataPoints);
};
/**
* Returns the calculated domain of an X-axis.
*
* The domain can be numerical: `[min, max]`, or categorical: `['a', 'b', 'c']`.
*
* The type of the domain is defined by the `type` prop of the XAxis.
*
* The values of the domain are calculated based on the data and the `dataKey` of the axis.
*
* If the chart has a Brush, the domain will be filtered to the brushed indexes if the hook is used outside a Brush context,
* and the full domain will be returned if the hook is used inside a Brush context.
*
* @param xAxisId The `xAxisId` of the X-axis. Defaults to `0` if not provided.
* @returns The domain of the X-axis, or `undefined` if it cannot be calculated or if used outside a chart context.
*/
var useXAxisDomain = function useXAxisDomain$1() {
	var xAxisId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultAxisId;
	var isPanorama = useIsPanorama();
	return useAppSelector((state) => selectAxisDomain(state, "xAxis", xAxisId, isPanorama));
};
/**
* Returns the calculated domain of a Y-axis.
*
* The domain can be numerical: `[min, max]`, or categorical: `['a', 'b', 'c']`.
*
* The type of the domain is defined by the `type` prop of the YAxis.
*
* The values of the domain are calculated based on the data and the `dataKey` of the axis.
*
* Does not interact with Brushes, as Y-axes do not support brushing.
*
* @param yAxisId The `yAxisId` of the Y-axis. Defaults to `0` if not provided.
* @returns The domain of the Y-axis, or `undefined` if it cannot be calculated or if used outside a chart context.
*/
var useYAxisDomain = function useYAxisDomain$1() {
	var yAxisId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultAxisId;
	var isPanorama = useIsPanorama();
	return useAppSelector((state) => selectAxisDomain(state, "yAxis", yAxisId, isPanorama));
};

//#endregion
//#region node_modules/recharts/es6/component/ActivePoints.js
function ownKeys$28(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$28(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$28(Object(t), !0).forEach(function(r$2) {
			_defineProperty$29(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$28(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$29(e, r$1, t) {
	return (r$1 = _toPropertyKey$29(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$29(t) {
	var i = _toPrimitive$29(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$29(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var renderActivePoint = (_ref$1) => {
	var { point: point$3, childIndex, mainColor, activeDot, dataKey } = _ref$1;
	if (activeDot === false || point$3.x == null || point$3.y == null) return null;
	var dotProps = _objectSpread$28(_objectSpread$28({
		index: childIndex,
		dataKey,
		cx: point$3.x,
		cy: point$3.y,
		r: 4,
		fill: mainColor !== null && mainColor !== void 0 ? mainColor : "none",
		strokeWidth: 2,
		stroke: "#fff",
		payload: point$3.payload,
		value: point$3.value
	}, svgPropertiesNoEventsFromUnknown(activeDot)), adaptEventHandlers(activeDot));
	var dot;
	if (/* @__PURE__ */ (0, import_react.isValidElement)(activeDot)) dot = /* @__PURE__ */ (0, import_react.cloneElement)(activeDot, dotProps);
	else if (typeof activeDot === "function") dot = activeDot(dotProps);
	else dot = /* @__PURE__ */ import_react.createElement(Dot, dotProps);
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-active-dot" }, dot);
};
function ActivePoints(_ref2) {
	var { points, mainColor, activeDot, itemDataKey } = _ref2;
	var activeTooltipIndex = useAppSelector(selectActiveTooltipIndex);
	var activeDataPoints = useActiveTooltipDataPoints();
	if (points == null || activeDataPoints == null) return null;
	var activePoint = points.find((p) => activeDataPoints.includes(p.payload));
	if (isNullish(activePoint)) return null;
	return renderActivePoint({
		point: activePoint,
		childIndex: Number(activeTooltipIndex),
		mainColor,
		dataKey: itemDataKey,
		activeDot
	});
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/radarSelectors.js
function ownKeys$27(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$27(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$27(Object(t), !0).forEach(function(r$2) {
			_defineProperty$28(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$27(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$28(e, r$1, t) {
	return (r$1 = _toPropertyKey$28(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$28(t) {
	var i = _toPrimitive$28(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$28(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var selectRadiusAxisScale = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
var selectRadiusAxisForRadar = createSelector([selectRadiusAxisScale], (scale) => {
	if (scale == null) return;
	return { scale };
});
var selectRadiusAxisForBandSize = createSelector([selectRadiusAxis, selectRadiusAxisScale], (axisSettings, scale) => {
	if (axisSettings == null || scale == null) return;
	return _objectSpread$27(_objectSpread$27({}, axisSettings), {}, { scale });
});
var selectRadiusAxisTicks$1 = (state, radiusAxisId, _angleAxisId, isPanorama) => {
	return selectPolarAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
};
var selectAngleAxisForRadar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
var selectPolarAxisScaleForRadar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
var selectAngleAxisForBandSize = createSelector([selectAngleAxisForRadar, selectPolarAxisScaleForRadar], (axisSettings, scale) => {
	if (axisSettings == null || scale == null) return;
	return _objectSpread$27(_objectSpread$27({}, axisSettings), {}, { scale });
});
var selectAngleAxisTicks$1 = (state, _radiusAxisId, angleAxisId, isPanorama) => {
	return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
};
var selectAngleAxisWithScaleAndViewport = createSelector([
	selectAngleAxisForRadar,
	selectPolarAxisScaleForRadar,
	selectPolarViewBox
], (axisOptions, scale, polarViewBox) => {
	if (polarViewBox == null || scale == null) return;
	return {
		scale,
		type: axisOptions.type,
		dataKey: axisOptions.dataKey,
		cx: polarViewBox.cx,
		cy: polarViewBox.cy
	};
});
var pickId = (_state, _radiusAxisId, _angleAxisId, _isPanorama, radarId) => radarId;
var selectBandSizeOfAxis = createSelector([
	selectChartLayout,
	selectRadiusAxisForBandSize,
	selectRadiusAxisTicks$1,
	selectAngleAxisForBandSize,
	selectAngleAxisTicks$1
], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
	if (isCategoricalAxis(layout, "radiusAxis")) return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
	return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
});
var selectSynchronisedRadarDataKey = createSelector([selectUnfilteredPolarItems, pickId], (graphicalItems, radarId) => {
	if (graphicalItems == null) return;
	var pgis = graphicalItems.find((item) => item.type === "radar" && radarId === item.id);
	return pgis === null || pgis === void 0 ? void 0 : pgis.dataKey;
});
var selectRadarPoints = createSelector([
	selectRadiusAxisForRadar,
	selectAngleAxisWithScaleAndViewport,
	selectChartDataAndAlwaysIgnoreIndexes,
	selectSynchronisedRadarDataKey,
	selectBandSizeOfAxis
], (radiusAxis, angleAxis, _ref$1, dataKey, bandSize) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref$1;
	if (radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || dataKey == null) return;
	var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
	return computeRadarPoints({
		radiusAxis,
		angleAxis,
		displayedData,
		dataKey,
		bandSize
	});
});

//#endregion
//#region node_modules/recharts/es6/polar/Radar.js
var import_last = /* @__PURE__ */ __toESM(require_last());
var _excluded$19 = ["id"];
function _objectWithoutProperties$19(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$19(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$19(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$26(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$26(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$26(Object(t), !0).forEach(function(r$2) {
			_defineProperty$27(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$26(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$27(e, r$1, t) {
	return (r$1 = _toPropertyKey$27(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$27(t) {
	var i = _toPrimitive$27(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$27(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$26() {
	return _extends$26 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$26.apply(null, arguments);
}
function getLegendItemColor$1(stroke, fill) {
	return stroke && stroke !== "none" ? stroke : fill;
}
var computeLegendPayloadFromRadarSectors = (props) => {
	var { dataKey, name, stroke, fill, legendType, hide } = props;
	return [{
		inactive: hide,
		dataKey,
		type: legendType,
		color: getLegendItemColor$1(stroke, fill),
		value: getTooltipNameProp(name, dataKey),
		payload: props
	}];
};
function getTooltipEntrySettings$9(props) {
	var { dataKey, stroke, strokeWidth, fill, name, hide, tooltipType } = props;
	return {
		dataDefinedOnItem: void 0,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			nameKey: void 0,
			dataKey,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: tooltipType,
			color: getLegendItemColor$1(stroke, fill),
			unit: ""
		}
	};
}
function renderDotItem$2(option, props) {
	var dotItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dotItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") dotItem = option(props);
	else dotItem = /* @__PURE__ */ import_react.createElement(Dot, _extends$26({}, props, { className: clsx("recharts-radar-dot", typeof option !== "boolean" ? option.className : "") }));
	return dotItem;
}
function computeRadarPoints(_ref$1) {
	var { radiusAxis, angleAxis, displayedData, dataKey, bandSize } = _ref$1;
	var { cx, cy } = angleAxis;
	var isRange = false;
	var points = [];
	var angleBandSize = angleAxis.type !== "number" ? bandSize !== null && bandSize !== void 0 ? bandSize : 0 : 0;
	displayedData.forEach((entry, i) => {
		var name = getValueByDataKey(entry, angleAxis.dataKey, i);
		var value = getValueByDataKey(entry, dataKey);
		var angle = angleAxis.scale(name) + angleBandSize;
		var pointValue = Array.isArray(value) ? (0, import_last.default)(value) : value;
		var radius = isNullish(pointValue) ? void 0 : radiusAxis.scale(pointValue);
		if (Array.isArray(value) && value.length >= 2) isRange = true;
		points.push(_objectSpread$26(_objectSpread$26({}, polarToCartesian(cx, cy, radius, angle)), {}, {
			name,
			value,
			cx,
			cy,
			radius,
			angle,
			payload: entry
		}));
	});
	var baseLinePoints = [];
	if (isRange) points.forEach((point$3) => {
		if (Array.isArray(point$3.value)) {
			var baseValue = point$3.value[0];
			var radius = isNullish(baseValue) ? void 0 : radiusAxis.scale(baseValue);
			baseLinePoints.push(_objectSpread$26(_objectSpread$26({}, point$3), {}, { radius }, polarToCartesian(cx, cy, radius, point$3.angle)));
		} else baseLinePoints.push(point$3);
	});
	return {
		points,
		isRange,
		baseLinePoints
	};
}
function Dots$2(_ref2) {
	var { points, props } = _ref2;
	var { dot, dataKey } = props;
	if (!dot) return null;
	var { id } = props, propsWithoutId = _objectWithoutProperties$19(props, _excluded$19);
	var baseProps = svgPropertiesNoEvents(propsWithoutId);
	var customDotProps = svgPropertiesAndEventsFromUnknown(dot);
	var dots = points.map((entry, i) => {
		var dotProps = _objectSpread$26(_objectSpread$26(_objectSpread$26({
			key: "dot-".concat(i),
			r: 3
		}, baseProps), customDotProps), {}, {
			dataKey,
			cx: entry.x,
			cy: entry.y,
			index: i,
			payload: entry
		});
		return renderDotItem$2(dot, dotProps);
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-radar-dots" }, dots);
}
function RadarLabelListProvider(_ref3) {
	var { showLabels, points, children } = _ref3;
	var labelListEntries = points.map((point$3) => {
		var viewBox = {
			x: point$3.x,
			y: point$3.y,
			width: 0,
			height: 0
		};
		return _objectSpread$26(_objectSpread$26({}, viewBox), {}, {
			value: point$3.value,
			payload: point$3.payload,
			parentViewBox: void 0,
			viewBox,
			fill: void 0
		});
	});
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: showLabels ? labelListEntries : null }, children);
}
function StaticPolygon(_ref4) {
	var { points, baseLinePoints, props } = _ref4;
	if (points == null) return null;
	var { shape, isRange, connectNulls } = props;
	var handleMouseEnter = (e) => {
		var { onMouseEnter } = props;
		if (onMouseEnter) onMouseEnter(props, e);
	};
	var handleMouseLeave = (e) => {
		var { onMouseLeave } = props;
		if (onMouseLeave) onMouseLeave(props, e);
	};
	var radar;
	if (/* @__PURE__ */ import_react.isValidElement(shape)) radar = /* @__PURE__ */ import_react.cloneElement(shape, _objectSpread$26(_objectSpread$26({}, props), {}, { points }));
	else if (typeof shape === "function") radar = shape(_objectSpread$26(_objectSpread$26({}, props), {}, { points }));
	else radar = /* @__PURE__ */ import_react.createElement(Polygon, _extends$26({}, svgPropertiesAndEvents(props), {
		onMouseEnter: handleMouseEnter,
		onMouseLeave: handleMouseLeave,
		points,
		baseLinePoints: isRange ? baseLinePoints : void 0,
		connectNulls
	}));
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-radar-polygon" }, radar, /* @__PURE__ */ import_react.createElement(Dots$2, {
		props,
		points
	}));
}
var interpolatePolarPoint = (prevPoints, prevPointsDiffFactor, t) => (entry, index) => {
	var prev = prevPoints && prevPoints[Math.floor(index * prevPointsDiffFactor)];
	if (prev) return _objectSpread$26(_objectSpread$26({}, entry), {}, {
		x: interpolate(prev.x, entry.x, t),
		y: interpolate(prev.y, entry.y, t)
	});
	return _objectSpread$26(_objectSpread$26({}, entry), {}, {
		x: interpolate(entry.cx, entry.x, t),
		y: interpolate(entry.cy, entry.y, t)
	});
};
function PolygonWithAnimation(_ref5) {
	var { props, previousPointsRef, previousBaseLinePointsRef } = _ref5;
	var { points, baseLinePoints, isAnimationActive, animationBegin, animationDuration, animationEasing, onAnimationEnd, onAnimationStart } = props;
	var prevPoints = previousPointsRef.current;
	var prevBaseLinePoints = previousBaseLinePointsRef.current;
	var prevPointsDiffFactor = prevPoints && prevPoints.length / points.length;
	var prevBaseLinePointsDiffFactor = prevBaseLinePoints && prevBaseLinePoints.length / baseLinePoints.length;
	var animationId = useAnimationId(props, "recharts-radar-");
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var showLabels = !isAnimating;
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(RadarLabelListProvider, {
		showLabels,
		points
	}, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		key: "radar-".concat(animationId),
		onAnimationEnd: handleAnimationEnd,
		onAnimationStart: handleAnimationStart
	}, (t) => {
		var stepData = t === 1 ? points : points.map(interpolatePolarPoint(prevPoints, prevPointsDiffFactor, t));
		var stepBaseLinePoints = t === 1 ? baseLinePoints : baseLinePoints === null || baseLinePoints === void 0 ? void 0 : baseLinePoints.map(interpolatePolarPoint(prevBaseLinePoints, prevBaseLinePointsDiffFactor, t));
		if (t > 0) {
			previousPointsRef.current = stepData;
			previousBaseLinePointsRef.current = stepBaseLinePoints;
		}
		return /* @__PURE__ */ import_react.createElement(StaticPolygon, {
			points: stepData,
			baseLinePoints: stepBaseLinePoints,
			props
		});
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }), props.children);
}
function RenderPolygon(props) {
	var previousPointsRef = (0, import_react.useRef)(void 0);
	var previousBaseLinePointsRef = (0, import_react.useRef)(void 0);
	return /* @__PURE__ */ import_react.createElement(PolygonWithAnimation, {
		props,
		previousPointsRef,
		previousBaseLinePointsRef
	});
}
var defaultRadarProps = {
	angleAxisId: 0,
	radiusAxisId: 0,
	hide: false,
	activeDot: true,
	dot: false,
	legendType: "rect",
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease"
};
var RadarWithState = class extends import_react.PureComponent {
	render() {
		var { hide, className, points } = this.props;
		if (hide || points == null) return null;
		var layerClass = clsx("recharts-radar", className);
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, /* @__PURE__ */ import_react.createElement(RenderPolygon, this.props)), /* @__PURE__ */ import_react.createElement(ActivePoints, {
			points,
			mainColor: getLegendItemColor$1(this.props.stroke, this.props.fill),
			itemDataKey: this.props.dataKey,
			activeDot: this.props.activeDot
		}));
	}
};
function RadarImpl(props) {
	var isPanorama = useIsPanorama();
	var radarPoints = useAppSelector((state) => selectRadarPoints(state, props.radiusAxisId, props.angleAxisId, isPanorama, props.id));
	return /* @__PURE__ */ import_react.createElement(RadarWithState, _extends$26({}, props, {
		points: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.points,
		baseLinePoints: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.baseLinePoints,
		isRange: radarPoints === null || radarPoints === void 0 ? void 0 : radarPoints.isRange
	}));
}
var Radar = class extends import_react.PureComponent {
	render() {
		return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
			id: this.props.id,
			type: "radar"
		}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetPolarGraphicalItem, {
			type: "radar",
			id,
			data: void 0,
			dataKey: this.props.dataKey,
			hide: this.props.hide,
			angleAxisId: this.props.angleAxisId,
			radiusAxisId: this.props.radiusAxisId
		}), /* @__PURE__ */ import_react.createElement(SetPolarLegendPayload, { legendPayload: computeLegendPayloadFromRadarSectors(this.props) }), /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
			fn: getTooltipEntrySettings$9,
			args: this.props
		}), /* @__PURE__ */ import_react.createElement(RadarImpl, _extends$26({}, this.props, { id }))));
	}
};
_defineProperty$27(Radar, "displayName", "Radar");
_defineProperty$27(Radar, "defaultProps", defaultRadarProps);

//#endregion
//#region node_modules/recharts/es6/util/RadialBarUtils.js
function _extends$25() {
	return _extends$25 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$25.apply(null, arguments);
}
function ownKeys$25(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$25(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$25(Object(t), !0).forEach(function(r$2) {
			_defineProperty$26(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$25(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$26(e, r$1, t) {
	return (r$1 = _toPropertyKey$26(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$26(t) {
	var i = _toPrimitive$26(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$26(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function parseCornerRadius(cornerRadius) {
	if (typeof cornerRadius === "string") return parseInt(cornerRadius, 10);
	return cornerRadius;
}
function typeGuardSectorProps(option, props) {
	var cxValue = "".concat(props.cx || option.cx);
	var cx = Number(cxValue);
	var cyValue = "".concat(props.cy || option.cy);
	var cy = Number(cyValue);
	return _objectSpread$25(_objectSpread$25(_objectSpread$25({}, props), option), {}, {
		cx,
		cy
	});
}
function RadialBarSector(props) {
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$25({
		shapeType: "sector",
		propTransformer: typeGuardSectorProps
	}, props));
}

//#endregion
//#region node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
	if (condition) return;
	if (isProduction) throw new Error(prefix);
	var provided = typeof message === "function" ? message() : message;
	var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
	throw new Error(value);
}

//#endregion
//#region node_modules/recharts/es6/util/BarUtils.js
var _excluded$18 = ["x", "y"];
function _extends$24() {
	return _extends$24 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$24.apply(null, arguments);
}
function ownKeys$24(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$24(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$24(Object(t), !0).forEach(function(r$2) {
			_defineProperty$25(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$24(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$25(e, r$1, t) {
	return (r$1 = _toPropertyKey$25(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$25(t) {
	var i = _toPrimitive$25(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$25(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$18(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$18(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$18(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function typeguardBarRectangleProps(_ref$1, props) {
	var { x: xProp, y: yProp } = _ref$1, option = _objectWithoutProperties$18(_ref$1, _excluded$18);
	var xValue = "".concat(xProp);
	var x$1 = parseInt(xValue, 10);
	var yValue = "".concat(yProp);
	var y$1 = parseInt(yValue, 10);
	var heightValue = "".concat(props.height || option.height);
	var height = parseInt(heightValue, 10);
	var widthValue = "".concat(props.width || option.width);
	var width = parseInt(widthValue, 10);
	return _objectSpread$24(_objectSpread$24(_objectSpread$24(_objectSpread$24(_objectSpread$24({}, props), option), x$1 ? { x: x$1 } : {}), y$1 ? { y: y$1 } : {}), {}, {
		height,
		width,
		name: props.name,
		radius: props.radius
	});
}
function BarRectangle(props) {
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$24({
		shapeType: "rectangle",
		propTransformer: typeguardBarRectangleProps,
		activeClassName: "recharts-active-bar"
	}, props));
}
/**
* Safely gets minPointSize from the minPointSize prop if it is a function
* @param minPointSize minPointSize as passed to the Bar component
* @param defaultValue default minPointSize
* @returns minPointSize
*/
var minPointSizeCallback = function minPointSizeCallback$1(minPointSize) {
	var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	return (value, index) => {
		if (isNumber(minPointSize)) return minPointSize;
		var isValueNumberOrNil = isNumber(value) || isNullish(value);
		if (isValueNumberOrNil) return minPointSize(value, index);
		!isValueNumberOrNil && invariant(false, "minPointSize callback function received a value with type of ".concat(typeof value, ". Currently only numbers or null/undefined are supported."));
		return defaultValue;
	};
};

//#endregion
//#region node_modules/recharts/es6/state/errorBarSlice.js
var errorBarSlice = createSlice({
	name: "errorBars",
	initialState: {},
	reducers: {
		addErrorBar: (state, action) => {
			var { itemId, errorBar } = action.payload;
			if (!state[itemId]) state[itemId] = [];
			state[itemId].push(errorBar);
		},
		replaceErrorBar: (state, action) => {
			var { itemId, prev, next } = action.payload;
			if (state[itemId]) state[itemId] = state[itemId].map((e) => e.dataKey === prev.dataKey && e.direction === prev.direction ? next : e);
		},
		removeErrorBar: (state, action) => {
			var { itemId, errorBar } = action.payload;
			if (state[itemId]) state[itemId] = state[itemId].filter((e) => e.dataKey !== errorBar.dataKey || e.direction !== errorBar.direction);
		}
	}
});
var { addErrorBar, replaceErrorBar, removeErrorBar } = errorBarSlice.actions;
var errorBarReducer = errorBarSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/context/ErrorBarContext.js
var _excluded$17 = ["children"];
function _objectWithoutProperties$17(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$17(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$17(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var ErrorBarContext = /* @__PURE__ */ (0, import_react.createContext)({
	data: [],
	xAxisId: "xAxis-0",
	yAxisId: "yAxis-0",
	dataPointFormatter: () => ({
		x: 0,
		y: 0,
		value: 0
	}),
	errorBarOffset: 0
});
function SetErrorBarContext(props) {
	var { children } = props, rest = _objectWithoutProperties$17(props, _excluded$17);
	return /* @__PURE__ */ import_react.createElement(ErrorBarContext.Provider, { value: rest }, children);
}
var useErrorBarContext = () => (0, import_react.useContext)(ErrorBarContext);
function ReportErrorBarSettings(props) {
	var dispatch = useAppDispatch();
	var graphicalItemId = useGraphicalItemId();
	var prevPropsRef = (0, import_react.useRef)(null);
	(0, import_react.useEffect)(() => {
		if (graphicalItemId == null) return;
		if (prevPropsRef.current === null) dispatch(addErrorBar({
			itemId: graphicalItemId,
			errorBar: props
		}));
		else if (prevPropsRef.current !== props) dispatch(replaceErrorBar({
			itemId: graphicalItemId,
			prev: prevPropsRef.current,
			next: props
		}));
		prevPropsRef.current = props;
	}, [
		dispatch,
		graphicalItemId,
		props
	]);
	(0, import_react.useEffect)(() => {
		return () => {
			if (prevPropsRef.current != null) {
				dispatch(removeErrorBar({
					itemId: graphicalItemId,
					errorBar: prevPropsRef.current
				}));
				prevPropsRef.current = null;
			}
		};
	}, [dispatch, graphicalItemId]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/cartesian/GraphicalItemClipPath.js
function useNeedsClip(xAxisId, yAxisId) {
	var _xAxis$allowDataOverf, _yAxis$allowDataOverf;
	var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
	var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
	var needClipX = (_xAxis$allowDataOverf = xAxis === null || xAxis === void 0 ? void 0 : xAxis.allowDataOverflow) !== null && _xAxis$allowDataOverf !== void 0 ? _xAxis$allowDataOverf : implicitXAxis.allowDataOverflow;
	var needClipY = (_yAxis$allowDataOverf = yAxis === null || yAxis === void 0 ? void 0 : yAxis.allowDataOverflow) !== null && _yAxis$allowDataOverf !== void 0 ? _yAxis$allowDataOverf : implicitYAxis.allowDataOverflow;
	return {
		needClip: needClipX || needClipY,
		needClipX,
		needClipY
	};
}
function GraphicalItemClipPath(_ref$1) {
	var { xAxisId, yAxisId, clipPathId } = _ref$1;
	var plotArea = usePlotArea();
	var { needClipX, needClipY, needClip } = useNeedsClip(xAxisId, yAxisId);
	if (!needClip) return null;
	var { x: x$1, y: y$1, width, height } = plotArea;
	return /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
		x: needClipX ? x$1 : x$1 - width / 2,
		y: needClipY ? y$1 : y$1 - height / 2,
		width: needClipX ? width : width * 2,
		height: needClipY ? height : height * 2
	}));
}

//#endregion
//#region node_modules/recharts/es6/cartesian/Bar.js
var _excluded$16 = [
	"onMouseEnter",
	"onMouseLeave",
	"onClick"
], _excluded2$10 = [
	"value",
	"background",
	"tooltipPosition"
], _excluded3$7 = ["id"], _excluded4$3 = [
	"onMouseEnter",
	"onClick",
	"onMouseLeave"
];
function _extends$23() {
	return _extends$23 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$23.apply(null, arguments);
}
function ownKeys$23(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$23(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$23(Object(t), !0).forEach(function(r$2) {
			_defineProperty$24(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$23(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$24(e, r$1, t) {
	return (r$1 = _toPropertyKey$24(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$24(t) {
	var i = _toPrimitive$24(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$24(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$16(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$16(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$16(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var computeLegendPayloadFromBarData = (props) => {
	var { dataKey, name, fill, legendType, hide } = props;
	return [{
		inactive: hide,
		dataKey,
		type: legendType,
		color: fill,
		value: getTooltipNameProp(name, dataKey),
		payload: props
	}];
};
function getTooltipEntrySettings$8(props) {
	var { dataKey, stroke, strokeWidth, fill, name, hide, unit: unit$1 } = props;
	return {
		dataDefinedOnItem: void 0,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			nameKey: void 0,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: props.tooltipType,
			color: props.fill,
			unit: unit$1
		}
	};
}
function BarBackground(props) {
	var activeIndex = useAppSelector(selectActiveTooltipIndex);
	var { data, dataKey, background: backgroundFromProps, allOtherBarProps } = props;
	var { onMouseEnter: onMouseEnterFromProps, onMouseLeave: onMouseLeaveFromProps, onClick: onItemClickFromProps } = allOtherBarProps, restOfAllOtherProps = _objectWithoutProperties$16(allOtherBarProps, _excluded$16);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
	if (!backgroundFromProps || data == null) return null;
	var backgroundProps = svgPropertiesNoEventsFromUnknown(backgroundFromProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, data.map((entry, i) => {
		var { value, background: backgroundFromDataEntry, tooltipPosition } = entry, rest = _objectWithoutProperties$16(entry, _excluded2$10);
		if (!backgroundFromDataEntry) return null;
		var onMouseEnter = onMouseEnterFromContext(entry, i);
		var onMouseLeave = onMouseLeaveFromContext(entry, i);
		var onClick = onClickFromContext(entry, i);
		var barRectangleProps = _objectSpread$23(_objectSpread$23(_objectSpread$23(_objectSpread$23(_objectSpread$23({
			option: backgroundFromProps,
			isActive: String(i) === activeIndex
		}, rest), {}, { fill: "#eee" }, backgroundFromDataEntry), backgroundProps), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
			onMouseEnter,
			onMouseLeave,
			onClick,
			dataKey,
			index: i,
			className: "recharts-bar-background-rectangle"
		});
		return /* @__PURE__ */ import_react.createElement(BarRectangle, _extends$23({ key: "background-bar-".concat(i) }, barRectangleProps));
	}));
}
function BarLabelListProvider(_ref$1) {
	var { showLabels, children, rects } = _ref$1;
	var labelListEntries = rects === null || rects === void 0 ? void 0 : rects.map((entry) => {
		var viewBox = {
			x: entry.x,
			y: entry.y,
			width: entry.width,
			height: entry.height
		};
		return _objectSpread$23(_objectSpread$23({}, viewBox), {}, {
			value: entry.value,
			payload: entry.payload,
			parentViewBox: entry.parentViewBox,
			viewBox,
			fill: entry.fill
		});
	});
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: showLabels ? labelListEntries : void 0 }, children);
}
function BarRectangleWithActiveState(props) {
	var { shape, activeBar, baseProps, entry, index, dataKey } = props;
	var activeIndex = useAppSelector(selectActiveTooltipIndex);
	var activeDataKey = useAppSelector(selectActiveTooltipDataKey);
	var isActive = activeBar && String(index) === activeIndex && (activeDataKey == null || dataKey === activeDataKey);
	var option = isActive ? activeBar : shape;
	return /* @__PURE__ */ import_react.createElement(BarRectangle, _extends$23({}, baseProps, { name: String(baseProps.name) }, entry, {
		isActive,
		option,
		index,
		dataKey
	}));
}
function BarRectangleNeverActive(props) {
	var { shape, baseProps, entry, index, dataKey } = props;
	return /* @__PURE__ */ import_react.createElement(BarRectangle, _extends$23({}, baseProps, { name: String(baseProps.name) }, entry, {
		isActive: false,
		option: shape,
		index,
		dataKey
	}));
}
function BarRectangles(_ref2) {
	var { data, props } = _ref2;
	var _svgPropertiesNoEvent = svgPropertiesNoEvents(props), { id } = _svgPropertiesNoEvent, baseProps = _objectWithoutProperties$16(_svgPropertiesNoEvent, _excluded3$7);
	var { shape, dataKey, activeBar } = props;
	var { onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps } = props, restOfAllOtherProps = _objectWithoutProperties$16(props, _excluded4$3);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, dataKey);
	if (!data) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, data.map((entry, i) => {
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$23({
			key: "rectangle-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value, "-").concat(i),
			className: "recharts-bar-rectangle"
		}, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
			onMouseEnter: onMouseEnterFromContext(entry, i),
			onMouseLeave: onMouseLeaveFromContext(entry, i),
			onClick: onClickFromContext(entry, i)
		}), activeBar ? /* @__PURE__ */ import_react.createElement(BarRectangleWithActiveState, {
			shape,
			activeBar,
			baseProps,
			entry,
			index: i,
			dataKey
		}) : /* @__PURE__ */ import_react.createElement(BarRectangleNeverActive, {
			shape,
			baseProps,
			entry,
			index: i,
			dataKey
		}));
	}));
}
function RectanglesWithAnimation(_ref3) {
	var { props, previousRectanglesRef } = _ref3;
	var { data, layout, isAnimationActive, animationBegin, animationDuration, animationEasing, onAnimationEnd, onAnimationStart } = props;
	var prevData = previousRectanglesRef.current;
	var animationId = useAnimationId(props, "recharts-bar-");
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var showLabels = !isAnimating;
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(BarLabelListProvider, {
		showLabels,
		rects: data
	}, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationEnd: handleAnimationEnd,
		onAnimationStart: handleAnimationStart,
		key: animationId
	}, (t) => {
		var stepData = t === 1 ? data : data === null || data === void 0 ? void 0 : data.map((entry, index) => {
			var prev = prevData && prevData[index];
			if (prev) return _objectSpread$23(_objectSpread$23({}, entry), {}, {
				x: interpolate(prev.x, entry.x, t),
				y: interpolate(prev.y, entry.y, t),
				width: interpolate(prev.width, entry.width, t),
				height: interpolate(prev.height, entry.height, t)
			});
			if (layout === "horizontal") {
				var h = interpolate(0, entry.height, t);
				return _objectSpread$23(_objectSpread$23({}, entry), {}, {
					y: entry.y + entry.height - h,
					height: h
				});
			}
			var w = interpolate(0, entry.width, t);
			return _objectSpread$23(_objectSpread$23({}, entry), {}, { width: w });
		});
		if (t > 0) previousRectanglesRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
		if (stepData == null) return null;
		return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement(BarRectangles, {
			props,
			data: stepData
		}));
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }), props.children);
}
function RenderRectangles(props) {
	var previousRectanglesRef = (0, import_react.useRef)(null);
	return /* @__PURE__ */ import_react.createElement(RectanglesWithAnimation, {
		previousRectanglesRef,
		props
	});
}
var defaultMinPointSize = 0;
var errorBarDataPointFormatter$2 = (dataPoint, dataKey) => {
	/**
	* if the value coming from `selectBarRectangles` is an array then this is a stacked bar chart.
	* arr[1] represents end value of the bar since the data is in the form of [startValue, endValue].
	* */
	var value = Array.isArray(dataPoint.value) ? dataPoint.value[1] : dataPoint.value;
	return {
		x: dataPoint.x,
		y: dataPoint.y,
		value,
		errorVal: getValueByDataKey(dataPoint, dataKey)
	};
};
var BarWithState = class extends import_react.PureComponent {
	render() {
		var { hide, data, dataKey, className, xAxisId, yAxisId, needClip, background, id } = this.props;
		if (hide || data == null) return null;
		var layerClass = clsx("recharts-bar", className);
		var clipPathId = id;
		return /* @__PURE__ */ import_react.createElement(Layer, {
			className: layerClass,
			id
		}, needClip && /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement(GraphicalItemClipPath, {
			clipPathId,
			xAxisId,
			yAxisId
		})), /* @__PURE__ */ import_react.createElement(Layer, {
			className: "recharts-bar-rectangles",
			clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0
		}, /* @__PURE__ */ import_react.createElement(BarBackground, {
			data,
			dataKey,
			background,
			allOtherBarProps: this.props
		}), /* @__PURE__ */ import_react.createElement(RenderRectangles, this.props)));
	}
};
var defaultBarProps = {
	activeBar: false,
	animationBegin: 0,
	animationDuration: 400,
	animationEasing: "ease",
	hide: false,
	isAnimationActive: !Global.isSsr,
	legendType: "rect",
	minPointSize: defaultMinPointSize,
	xAxisId: 0,
	yAxisId: 0
};
function BarImpl(props) {
	var { xAxisId, yAxisId, hide, legendType, minPointSize, activeBar, animationBegin, animationDuration, animationEasing, isAnimationActive } = props;
	var { needClip } = useNeedsClip(xAxisId, yAxisId);
	var layout = useChartLayout();
	var isPanorama = useIsPanorama();
	var cells = findAllByType(props.children, Cell);
	var rects = useAppSelector((state) => selectBarRectangles(state, xAxisId, yAxisId, isPanorama, props.id, cells));
	if (layout !== "vertical" && layout !== "horizontal") return null;
	var errorBarOffset;
	var firstDataPoint = rects === null || rects === void 0 ? void 0 : rects[0];
	if (firstDataPoint == null || firstDataPoint.height == null || firstDataPoint.width == null) errorBarOffset = 0;
	else errorBarOffset = layout === "vertical" ? firstDataPoint.height / 2 : firstDataPoint.width / 2;
	return /* @__PURE__ */ import_react.createElement(SetErrorBarContext, {
		xAxisId,
		yAxisId,
		data: rects,
		dataPointFormatter: errorBarDataPointFormatter$2,
		errorBarOffset
	}, /* @__PURE__ */ import_react.createElement(BarWithState, _extends$23({}, props, {
		layout,
		needClip,
		data: rects,
		xAxisId,
		yAxisId,
		hide,
		legendType,
		minPointSize,
		activeBar,
		animationBegin,
		animationDuration,
		animationEasing,
		isAnimationActive
	})));
}
function computeBarRectangles(_ref4) {
	var { layout, barSettings: { dataKey, minPointSize: minPointSizeProp }, pos, bandSize, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, displayedData, offset, cells, parentViewBox } = _ref4;
	var numericAxis = layout === "horizontal" ? yAxis : xAxis;
	var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
	var baseValue = getBaseValueOfBar({ numericAxis });
	return displayedData.map((entry, index) => {
		var value, x$1, y$1, width, height, background;
		if (stackedData) value = truncateByDomain(stackedData[index], stackedDomain);
		else {
			value = getValueByDataKey(entry, dataKey);
			if (!Array.isArray(value)) value = [baseValue, value];
		}
		var minPointSize = minPointSizeCallback(minPointSizeProp, defaultMinPointSize)(value[1], index);
		if (layout === "horizontal") {
			var _ref5;
			var [baseValueScale, currentValueScale] = [yAxis.scale(value[0]), yAxis.scale(value[1])];
			x$1 = getCateCoordinateOfBar({
				axis: xAxis,
				ticks: xAxisTicks,
				bandSize,
				offset: pos.offset,
				entry,
				index
			});
			y$1 = (_ref5 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref5 !== void 0 ? _ref5 : void 0;
			width = pos.size;
			var computedHeight = baseValueScale - currentValueScale;
			height = isNan(computedHeight) ? 0 : computedHeight;
			background = {
				x: x$1,
				y: offset.top,
				width,
				height: offset.height
			};
			if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
				var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
				y$1 -= delta;
				height += delta;
			}
		} else {
			var [_baseValueScale, _currentValueScale] = [xAxis.scale(value[0]), xAxis.scale(value[1])];
			x$1 = _baseValueScale;
			y$1 = getCateCoordinateOfBar({
				axis: yAxis,
				ticks: yAxisTicks,
				bandSize,
				offset: pos.offset,
				entry,
				index
			});
			width = _currentValueScale - _baseValueScale;
			height = pos.size;
			background = {
				x: offset.left,
				y: y$1,
				width: offset.width,
				height
			};
			if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
				var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
				width += _delta;
			}
		}
		if (x$1 == null || y$1 == null || width == null || height == null) return null;
		return _objectSpread$23(_objectSpread$23({}, entry), {}, {
			x: x$1,
			y: y$1,
			width,
			height,
			value: stackedData ? value : value[1],
			payload: entry,
			background,
			tooltipPosition: {
				x: x$1 + width / 2,
				y: y$1 + height / 2
			},
			parentViewBox
		}, cells && cells[index] && cells[index].props);
	}).filter(Boolean);
}
function BarFn(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultBarProps);
	var isPanorama = useIsPanorama();
	return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
		id: props.id,
		type: "bar"
	}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetLegendPayload, { legendPayload: computeLegendPayloadFromBarData(props) }), /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$8,
		args: props
	}), /* @__PURE__ */ import_react.createElement(SetCartesianGraphicalItem, {
		type: "bar",
		id,
		data: void 0,
		xAxisId: props.xAxisId,
		yAxisId: props.yAxisId,
		zAxisId: 0,
		dataKey: props.dataKey,
		stackId: getNormalizedStackId(props.stackId),
		hide: props.hide,
		barSize: props.barSize,
		minPointSize: props.minPointSize,
		maxBarSize: props.maxBarSize,
		isPanorama
	}), /* @__PURE__ */ import_react.createElement(BarImpl, _extends$23({}, props, { id }))));
}
var Bar = /* @__PURE__ */ import_react.memo(BarFn);
Bar.displayName = "Bar";

//#endregion
//#region node_modules/recharts/es6/state/selectors/barSelectors.js
function ownKeys$22(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$22(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$22(Object(t), !0).forEach(function(r$2) {
			_defineProperty$23(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$22(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$23(e, r$1, t) {
	return (r$1 = _toPropertyKey$23(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$23(t) {
	var i = _toPrimitive$23(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$23(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var pickXAxisId = (_state, xAxisId) => xAxisId;
var pickYAxisId = (_state, _xAxisId, yAxisId) => yAxisId;
var pickIsPanorama = (_state, _xAxisId, _yAxisId, isPanorama) => isPanorama;
var pickBarId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
var selectSynchronisedBarSettings = createSelector([selectUnfilteredCartesianItems, pickBarId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "bar").find((item) => item.id === id));
var selectMaxBarSize = createSelector([selectSynchronisedBarSettings], (barSettings) => barSettings === null || barSettings === void 0 ? void 0 : barSettings.maxBarSize);
var pickCells$2 = (_state, _xAxisId, _yAxisId, _isPanorama, _id, cells) => cells;
var getBarSize = (globalSize, totalSize, selfSize) => {
	var barSize = selfSize !== null && selfSize !== void 0 ? selfSize : globalSize;
	if (isNullish(barSize)) return;
	return getPercentValue(barSize, totalSize, 0);
};
var selectAllVisibleBars = createSelector([
	selectChartLayout,
	selectUnfilteredCartesianItems,
	pickXAxisId,
	pickYAxisId,
	pickIsPanorama
], (layout, allItems, xAxisId, yAxisId, isPanorama) => allItems.filter((i) => {
	if (layout === "horizontal") return i.xAxisId === xAxisId;
	return i.yAxisId === yAxisId;
}).filter((i) => i.isPanorama === isPanorama).filter((i) => i.hide === false).filter((i) => i.type === "bar"));
var selectBarStackGroups = (state, xAxisId, yAxisId, isPanorama) => {
	if (selectChartLayout(state) === "horizontal") return selectStackGroups(state, "yAxis", yAxisId, isPanorama);
	return selectStackGroups(state, "xAxis", xAxisId, isPanorama);
};
var selectBarCartesianAxisSize = (state, xAxisId, yAxisId) => {
	if (selectChartLayout(state) === "horizontal") return selectCartesianAxisSize(state, "xAxis", xAxisId);
	return selectCartesianAxisSize(state, "yAxis", yAxisId);
};
var combineBarSizeList = (allBars, globalSize, totalSize) => {
	var initialValue = {};
	var stackedBars = allBars.filter(isStacked);
	var unstackedBars = allBars.filter((b) => b.stackId == null);
	var groupByStack = stackedBars.reduce((acc, bar) => {
		if (!acc[bar.stackId]) acc[bar.stackId] = [];
		acc[bar.stackId].push(bar);
		return acc;
	}, initialValue);
	var stackedSizeList = Object.entries(groupByStack).map((_ref$1) => {
		var [stackId, bars] = _ref$1;
		var dataKeys = bars.map((b) => b.dataKey);
		var barSize = getBarSize(globalSize, totalSize, bars[0].barSize);
		return {
			stackId,
			dataKeys,
			barSize
		};
	});
	var unstackedSizeList = unstackedBars.map((b) => {
		var dataKeys = [b.dataKey].filter((dk) => dk != null);
		var barSize = getBarSize(globalSize, totalSize, b.barSize);
		return {
			stackId: void 0,
			dataKeys,
			barSize
		};
	});
	return [...stackedSizeList, ...unstackedSizeList];
};
var selectBarSizeList = createSelector([
	selectAllVisibleBars,
	selectRootBarSize,
	selectBarCartesianAxisSize
], combineBarSizeList);
var selectBarBandSize = (state, xAxisId, yAxisId, isPanorama, id) => {
	var _ref2, _getBandSizeOfAxis;
	var barSettings = selectSynchronisedBarSettings(state, xAxisId, yAxisId, isPanorama, id);
	if (barSettings == null) return;
	var layout = selectChartLayout(state);
	var globalMaxBarSize = selectRootMaxBarSize(state);
	var { maxBarSize: childMaxBarSize } = barSettings;
	var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
	var axis, ticks$1;
	if (layout === "horizontal") {
		axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
		ticks$1 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
	} else {
		axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
		ticks$1 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
	}
	return (_ref2 = (_getBandSizeOfAxis = getBandSizeOfAxis(axis, ticks$1, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
};
var selectAxisBandSize = (state, xAxisId, yAxisId, isPanorama) => {
	var layout = selectChartLayout(state);
	var axis, ticks$1;
	if (layout === "horizontal") {
		axis = selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
		ticks$1 = selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
	} else {
		axis = selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
		ticks$1 = selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
	}
	return getBandSizeOfAxis(axis, ticks$1);
};
function getBarPositions(barGap, barCategoryGap, bandSize, sizeList, maxBarSize) {
	var len = sizeList.length;
	if (len < 1) return;
	var realBarGap = getPercentValue(barGap, bandSize, 0, true);
	var result;
	var initialValue = [];
	if (isWellBehavedNumber(sizeList[0].barSize)) {
		var useFull = false;
		var fullBarSize = bandSize / len;
		var sum = sizeList.reduce((res, entry) => res + (entry.barSize || 0), 0);
		sum += (len - 1) * realBarGap;
		if (sum >= bandSize) {
			sum -= (len - 1) * realBarGap;
			realBarGap = 0;
		}
		if (sum >= bandSize && fullBarSize > 0) {
			useFull = true;
			fullBarSize *= .9;
			sum = len * fullBarSize;
		}
		var prev = {
			offset: ((bandSize - sum) / 2 >> 0) - realBarGap,
			size: 0
		};
		result = sizeList.reduce((res, entry) => {
			var _entry$barSize;
			var newPosition = {
				stackId: entry.stackId,
				dataKeys: entry.dataKeys,
				position: {
					offset: prev.offset + prev.size + realBarGap,
					size: useFull ? fullBarSize : (_entry$barSize = entry.barSize) !== null && _entry$barSize !== void 0 ? _entry$barSize : 0
				}
			};
			var newRes = [...res, newPosition];
			prev = newRes[newRes.length - 1].position;
			return newRes;
		}, initialValue);
	} else {
		var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
		if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) realBarGap = 0;
		var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
		if (originalSize > 1) originalSize >>= 0;
		var size = isWellBehavedNumber(maxBarSize) ? Math.min(originalSize, maxBarSize) : originalSize;
		result = sizeList.reduce((res, entry, i) => [...res, {
			stackId: entry.stackId,
			dataKeys: entry.dataKeys,
			position: {
				offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
				size
			}
		}], initialValue);
	}
	return result;
}
var combineAllBarPositions = (sizeList, globalMaxBarSize, barGap, barCategoryGap, barBandSize, bandSize, childMaxBarSize) => {
	var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
	var allBarPositions = getBarPositions(barGap, barCategoryGap, barBandSize !== bandSize ? barBandSize : bandSize, sizeList, maxBarSize);
	if (barBandSize !== bandSize && allBarPositions != null) allBarPositions = allBarPositions.map((pos) => _objectSpread$22(_objectSpread$22({}, pos), {}, { position: _objectSpread$22(_objectSpread$22({}, pos.position), {}, { offset: pos.position.offset - barBandSize / 2 }) }));
	return allBarPositions;
};
var selectAllBarPositions = createSelector([
	selectBarSizeList,
	selectRootMaxBarSize,
	selectBarGap,
	selectBarCategoryGap,
	selectBarBandSize,
	selectAxisBandSize,
	selectMaxBarSize
], combineAllBarPositions);
var selectXAxisWithScale$3 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale$3 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectXAxisTicks$3 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisTicks$3 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectBarPosition = createSelector([selectAllBarPositions, selectSynchronisedBarSettings], (allBarPositions, barSettings) => {
	if (allBarPositions == null || barSettings == null) return;
	var position$1 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
	if (position$1 == null) return;
	return position$1.position;
});
var combineStackedData = (stackGroups, barSettings) => {
	var stackSeriesIdentifier = getStackSeriesIdentifier(barSettings);
	if (!stackGroups || stackSeriesIdentifier == null || barSettings == null) return;
	var { stackId } = barSettings;
	if (stackId == null) return;
	var stackGroup = stackGroups[stackId];
	if (!stackGroup) return;
	var { stackedData } = stackGroup;
	if (!stackedData) return;
	return stackedData.find((sd) => sd.key === stackSeriesIdentifier);
};
var selectStackedDataOfItem = createSelector([selectBarStackGroups, selectSynchronisedBarSettings], combineStackedData);
var selectBarRectangles = createSelector([
	selectChartOffsetInternal,
	selectAxisViewBox,
	selectXAxisWithScale$3,
	selectYAxisWithScale$3,
	selectXAxisTicks$3,
	selectYAxisTicks$3,
	selectBarPosition,
	selectChartLayout,
	selectChartDataWithIndexesIfNotInPanorama,
	selectAxisBandSize,
	selectStackedDataOfItem,
	selectSynchronisedBarSettings,
	pickCells$2
], (offset, axisViewBox, xAxis, yAxis, xAxisTicks, yAxisTicks, pos, layout, _ref3, bandSize, stackedData, barSettings, cells) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref3;
	if (barSettings == null || pos == null || axisViewBox == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || bandSize == null) return;
	var { data } = barSettings;
	var displayedData;
	if (data != null && data.length > 0) displayedData = data;
	else displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
	if (displayedData == null) return;
	return computeBarRectangles({
		layout,
		barSettings,
		pos,
		parentViewBox: axisViewBox,
		bandSize,
		xAxis,
		yAxis,
		xAxisTicks,
		yAxisTicks,
		stackedData,
		displayedData,
		offset,
		cells
	});
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/radialBarSelectors.js
function ownKeys$21(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$21(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$21(Object(t), !0).forEach(function(r$2) {
			_defineProperty$22(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$21(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$22(e, r$1, t) {
	return (r$1 = _toPropertyKey$22(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$22(t) {
	var i = _toPrimitive$22(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$22(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var selectRadiusAxisForRadialBar = (state, radiusAxisId) => selectRadiusAxis(state, radiusAxisId);
var selectRadiusAxisScaleForRadar = (state, radiusAxisId) => selectPolarAxisScale(state, "radiusAxis", radiusAxisId);
var selectRadiusAxisWithScale = createSelector([selectRadiusAxisForRadialBar, selectRadiusAxisScaleForRadar], (axis, scale) => {
	if (axis == null || scale == null) return;
	return _objectSpread$21(_objectSpread$21({}, axis), {}, { scale });
});
var selectRadiusAxisTicks = (state, radiusAxisId, _angleAxisId, isPanorama) => {
	return selectPolarGraphicalItemAxisTicks(state, "radiusAxis", radiusAxisId, isPanorama);
};
var selectAngleAxisForRadialBar = (state, _radiusAxisId, angleAxisId) => selectAngleAxis(state, angleAxisId);
var selectAngleAxisScaleForRadialBar = (state, _radiusAxisId, angleAxisId) => selectPolarAxisScale(state, "angleAxis", angleAxisId);
var selectAngleAxisWithScale = createSelector([selectAngleAxisForRadialBar, selectAngleAxisScaleForRadialBar], (axis, scale) => {
	if (axis == null || scale == null) return;
	return _objectSpread$21(_objectSpread$21({}, axis), {}, { scale });
});
var selectAngleAxisTicks = (state, _radiusAxisId, angleAxisId, isPanorama) => {
	return selectPolarAxisTicks(state, "angleAxis", angleAxisId, isPanorama);
};
var pickRadialBarSettings = (_state, _radiusAxisId, _angleAxisId, radialBarSettings) => radialBarSettings;
var selectSynchronisedRadialBarSettings = createSelector([selectUnfilteredPolarItems, pickRadialBarSettings], (graphicalItems, radialBarSettingsFromProps) => {
	if (graphicalItems.some((pgis) => pgis.type === "radialBar" && radialBarSettingsFromProps.dataKey === pgis.dataKey && radialBarSettingsFromProps.stackId === pgis.stackId)) return radialBarSettingsFromProps;
});
var selectBandSizeOfPolarAxis = createSelector([
	selectChartLayout,
	selectRadiusAxisWithScale,
	selectRadiusAxisTicks,
	selectAngleAxisWithScale,
	selectAngleAxisTicks
], (layout, radiusAxis, radiusAxisTicks, angleAxis, angleAxisTicks) => {
	if (isCategoricalAxis(layout, "radiusAxis")) return getBandSizeOfAxis(radiusAxis, radiusAxisTicks, false);
	return getBandSizeOfAxis(angleAxis, angleAxisTicks, false);
});
var selectBaseValue = createSelector([
	selectAngleAxisWithScale,
	selectRadiusAxisWithScale,
	selectChartLayout
], (angleAxis, radiusAxis, layout) => {
	var numericAxis = layout === "radial" ? angleAxis : radiusAxis;
	if (numericAxis == null || numericAxis.scale == null) return;
	return getBaseValueOfBar({ numericAxis });
});
var pickCells$1 = (_state, _radiusAxisId, _angleAxisId, _radialBarSettings, cells) => cells;
var pickAngleAxisId = (_state, _radiusAxisId, angleAxisId, _radialBarSettings, _cells) => angleAxisId;
var pickRadiusAxisId = (_state, radiusAxisId, _angleAxisId, _radialBarSettings, _cells) => radiusAxisId;
var pickMaxBarSize = (_state, _radiusAxisId, _angleAxisId, radialBarSettings, _cells) => radialBarSettings.maxBarSize;
var selectAllVisibleRadialBars = createSelector([
	selectChartLayout,
	selectUnfilteredPolarItems,
	pickAngleAxisId,
	pickRadiusAxisId
], (layout, allItems, angleAxisId, radiusAxisId) => {
	return allItems.filter((i) => {
		if (layout === "centric") return i.angleAxisId === angleAxisId;
		return i.radiusAxisId === radiusAxisId;
	}).filter((i) => i.hide === false).filter((i) => i.type === "radialBar");
});
/**
* The generator never returned the totalSize which means that barSize in polar chart can not support percent values.
* We can add that if we want to I suppose.
* @returns undefined - but it should be a total size of numerical axis in polar chart
*/
var selectPolarBarAxisSize = () => void 0;
var selectPolarBarSizeList = createSelector([
	selectAllVisibleRadialBars,
	selectRootBarSize,
	selectPolarBarAxisSize
], combineBarSizeList);
var selectPolarBarBandSize = createSelector([
	selectChartLayout,
	selectRootMaxBarSize,
	selectAngleAxisWithScale,
	selectAngleAxisTicks,
	selectRadiusAxisWithScale,
	selectRadiusAxisTicks,
	pickMaxBarSize
], (layout, globalMaxBarSize, angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, childMaxBarSize) => {
	var _ref2, _getBandSizeOfAxis2;
	var maxBarSize = isNullish(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
	if (layout === "centric") {
		var _ref$1, _getBandSizeOfAxis;
		return (_ref$1 = (_getBandSizeOfAxis = getBandSizeOfAxis(angleAxis, angleAxisTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref$1 !== void 0 ? _ref$1 : 0;
	}
	return (_ref2 = (_getBandSizeOfAxis2 = getBandSizeOfAxis(radiusAxis, radiusAxisTicks, true)) !== null && _getBandSizeOfAxis2 !== void 0 ? _getBandSizeOfAxis2 : maxBarSize) !== null && _ref2 !== void 0 ? _ref2 : 0;
});
var selectAllPolarBarPositions = createSelector([
	selectPolarBarSizeList,
	selectRootMaxBarSize,
	selectBarGap,
	selectBarCategoryGap,
	selectPolarBarBandSize,
	selectBandSizeOfPolarAxis,
	pickMaxBarSize
], combineAllBarPositions);
var selectPolarBarPosition = createSelector([selectAllPolarBarPositions, selectSynchronisedRadialBarSettings], (allBarPositions, barSettings) => {
	if (allBarPositions == null || barSettings == null) return;
	var position$1 = allBarPositions.find((p) => p.stackId === barSettings.stackId && barSettings.dataKey != null && p.dataKeys.includes(barSettings.dataKey));
	if (position$1 == null) return;
	return position$1.position;
});
var selectStackedRadialBars = createSelector([selectPolarItemsSettings], (allPolarItems) => allPolarItems.filter((item) => item.type === "radialBar").filter(isStacked));
var selectPolarCombinedStackedData = createSelector([
	selectStackedRadialBars,
	selectChartDataAndAlwaysIgnoreIndexes,
	selectTooltipAxis
], combineDisplayedStackedData);
var selectStackGroups$1 = createSelector([
	selectPolarCombinedStackedData,
	selectStackedRadialBars,
	selectStackOffsetType
], combineStackGroups);
var selectRadialBarStackGroups = (state, radiusAxisId, angleAxisId) => {
	if (selectChartLayout(state) === "centric") return selectStackGroups$1(state, "radiusAxis", radiusAxisId);
	return selectStackGroups$1(state, "angleAxis", angleAxisId);
};
var selectPolarStackedData = createSelector([selectRadialBarStackGroups, selectSynchronisedRadialBarSettings], combineStackedData);
var selectRadialBarSectors = createSelector([
	selectAngleAxisWithScale,
	selectAngleAxisTicks,
	selectRadiusAxisWithScale,
	selectRadiusAxisTicks,
	selectChartDataWithIndexes,
	selectSynchronisedRadialBarSettings,
	selectBandSizeOfPolarAxis,
	selectChartLayout,
	selectBaseValue,
	selectPolarViewBox,
	pickCells$1,
	selectPolarBarPosition,
	selectPolarStackedData
], (angleAxis, angleAxisTicks, radiusAxis, radiusAxisTicks, _ref3, radialBarSettings, bandSize, layout, baseValue, polarViewBox, cells, pos, stackedData) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref3;
	if (radialBarSettings == null || radiusAxis == null || angleAxis == null || chartData == null || bandSize == null || pos == null || layout !== "centric" && layout !== "radial" || radiusAxisTicks == null) return [];
	var { dataKey, minPointSize } = radialBarSettings;
	var { cx, cy, startAngle, endAngle } = polarViewBox;
	var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
	var stackedDomain = stackedData ? (layout === "centric" ? radiusAxis : angleAxis).scale.domain() : null;
	return computeRadialBarDataItems({
		angleAxis,
		angleAxisTicks,
		bandSize,
		baseValue,
		cells,
		cx,
		cy,
		dataKey,
		dataStartIndex,
		displayedData,
		endAngle,
		layout,
		minPointSize,
		pos,
		radiusAxis,
		radiusAxisTicks,
		stackedData,
		stackedDomain,
		startAngle
	});
});
var selectRadialBarLegendPayload = createSelector([selectChartDataAndAlwaysIgnoreIndexes, (_s, l) => l], (_ref4, legendType) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref4;
	if (chartData == null) return [];
	var displayedData = chartData.slice(dataStartIndex, dataEndIndex + 1);
	if (displayedData.length === 0) return [];
	return displayedData.map((entry) => {
		return {
			type: legendType,
			value: entry.name,
			color: entry.fill,
			payload: entry
		};
	});
});

//#endregion
//#region node_modules/recharts/es6/polar/RadialBar.js
var _excluded$15 = [
	"shape",
	"activeShape",
	"cornerRadius",
	"id"
], _excluded2$9 = [
	"onMouseEnter",
	"onClick",
	"onMouseLeave"
], _excluded3$6 = ["value", "background"];
function _extends$22() {
	return _extends$22 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$22.apply(null, arguments);
}
function ownKeys$20(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$20(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$20(Object(t), !0).forEach(function(r$2) {
			_defineProperty$21(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$20(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$21(e, r$1, t) {
	return (r$1 = _toPropertyKey$21(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$21(t) {
	var i = _toPrimitive$21(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$21(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$15(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$15(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$15(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var STABLE_EMPTY_ARRAY = [];
function RadialBarLabelListProvider(_ref$1) {
	var { showLabels, sectors, children } = _ref$1;
	var labelListEntries = sectors.map((sector) => ({
		value: sector.value,
		payload: sector.payload,
		parentViewBox: void 0,
		clockWise: false,
		viewBox: {
			cx: sector.cx,
			cy: sector.cy,
			innerRadius: sector.innerRadius,
			outerRadius: sector.outerRadius,
			startAngle: sector.startAngle,
			endAngle: sector.endAngle,
			clockWise: false
		},
		fill: sector.fill
	}));
	return /* @__PURE__ */ import_react.createElement(PolarLabelListContextProvider, { value: showLabels ? labelListEntries : null }, children);
}
function RadialBarSectors(_ref2) {
	var { sectors, allOtherRadialBarProps, showLabels } = _ref2;
	var { shape, activeShape, cornerRadius, id } = allOtherRadialBarProps, others = _objectWithoutProperties$15(allOtherRadialBarProps, _excluded$15);
	var baseProps = svgPropertiesNoEvents(others);
	var activeIndex = useAppSelector(selectActiveTooltipIndex);
	var { onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps } = allOtherRadialBarProps, restOfAllOtherProps = _objectWithoutProperties$15(allOtherRadialBarProps, _excluded2$9);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherRadialBarProps.dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherRadialBarProps.dataKey);
	if (sectors == null) return null;
	return /* @__PURE__ */ import_react.createElement(RadialBarLabelListProvider, {
		showLabels,
		sectors
	}, sectors.map((entry, i) => {
		var isActive = activeShape && activeIndex === String(i);
		var onMouseEnter = onMouseEnterFromContext(entry, i);
		var onMouseLeave = onMouseLeaveFromContext(entry, i);
		var onClick = onClickFromContext(entry, i);
		var radialBarSectorProps = _objectSpread$20(_objectSpread$20(_objectSpread$20(_objectSpread$20({}, baseProps), {}, { cornerRadius: parseCornerRadius(cornerRadius) }, entry), adaptEventsOfChild(restOfAllOtherProps, entry, i)), {}, {
			onMouseEnter,
			onMouseLeave,
			onClick,
			className: "recharts-radial-bar-sector ".concat(entry.className),
			forceCornerRadius: others.forceCornerRadius,
			cornerIsExternal: others.cornerIsExternal,
			isActive,
			option: isActive ? activeShape : shape
		});
		return /* @__PURE__ */ import_react.createElement(RadialBarSector, _extends$22({ key: "sector-".concat(entry.cx, "-").concat(entry.cy, "-").concat(entry.innerRadius, "-").concat(entry.outerRadius, "-").concat(entry.startAngle, "-").concat(entry.endAngle, "-").concat(i) }, radialBarSectorProps));
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: allOtherRadialBarProps.label }), allOtherRadialBarProps.children);
}
function SectorsWithAnimation(_ref3) {
	var { props, previousSectorsRef } = _ref3;
	var { data, isAnimationActive, animationBegin, animationDuration, animationEasing, onAnimationEnd, onAnimationStart } = props;
	var animationId = useAnimationId(props, "recharts-radialbar-");
	var prevData = previousSectorsRef.current;
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationStart: handleAnimationStart,
		onAnimationEnd: handleAnimationEnd,
		key: animationId
	}, (t) => {
		var stepData = t === 1 ? data : (data !== null && data !== void 0 ? data : STABLE_EMPTY_ARRAY).map((entry, index) => {
			var prev = prevData && prevData[index];
			if (prev) {
				var interpolatorStartAngle = interpolateNumber(prev.startAngle, entry.startAngle);
				var interpolatorEndAngle = interpolateNumber(prev.endAngle, entry.endAngle);
				return _objectSpread$20(_objectSpread$20({}, entry), {}, {
					startAngle: interpolatorStartAngle(t),
					endAngle: interpolatorEndAngle(t)
				});
			}
			var { endAngle, startAngle } = entry;
			var interpolator = interpolateNumber(startAngle, endAngle);
			return _objectSpread$20(_objectSpread$20({}, entry), {}, { endAngle: interpolator(t) });
		});
		if (t > 0) previousSectorsRef.current = stepData !== null && stepData !== void 0 ? stepData : null;
		return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement(RadialBarSectors, {
			sectors: stepData !== null && stepData !== void 0 ? stepData : STABLE_EMPTY_ARRAY,
			allOtherRadialBarProps: props,
			showLabels: !isAnimating
		}));
	});
}
function RenderSectors(props) {
	var previousSectorsRef = (0, import_react.useRef)(null);
	return /* @__PURE__ */ import_react.createElement(SectorsWithAnimation, {
		props,
		previousSectorsRef
	});
}
function SetRadialBarPayloadLegend(props) {
	var legendPayload = useAppSelector((state) => selectRadialBarLegendPayload(state, props.legendType));
	return /* @__PURE__ */ import_react.createElement(SetPolarLegendPayload, { legendPayload: legendPayload !== null && legendPayload !== void 0 ? legendPayload : [] });
}
function getTooltipEntrySettings$7(props) {
	var { dataKey, data, stroke, strokeWidth, name, hide, fill, tooltipType } = props;
	return {
		dataDefinedOnItem: data,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			nameKey: void 0,
			dataKey,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: tooltipType,
			color: fill,
			unit: ""
		}
	};
}
var RadialBarWithState = class extends import_react.PureComponent {
	renderBackground(sectors) {
		if (sectors == null) return null;
		var { cornerRadius } = this.props;
		var backgroundProps = svgPropertiesNoEventsFromUnknown(this.props.background);
		return sectors.map((entry, i) => {
			var { value, background } = entry, rest = _objectWithoutProperties$15(entry, _excluded3$6);
			if (!background) return null;
			var props = _objectSpread$20(_objectSpread$20(_objectSpread$20(_objectSpread$20(_objectSpread$20({ cornerRadius: parseCornerRadius(cornerRadius) }, rest), {}, { fill: "#eee" }, background), backgroundProps), adaptEventsOfChild(this.props, entry, i)), {}, {
				index: i,
				className: clsx("recharts-radial-bar-background-sector", backgroundProps === null || backgroundProps === void 0 ? void 0 : backgroundProps.className),
				option: background,
				isActive: false
			});
			return /* @__PURE__ */ import_react.createElement(RadialBarSector, _extends$22({ key: "background-".concat(rest.cx, "-").concat(rest.cy, "-").concat(rest.innerRadius, "-").concat(rest.outerRadius, "-").concat(rest.startAngle, "-").concat(rest.endAngle, "-").concat(i) }, props));
		});
	}
	render() {
		var { hide, data, className, background } = this.props;
		if (hide) return null;
		var layerClass = clsx("recharts-area", className);
		return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, background && /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-radial-bar-background" }, this.renderBackground(data)), /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-radial-bar-sectors" }, /* @__PURE__ */ import_react.createElement(RenderSectors, this.props)));
	}
};
function RadialBarImpl(props) {
	var _useAppSelector;
	var cells = findAllByType(props.children, Cell);
	var radialBarSettings = {
		data: void 0,
		hide: false,
		id: props.id,
		dataKey: props.dataKey,
		minPointSize: props.minPointSize,
		stackId: getNormalizedStackId(props.stackId),
		maxBarSize: props.maxBarSize,
		barSize: props.barSize,
		type: "radialBar",
		angleAxisId: props.angleAxisId,
		radiusAxisId: props.radiusAxisId
	};
	var data = (_useAppSelector = useAppSelector((state) => selectRadialBarSectors(state, props.radiusAxisId, props.angleAxisId, radialBarSettings, cells))) !== null && _useAppSelector !== void 0 ? _useAppSelector : STABLE_EMPTY_ARRAY;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$7,
		args: _objectSpread$20(_objectSpread$20({}, props), {}, { data })
	}), /* @__PURE__ */ import_react.createElement(RadialBarWithState, _extends$22({}, props, { data })));
}
var defaultRadialBarProps = {
	angleAxisId: 0,
	radiusAxisId: 0,
	minPointSize: 0,
	hide: false,
	legendType: "rect",
	data: [],
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease",
	forceCornerRadius: false,
	cornerIsExternal: false
};
function computeRadialBarDataItems(_ref4) {
	var { displayedData, stackedData, dataStartIndex, stackedDomain, dataKey, baseValue, layout, radiusAxis, radiusAxisTicks, bandSize, pos, angleAxis, minPointSize, cx, cy, angleAxisTicks, cells, startAngle: rootStartAngle, endAngle: rootEndAngle } = _ref4;
	return (displayedData !== null && displayedData !== void 0 ? displayedData : []).map((entry, index) => {
		var value, innerRadius, outerRadius, startAngle, endAngle, backgroundSector;
		if (stackedData) value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);
		else {
			value = getValueByDataKey(entry, dataKey);
			if (!Array.isArray(value)) value = [baseValue, value];
		}
		if (layout === "radial") {
			innerRadius = getCateCoordinateOfBar({
				axis: radiusAxis,
				ticks: radiusAxisTicks,
				bandSize,
				offset: pos.offset,
				entry,
				index
			});
			endAngle = angleAxis.scale(value[1]);
			startAngle = angleAxis.scale(value[0]);
			outerRadius = (innerRadius !== null && innerRadius !== void 0 ? innerRadius : 0) + pos.size;
			var deltaAngle = endAngle - startAngle;
			if (Math.abs(minPointSize) > 0 && Math.abs(deltaAngle) < Math.abs(minPointSize)) {
				var delta = mathSign(deltaAngle || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaAngle));
				endAngle += delta;
			}
			backgroundSector = { background: {
				cx,
				cy,
				innerRadius,
				outerRadius,
				startAngle: rootStartAngle,
				endAngle: rootEndAngle
			} };
		} else {
			innerRadius = radiusAxis.scale(value[0]);
			outerRadius = radiusAxis.scale(value[1]);
			startAngle = getCateCoordinateOfBar({
				axis: angleAxis,
				ticks: angleAxisTicks,
				bandSize,
				offset: pos.offset,
				entry,
				index
			});
			endAngle = (startAngle !== null && startAngle !== void 0 ? startAngle : 0) + pos.size;
			var deltaRadius = outerRadius - innerRadius;
			if (Math.abs(minPointSize) > 0 && Math.abs(deltaRadius) < Math.abs(minPointSize)) {
				var _delta = mathSign(deltaRadius || minPointSize) * (Math.abs(minPointSize) - Math.abs(deltaRadius));
				outerRadius += _delta;
			}
		}
		return _objectSpread$20(_objectSpread$20(_objectSpread$20({}, entry), backgroundSector), {}, {
			payload: entry,
			value: stackedData ? value : value[1],
			cx,
			cy,
			innerRadius,
			outerRadius,
			startAngle,
			endAngle
		}, cells && cells[index] && cells[index].props);
	});
}
var RadialBar = class extends import_react.PureComponent {
	render() {
		return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
			id: this.props.id,
			type: "radialBar"
		}, (id) => {
			var _this$props$hide, _this$props$angleAxis, _this$props$radiusAxi;
			return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetPolarGraphicalItem, {
				type: "radialBar",
				id,
				data: void 0,
				dataKey: this.props.dataKey,
				hide: (_this$props$hide = this.props.hide) !== null && _this$props$hide !== void 0 ? _this$props$hide : defaultRadialBarProps.hide,
				angleAxisId: (_this$props$angleAxis = this.props.angleAxisId) !== null && _this$props$angleAxis !== void 0 ? _this$props$angleAxis : defaultRadialBarProps.angleAxisId,
				radiusAxisId: (_this$props$radiusAxi = this.props.radiusAxisId) !== null && _this$props$radiusAxi !== void 0 ? _this$props$radiusAxi : defaultRadialBarProps.radiusAxisId,
				stackId: getNormalizedStackId(this.props.stackId),
				barSize: this.props.barSize,
				minPointSize: this.props.minPointSize,
				maxBarSize: this.props.maxBarSize
			}), /* @__PURE__ */ import_react.createElement(SetRadialBarPayloadLegend, this.props), /* @__PURE__ */ import_react.createElement(RadialBarImpl, _extends$22({}, this.props, { id })));
		});
	}
};
_defineProperty$21(RadialBar, "displayName", "RadialBar");
_defineProperty$21(RadialBar, "defaultProps", defaultRadialBarProps);

//#endregion
//#region node_modules/recharts/es6/util/CssPrefixUtils.js
function ownKeys$19(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$19(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$19(Object(t), !0).forEach(function(r$2) {
			_defineProperty$20(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$19(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$20(e, r$1, t) {
	return (r$1 = _toPropertyKey$20(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$20(t) {
	var i = _toPrimitive$20(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$20(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var PREFIX_LIST = [
	"Webkit",
	"Moz",
	"O",
	"ms"
];
var generatePrefixStyle = (name, value) => {
	if (!name) return;
	var camelName = name.replace(/(\w)/, (v) => v.toUpperCase());
	var result = PREFIX_LIST.reduce((res, entry) => _objectSpread$19(_objectSpread$19({}, res), {}, { [entry + camelName]: value }), {});
	result[name] = value;
	return result;
};

//#endregion
//#region node_modules/recharts/es6/context/chartDataContext.js
var ChartDataContextProvider = (props) => {
	var { chartData } = props;
	var dispatch = useAppDispatch();
	var isPanorama = useIsPanorama();
	(0, import_react.useEffect)(() => {
		if (isPanorama) return () => {};
		dispatch(setChartData(chartData));
		return () => {
			dispatch(setChartData(void 0));
		};
	}, [
		chartData,
		dispatch,
		isPanorama
	]);
	return null;
};
var SetComputedData = (props) => {
	var { computedData } = props;
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(setComputedData(computedData));
		return () => {
			dispatch(setChartData(void 0));
		};
	}, [computedData, dispatch]);
	return null;
};
var selectChartData = (state) => state.chartData.chartData;
/**
* "data" is the data of the chart - it has no type because this part of recharts is very flexible.
* Basically it's an array of "something" and then there's the dataKey property in various places
* that's meant to pull other things away from the data.
*
* Some charts have `data` defined on the chart root, and they will return the array through this hook.
* For example: <ComposedChart data={data} />.
*
* Other charts, such as Pie, have data defined on individual graphical elements.
* These charts will return `undefined` through this hook, and you need to read the data from children.
* For example: <PieChart><Pie data={data} />
*
* Some charts also allow setting both - data on the parent, and data on the children at the same time!
* However, this particular selector will only return the ones defined on the parent.
*
* @deprecated use one of the other selectors instead - which one, depends on how do you identify the applicable graphical items.
*
* @return data array for some charts and undefined for other
*/
var useChartData = () => useAppSelector(selectChartData);
var selectDataIndex = (state) => {
	var { dataStartIndex, dataEndIndex } = state.chartData;
	return {
		startIndex: dataStartIndex,
		endIndex: dataEndIndex
	};
};
/**
* startIndex and endIndex are data boundaries, set through Brush.
*
* @return object with startIndex and endIndex
*/
var useDataIndex = () => {
	return useAppSelector(selectDataIndex);
};

//#endregion
//#region node_modules/recharts/es6/context/brushUpdateContext.js
var BrushUpdateDispatchContext = /* @__PURE__ */ (0, import_react.createContext)(() => {});

//#endregion
//#region node_modules/recharts/es6/state/brushSlice.js
/**
* From all Brush properties, only height has a default value and will always be defined.
* Other properties are nullable and will be computed from offsets and margins if they are not set.
*/
var initialState$2 = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	padding: {
		top: 0,
		right: 0,
		bottom: 0,
		left: 0
	}
};
var brushSlice = createSlice({
	name: "brush",
	initialState: initialState$2,
	reducers: { setBrushSettings(_state, action) {
		if (action.payload == null) return initialState$2;
		return action.payload;
	} }
});
var { setBrushSettings } = brushSlice.actions;
var brushReducer = brushSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/cartesian/Brush.js
var import_range = /* @__PURE__ */ __toESM(require_range());
function _extends$21() {
	return _extends$21 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$21.apply(null, arguments);
}
function ownKeys$18(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$18(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$18(Object(t), !0).forEach(function(r$2) {
			_defineProperty$19(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$18(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$19(e, r$1, t) {
	return (r$1 = _toPropertyKey$19(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$19(t) {
	var i = _toPrimitive$19(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$19(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function DefaultTraveller(props) {
	var { x: x$1, y: y$1, width, height, stroke } = props;
	var lineY = Math.floor(y$1 + height / 2) - 1;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement("rect", {
		x: x$1,
		y: y$1,
		width,
		height,
		fill: stroke,
		stroke: "none"
	}), /* @__PURE__ */ import_react.createElement("line", {
		x1: x$1 + 1,
		y1: lineY,
		x2: x$1 + width - 1,
		y2: lineY,
		fill: "none",
		stroke: "#fff"
	}), /* @__PURE__ */ import_react.createElement("line", {
		x1: x$1 + 1,
		y1: lineY + 2,
		x2: x$1 + width - 1,
		y2: lineY + 2,
		fill: "none",
		stroke: "#fff"
	}));
}
function Traveller(props) {
	var { travellerProps, travellerType } = props;
	if (/* @__PURE__ */ import_react.isValidElement(travellerType)) return /* @__PURE__ */ import_react.cloneElement(travellerType, travellerProps);
	if (typeof travellerType === "function") return travellerType(travellerProps);
	return /* @__PURE__ */ import_react.createElement(DefaultTraveller, travellerProps);
}
function TravellerLayer(_ref$1) {
	var _data$startIndex, _data$endIndex;
	var { otherProps, travellerX, id, onMouseEnter, onMouseLeave, onMouseDown, onTouchStart, onTravellerMoveKeyboard, onFocus, onBlur } = _ref$1;
	var { y: y$1, x: xFromProps, travellerWidth, height, traveller, ariaLabel, data, startIndex, endIndex } = otherProps;
	var x$1 = Math.max(travellerX, xFromProps);
	var travellerProps = _objectSpread$18(_objectSpread$18({}, svgPropertiesNoEvents(otherProps)), {}, {
		x: x$1,
		y: y$1,
		width: travellerWidth,
		height
	});
	var ariaLabelBrush = ariaLabel || "Min value: ".concat((_data$startIndex = data[startIndex]) === null || _data$startIndex === void 0 ? void 0 : _data$startIndex.name, ", Max value: ").concat((_data$endIndex = data[endIndex]) === null || _data$endIndex === void 0 ? void 0 : _data$endIndex.name);
	return /* @__PURE__ */ import_react.createElement(Layer, {
		tabIndex: 0,
		role: "slider",
		"aria-label": ariaLabelBrush,
		"aria-valuenow": travellerX,
		className: "recharts-brush-traveller",
		onMouseEnter,
		onMouseLeave,
		onMouseDown,
		onTouchStart,
		onKeyDown: (e) => {
			if (!["ArrowLeft", "ArrowRight"].includes(e.key)) return;
			e.preventDefault();
			e.stopPropagation();
			onTravellerMoveKeyboard(e.key === "ArrowRight" ? 1 : -1, id);
		},
		onFocus,
		onBlur,
		style: { cursor: "col-resize" }
	}, /* @__PURE__ */ import_react.createElement(Traveller, {
		travellerType: traveller,
		travellerProps
	}));
}
function getTextOfTick(props) {
	var { index, data, tickFormatter, dataKey } = props;
	var text = getValueByDataKey(data[index], dataKey, index);
	return typeof tickFormatter === "function" ? tickFormatter(text, index) : text;
}
function getIndexInRange(valueRange, x$1) {
	var len = valueRange.length;
	var start = 0;
	var end = len - 1;
	while (end - start > 1) {
		var middle = Math.floor((start + end) / 2);
		if (valueRange[middle] > x$1) end = middle;
		else start = middle;
	}
	return x$1 >= valueRange[end] ? end : start;
}
function getIndex(_ref2) {
	var { startX, endX, scaleValues, gap, data } = _ref2;
	var lastIndex = data.length - 1;
	var min$1 = Math.min(startX, endX);
	var max$1 = Math.max(startX, endX);
	var minIndex = getIndexInRange(scaleValues, min$1);
	var maxIndex = getIndexInRange(scaleValues, max$1);
	return {
		startIndex: minIndex - minIndex % gap,
		endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
	};
}
function Background$1(_ref3) {
	var { x: x$1, y: y$1, width, height, fill, stroke } = _ref3;
	return /* @__PURE__ */ import_react.createElement("rect", {
		stroke,
		fill,
		x: x$1,
		y: y$1,
		width,
		height
	});
}
function BrushText(_ref4) {
	var { startIndex, endIndex, y: y$1, height, travellerWidth, stroke, tickFormatter, dataKey, data, startX, endX } = _ref4;
	var offset = 5;
	var attrs = {
		pointerEvents: "none",
		fill: stroke
	};
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-brush-texts" }, /* @__PURE__ */ import_react.createElement(Text, _extends$21({
		textAnchor: "end",
		verticalAnchor: "middle",
		x: Math.min(startX, endX) - offset,
		y: y$1 + height / 2
	}, attrs), getTextOfTick({
		index: startIndex,
		tickFormatter,
		dataKey,
		data
	})), /* @__PURE__ */ import_react.createElement(Text, _extends$21({
		textAnchor: "start",
		verticalAnchor: "middle",
		x: Math.max(startX, endX) + travellerWidth + offset,
		y: y$1 + height / 2
	}, attrs), getTextOfTick({
		index: endIndex,
		tickFormatter,
		dataKey,
		data
	})));
}
function Slide(_ref5) {
	var { y: y$1, height, stroke, travellerWidth, startX, endX, onMouseEnter, onMouseLeave, onMouseDown, onTouchStart } = _ref5;
	var x$1 = Math.min(startX, endX) + travellerWidth;
	var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
	return /* @__PURE__ */ import_react.createElement("rect", {
		className: "recharts-brush-slide",
		onMouseEnter,
		onMouseLeave,
		onMouseDown,
		onTouchStart,
		style: { cursor: "move" },
		stroke: "none",
		fill: stroke,
		fillOpacity: .2,
		x: x$1,
		y: y$1,
		width,
		height
	});
}
function Panorama(_ref6) {
	var { x: x$1, y: y$1, width, height, data, children, padding } = _ref6;
	if (!(import_react.Children.count(children) === 1)) return null;
	var chartElement = import_react.Children.only(children);
	if (!chartElement) return null;
	return /* @__PURE__ */ import_react.cloneElement(chartElement, {
		x: x$1,
		y: y$1,
		width,
		height,
		margin: padding,
		compact: true,
		data
	});
}
var createScale = (_ref7) => {
	var { data, startIndex, endIndex, x: x$1, width, travellerWidth } = _ref7;
	if (!data || !data.length) return {};
	var len = data.length;
	var scale = point().domain((0, import_range.default)(0, len)).range([x$1, x$1 + width - travellerWidth]);
	var scaleValues = scale.domain().map((entry) => scale(entry));
	return {
		isTextActive: false,
		isSlideMoving: false,
		isTravellerMoving: false,
		isTravellerFocused: false,
		startX: scale(startIndex),
		endX: scale(endIndex),
		scale,
		scaleValues
	};
};
var isTouch = (e) => e.changedTouches && !!e.changedTouches.length;
var BrushWithState = class extends import_react.PureComponent {
	constructor(props) {
		super(props);
		_defineProperty$19(this, "handleDrag", (e) => {
			if (this.leaveTimer) {
				clearTimeout(this.leaveTimer);
				this.leaveTimer = null;
			}
			if (this.state.isTravellerMoving) this.handleTravellerMove(e);
			else if (this.state.isSlideMoving) this.handleSlideDrag(e);
		});
		_defineProperty$19(this, "handleTouchMove", (e) => {
			if (e.changedTouches != null && e.changedTouches.length > 0) this.handleDrag(e.changedTouches[0]);
		});
		_defineProperty$19(this, "handleDragEnd", () => {
			this.setState({
				isTravellerMoving: false,
				isSlideMoving: false
			}, () => {
				var { endIndex, onDragEnd, startIndex } = this.props;
				onDragEnd === null || onDragEnd === void 0 || onDragEnd({
					endIndex,
					startIndex
				});
			});
			this.detachDragEndListener();
		});
		_defineProperty$19(this, "handleLeaveWrapper", () => {
			if (this.state.isTravellerMoving || this.state.isSlideMoving) this.leaveTimer = window.setTimeout(this.handleDragEnd, this.props.leaveTimeOut);
		});
		_defineProperty$19(this, "handleEnterSlideOrTraveller", () => {
			this.setState({ isTextActive: true });
		});
		_defineProperty$19(this, "handleLeaveSlideOrTraveller", () => {
			this.setState({ isTextActive: false });
		});
		_defineProperty$19(this, "handleSlideDragStart", (e) => {
			var event = isTouch(e) ? e.changedTouches[0] : e;
			this.setState({
				isTravellerMoving: false,
				isSlideMoving: true,
				slideMoveStartX: event.pageX
			});
			this.attachDragEndListener();
		});
		_defineProperty$19(this, "handleTravellerMoveKeyboard", (direction, id) => {
			var { data, gap, startIndex, endIndex } = this.props;
			var { scaleValues, startX, endX } = this.state;
			if (scaleValues == null) return;
			var currentIndex = -1;
			if (id === "startX") currentIndex = startIndex;
			else if (id === "endX") currentIndex = endIndex;
			if (currentIndex < 0 || currentIndex >= data.length) return;
			var newIndex = currentIndex + direction;
			if (newIndex === -1 || newIndex >= scaleValues.length) return;
			var newScaleValue = scaleValues[newIndex];
			if (id === "startX" && newScaleValue >= endX || id === "endX" && newScaleValue <= startX) return;
			this.setState({ [id]: newScaleValue }, () => {
				this.props.onChange(getIndex({
					startX: this.state.startX,
					endX: this.state.endX,
					data,
					gap,
					scaleValues
				}));
			});
		});
		this.travellerDragStartHandlers = {
			startX: this.handleTravellerDragStart.bind(this, "startX"),
			endX: this.handleTravellerDragStart.bind(this, "endX")
		};
		this.state = {
			brushMoveStartX: 0,
			movingTravellerId: void 0,
			endX: 0,
			startX: 0,
			slideMoveStartX: 0
		};
	}
	static getDerivedStateFromProps(nextProps, prevState) {
		var { data, width, x: x$1, travellerWidth, startIndex, endIndex, startIndexControlledFromProps, endIndexControlledFromProps } = nextProps;
		if (data !== prevState.prevData) return _objectSpread$18({
			prevData: data,
			prevTravellerWidth: travellerWidth,
			prevX: x$1,
			prevWidth: width
		}, data && data.length ? createScale({
			data,
			width,
			x: x$1,
			travellerWidth,
			startIndex,
			endIndex
		}) : {
			scale: void 0,
			scaleValues: void 0
		});
		var prevScale = prevState.scale;
		if (prevScale && (width !== prevState.prevWidth || x$1 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
			prevScale.range([x$1, x$1 + width - travellerWidth]);
			var scaleValues = prevScale.domain().map((entry) => prevScale(entry)).filter((value) => value != null);
			return {
				prevData: data,
				prevTravellerWidth: travellerWidth,
				prevX: x$1,
				prevWidth: width,
				startX: prevScale(nextProps.startIndex),
				endX: prevScale(nextProps.endIndex),
				scaleValues
			};
		}
		if (prevState.scale && !prevState.isSlideMoving && !prevState.isTravellerMoving && !prevState.isTravellerFocused && !prevState.isTextActive) {
			if (startIndexControlledFromProps != null && prevState.prevStartIndexControlledFromProps !== startIndexControlledFromProps) return {
				startX: prevState.scale(startIndexControlledFromProps),
				prevStartIndexControlledFromProps: startIndexControlledFromProps
			};
			if (endIndexControlledFromProps != null && prevState.prevEndIndexControlledFromProps !== endIndexControlledFromProps) return {
				endX: prevState.scale(endIndexControlledFromProps),
				prevEndIndexControlledFromProps: endIndexControlledFromProps
			};
		}
		return null;
	}
	componentWillUnmount() {
		if (this.leaveTimer) {
			clearTimeout(this.leaveTimer);
			this.leaveTimer = null;
		}
		this.detachDragEndListener();
	}
	attachDragEndListener() {
		window.addEventListener("mouseup", this.handleDragEnd, true);
		window.addEventListener("touchend", this.handleDragEnd, true);
		window.addEventListener("mousemove", this.handleDrag, true);
	}
	detachDragEndListener() {
		window.removeEventListener("mouseup", this.handleDragEnd, true);
		window.removeEventListener("touchend", this.handleDragEnd, true);
		window.removeEventListener("mousemove", this.handleDrag, true);
	}
	handleSlideDrag(e) {
		var { slideMoveStartX, startX, endX, scaleValues } = this.state;
		if (scaleValues == null) return;
		var { x: x$1, width, travellerWidth, startIndex, endIndex, onChange, data, gap } = this.props;
		var delta = e.pageX - slideMoveStartX;
		if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - endX, x$1 + width - travellerWidth - startX);
		else if (delta < 0) delta = Math.max(delta, x$1 - startX, x$1 - endX);
		var newIndex = getIndex({
			startX: startX + delta,
			endX: endX + delta,
			data,
			gap,
			scaleValues
		});
		if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) onChange(newIndex);
		this.setState({
			startX: startX + delta,
			endX: endX + delta,
			slideMoveStartX: e.pageX
		});
	}
	handleTravellerDragStart(id, e) {
		var event = isTouch(e) ? e.changedTouches[0] : e;
		this.setState({
			isSlideMoving: false,
			isTravellerMoving: true,
			movingTravellerId: id,
			brushMoveStartX: event.pageX
		});
		this.attachDragEndListener();
	}
	handleTravellerMove(e) {
		var { brushMoveStartX, movingTravellerId, endX, startX, scaleValues } = this.state;
		if (movingTravellerId == null) return;
		var prevValue = this.state[movingTravellerId];
		var { x: x$1, width, travellerWidth, onChange, gap, data } = this.props;
		var params = {
			startX: this.state.startX,
			endX: this.state.endX,
			data,
			gap,
			scaleValues
		};
		var delta = e.pageX - brushMoveStartX;
		if (delta > 0) delta = Math.min(delta, x$1 + width - travellerWidth - prevValue);
		else if (delta < 0) delta = Math.max(delta, x$1 - prevValue);
		params[movingTravellerId] = prevValue + delta;
		var newIndex = getIndex(params);
		var { startIndex, endIndex } = newIndex;
		var isFullGap = () => {
			var lastIndex = data.length - 1;
			if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) return true;
			return false;
		};
		this.setState({
			[movingTravellerId]: prevValue + delta,
			brushMoveStartX: e.pageX
		}, () => {
			if (onChange) {
				if (isFullGap()) onChange(newIndex);
			}
		});
	}
	render() {
		var { data, className, children, x: x$1, y: y$1, dy, width, height, alwaysShowText, fill, stroke, startIndex, endIndex, travellerWidth, tickFormatter, dataKey, padding } = this.props;
		var { startX, endX, isTextActive, isSlideMoving, isTravellerMoving, isTravellerFocused } = this.state;
		if (!data || !data.length || !isNumber(x$1) || !isNumber(y$1) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) return null;
		var layerClass = clsx("recharts-brush", className);
		var style = generatePrefixStyle("userSelect", "none");
		var calculatedY = y$1 + (dy !== null && dy !== void 0 ? dy : 0);
		return /* @__PURE__ */ import_react.createElement(Layer, {
			className: layerClass,
			onMouseLeave: this.handleLeaveWrapper,
			onTouchMove: this.handleTouchMove,
			style
		}, /* @__PURE__ */ import_react.createElement(Background$1, {
			x: x$1,
			y: calculatedY,
			width,
			height,
			fill,
			stroke
		}), /* @__PURE__ */ import_react.createElement(PanoramaContextProvider, null, /* @__PURE__ */ import_react.createElement(Panorama, {
			x: x$1,
			y: calculatedY,
			width,
			height,
			data,
			padding
		}, children)), /* @__PURE__ */ import_react.createElement(Slide, {
			y: calculatedY,
			height,
			stroke,
			travellerWidth,
			startX,
			endX,
			onMouseEnter: this.handleEnterSlideOrTraveller,
			onMouseLeave: this.handleLeaveSlideOrTraveller,
			onMouseDown: this.handleSlideDragStart,
			onTouchStart: this.handleSlideDragStart
		}), /* @__PURE__ */ import_react.createElement(TravellerLayer, {
			travellerX: startX,
			id: "startX",
			otherProps: _objectSpread$18(_objectSpread$18({}, this.props), {}, { y: calculatedY }),
			onMouseEnter: this.handleEnterSlideOrTraveller,
			onMouseLeave: this.handleLeaveSlideOrTraveller,
			onMouseDown: this.travellerDragStartHandlers.startX,
			onTouchStart: this.travellerDragStartHandlers.startX,
			onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
			onFocus: () => {
				this.setState({ isTravellerFocused: true });
			},
			onBlur: () => {
				this.setState({ isTravellerFocused: false });
			}
		}), /* @__PURE__ */ import_react.createElement(TravellerLayer, {
			travellerX: endX,
			id: "endX",
			otherProps: _objectSpread$18(_objectSpread$18({}, this.props), {}, { y: calculatedY }),
			onMouseEnter: this.handleEnterSlideOrTraveller,
			onMouseLeave: this.handleLeaveSlideOrTraveller,
			onMouseDown: this.travellerDragStartHandlers.endX,
			onTouchStart: this.travellerDragStartHandlers.endX,
			onTravellerMoveKeyboard: this.handleTravellerMoveKeyboard,
			onFocus: () => {
				this.setState({ isTravellerFocused: true });
			},
			onBlur: () => {
				this.setState({ isTravellerFocused: false });
			}
		}), (isTextActive || isSlideMoving || isTravellerMoving || isTravellerFocused || alwaysShowText) && /* @__PURE__ */ import_react.createElement(BrushText, {
			startIndex,
			endIndex,
			y: calculatedY,
			height,
			travellerWidth,
			stroke,
			tickFormatter,
			dataKey,
			data,
			startX,
			endX
		}));
	}
};
function BrushInternal(props) {
	var dispatch = useAppDispatch();
	var chartData = useChartData();
	var dataIndexes = useDataIndex();
	var onChangeFromContext = (0, import_react.useContext)(BrushUpdateDispatchContext);
	var onChangeFromProps = props.onChange;
	var { startIndex: startIndexFromProps, endIndex: endIndexFromProps } = props;
	(0, import_react.useEffect)(() => {
		dispatch(setDataStartEndIndexes({
			startIndex: startIndexFromProps,
			endIndex: endIndexFromProps
		}));
	}, [
		dispatch,
		endIndexFromProps,
		startIndexFromProps
	]);
	useBrushChartSynchronisation();
	var onChange = (0, import_react.useCallback)((nextState) => {
		if (dataIndexes == null) return;
		var { startIndex: startIndex$1, endIndex: endIndex$1 } = dataIndexes;
		if (nextState.startIndex !== startIndex$1 || nextState.endIndex !== endIndex$1) {
			onChangeFromContext === null || onChangeFromContext === void 0 || onChangeFromContext(nextState);
			onChangeFromProps === null || onChangeFromProps === void 0 || onChangeFromProps(nextState);
			dispatch(setDataStartEndIndexes(nextState));
		}
	}, [
		onChangeFromProps,
		onChangeFromContext,
		dispatch,
		dataIndexes
	]);
	var brushDimensions = useAppSelector(selectBrushDimensions);
	if (brushDimensions == null || dataIndexes == null || chartData == null || !chartData.length) return null;
	var { startIndex, endIndex } = dataIndexes;
	var { x: x$1, y: y$1, width } = brushDimensions;
	var contextProperties = {
		data: chartData,
		x: x$1,
		y: y$1,
		width,
		startIndex,
		endIndex,
		onChange
	};
	return /* @__PURE__ */ import_react.createElement(BrushWithState, _extends$21({}, props, contextProperties, {
		startIndexControlledFromProps: startIndexFromProps !== null && startIndexFromProps !== void 0 ? startIndexFromProps : void 0,
		endIndexControlledFromProps: endIndexFromProps !== null && endIndexFromProps !== void 0 ? endIndexFromProps : void 0
	}));
}
function BrushSettingsDispatcher(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(setBrushSettings(props));
		return () => {
			dispatch(setBrushSettings(null));
		};
	}, [dispatch, props]);
	return null;
}
var defaultBrushProps = {
	height: 40,
	travellerWidth: 5,
	gap: 1,
	fill: "#fff",
	stroke: "#666",
	padding: {
		top: 1,
		right: 1,
		bottom: 1,
		left: 1
	},
	leaveTimeOut: 1e3,
	alwaysShowText: false
};
function Brush(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultBrushProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(BrushSettingsDispatcher, {
		height: props.height,
		x: props.x,
		y: props.y,
		width: props.width,
		padding: props.padding
	}), /* @__PURE__ */ import_react.createElement(BrushInternal, props));
}
Brush.displayName = "Brush";

//#endregion
//#region node_modules/recharts/es6/util/CartesianUtils.js
function ownKeys$17(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$17(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$17(Object(t), !0).forEach(function(r$2) {
			_defineProperty$18(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$17(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$18(e, r$1, t) {
	return (r$1 = _toPropertyKey$18(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$18(t) {
	var i = _toPrimitive$18(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$18(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var rectWithPoints = (_ref$1, _ref2) => {
	var { x: x1, y: y1 } = _ref$1;
	var { x: x2, y: y2 } = _ref2;
	return {
		x: Math.min(x1, x2),
		y: Math.min(y1, y2),
		width: Math.abs(x2 - x1),
		height: Math.abs(y2 - y1)
	};
};
/**
* Compute the x, y, width, and height of a box from two reference points.
* @param  {Object} coords     x1, x2, y1, and y2
* @return {Object} object
*/
var rectWithCoords = (_ref3) => {
	var { x1, y1, x2, y2 } = _ref3;
	return rectWithPoints({
		x: x1,
		y: y1
	}, {
		x: x2,
		y: y2
	});
};
var ScaleHelper = class ScaleHelper {
	static create(obj) {
		return new ScaleHelper(obj);
	}
	constructor(scale) {
		this.scale = scale;
	}
	get domain() {
		return this.scale.domain;
	}
	get range() {
		return this.scale.range;
	}
	get rangeMin() {
		return this.range()[0];
	}
	get rangeMax() {
		return this.range()[1];
	}
	get bandwidth() {
		return this.scale.bandwidth;
	}
	apply(value) {
		var { bandAware, position: position$1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
		if (value === void 0) return;
		if (position$1) switch (position$1) {
			case "start": return this.scale(value);
			case "middle":
				var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
				return this.scale(value) + offset;
			case "end":
				var _offset = this.bandwidth ? this.bandwidth() : 0;
				return this.scale(value) + _offset;
			default: return this.scale(value);
		}
		if (bandAware) {
			var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
			return this.scale(value) + _offset2;
		}
		return this.scale(value);
	}
	isInRange(value) {
		var range$5 = this.range();
		var first = range$5[0];
		var last$4 = range$5[range$5.length - 1];
		return first <= last$4 ? value >= first && value <= last$4 : value >= last$4 && value <= first;
	}
};
_defineProperty$18(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = (options$2) => {
	var scales = Object.keys(options$2).reduce((res, key) => _objectSpread$17(_objectSpread$17({}, res), {}, { [key]: ScaleHelper.create(options$2[key]) }), {});
	return _objectSpread$17(_objectSpread$17({}, scales), {}, {
		apply(coord) {
			var { bandAware, position: position$1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
			return Object.fromEntries(Object.entries(coord).map((_ref4) => {
				var [label, value] = _ref4;
				return [label, scales[label].apply(value, {
					bandAware,
					position: position$1
				})];
			}));
		},
		isInRange(coord) {
			return Object.keys(coord).every((label) => scales[label].isInRange(coord[label]));
		}
	});
};
/** Normalizes the angle so that 0 <= angle < 180.
* @param {number} angle Angle in degrees.
* @return {number} the normalized angle with a value of at least 0 and never greater or equal to 180. */
function normalizeAngle(angle) {
	return (angle % 180 + 180) % 180;
}
/** Calculates the width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.
* @param {Object} size Width and height of the text in a horizontal position.
* @param {number} angle Angle in degrees in which the text is displayed.
* @return {number} The width of the largest horizontal line that fits inside a rectangle that is displayed at an angle.
*/
var getAngledRectangleWidth = function getAngledRectangleWidth$1(_ref5) {
	var { width, height } = _ref5;
	var angle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
	var angleRadians = normalizeAngle(angle) * Math.PI / 180;
	var angleThreshold = Math.atan(height / width);
	var angledWidth = angleRadians > angleThreshold && angleRadians < Math.PI - angleThreshold ? height / Math.sin(angleRadians) : width / Math.cos(angleRadians);
	return Math.abs(angledWidth);
};

//#endregion
//#region node_modules/recharts/es6/state/referenceElementsSlice.js
var initialState$1 = {
	dots: [],
	areas: [],
	lines: []
};
var referenceElementsSlice = createSlice({
	name: "referenceElements",
	initialState: initialState$1,
	reducers: {
		addDot: (state, action) => {
			state.dots.push(action.payload);
		},
		removeDot: (state, action) => {
			var index = current(state).dots.findIndex((dot) => dot === action.payload);
			if (index !== -1) state.dots.splice(index, 1);
		},
		addArea: (state, action) => {
			state.areas.push(action.payload);
		},
		removeArea: (state, action) => {
			var index = current(state).areas.findIndex((area) => area === action.payload);
			if (index !== -1) state.areas.splice(index, 1);
		},
		addLine: (state, action) => {
			state.lines.push(action.payload);
		},
		removeLine: (state, action) => {
			var index = current(state).lines.findIndex((line) => line === action.payload);
			if (index !== -1) state.lines.splice(index, 1);
		}
	}
});
var { addDot, removeDot, addArea, removeArea, addLine, removeLine } = referenceElementsSlice.actions;
var referenceElementsReducer = referenceElementsSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/container/ClipPathProvider.js
var ClipPathIdContext = /* @__PURE__ */ (0, import_react.createContext)(void 0);
/**
* Generates a unique clip path ID for use in SVG elements,
* and puts it in a context provider.
*
* To read the clip path ID, use the `useClipPathId` hook,
* or render `<ClipPath>` component which will automatically use the ID from this context.
*
* @param props children - React children to be wrapped by the provider
* @returns React Context Provider
*/
var ClipPathProvider = (_ref$1) => {
	var { children } = _ref$1;
	var [clipPathId] = (0, import_react.useState)("".concat(uniqueId("recharts"), "-clip"));
	var plotArea = usePlotArea();
	if (plotArea == null) return null;
	var { x: x$1, y: y$1, width, height } = plotArea;
	return /* @__PURE__ */ import_react.createElement(ClipPathIdContext.Provider, { value: clipPathId }, /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: clipPathId }, /* @__PURE__ */ import_react.createElement("rect", {
		x: x$1,
		y: y$1,
		height,
		width
	}))), children);
};
var useClipPathId = () => {
	return (0, import_react.useContext)(ClipPathIdContext);
};

//#endregion
//#region node_modules/recharts/es6/cartesian/ReferenceLine.js
function ownKeys$16(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$16(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$16(Object(t), !0).forEach(function(r$2) {
			_defineProperty$17(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$16(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$17(e, r$1, t) {
	return (r$1 = _toPropertyKey$17(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$17(t) {
	var i = _toPrimitive$17(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$17(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$20() {
	return _extends$20 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$20.apply(null, arguments);
}
/**
* This excludes `viewBox` prop from svg for two reasons:
* 1. The components wants viewBox of object type, and svg wants string
*    - so there's a conflict, and the component will throw if it gets string
* 2. Internally the component calls `svgPropertiesNoEvents` which filters the viewBox away anyway
*/
var renderLine = (option, props) => {
	var line;
	if (/* @__PURE__ */ import_react.isValidElement(option)) line = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") line = option(props);
	else line = /* @__PURE__ */ import_react.createElement("line", _extends$20({}, props, { className: "recharts-reference-line-line" }));
	return line;
};
var getEndPoints = (scales, isFixedX, isFixedY, isSegment, viewBox, position$1, xAxisOrientation, yAxisOrientation, props) => {
	var { x: x$1, y: y$1, width, height } = viewBox;
	if (isFixedY) {
		var { y: yCoord } = props;
		var coord = scales.y.apply(yCoord, { position: position$1 });
		if (isNan(coord)) return null;
		if (props.ifOverflow === "discard" && !scales.y.isInRange(coord)) return null;
		var points = [{
			x: x$1 + width,
			y: coord
		}, {
			x: x$1,
			y: coord
		}];
		return yAxisOrientation === "left" ? points.reverse() : points;
	}
	if (isFixedX) {
		var { x: xCoord } = props;
		var _coord = scales.x.apply(xCoord, { position: position$1 });
		if (isNan(_coord)) return null;
		if (props.ifOverflow === "discard" && !scales.x.isInRange(_coord)) return null;
		var _points = [{
			x: _coord,
			y: y$1 + height
		}, {
			x: _coord,
			y: y$1
		}];
		return xAxisOrientation === "top" ? _points.reverse() : _points;
	}
	if (isSegment) {
		var { segment } = props;
		var _points2 = segment.map((p) => scales.apply(p, { position: position$1 }));
		if (props.ifOverflow === "discard" && _points2.some((p) => !scales.isInRange(p))) return null;
		return _points2;
	}
	return null;
};
function ReportReferenceLine(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(addLine(props));
		return () => {
			dispatch(removeLine(props));
		};
	});
	return null;
}
function ReferenceLineImpl(props) {
	var { x: fixedX, y: fixedY, segment, xAxisId, yAxisId, shape, className, ifOverflow } = props;
	var isPanorama = useIsPanorama();
	var clipPathId = useClipPathId();
	var xAxis = useAppSelector((state) => selectXAxisSettings(state, xAxisId));
	var yAxis = useAppSelector((state) => selectYAxisSettings(state, yAxisId));
	var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
	var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
	var viewBox = useViewBox();
	var isFixedX = isNumOrStr(fixedX);
	var isFixedY = isNumOrStr(fixedY);
	if (!clipPathId || !viewBox || xAxis == null || yAxis == null || xAxisScale == null || yAxisScale == null) return null;
	var scales = createLabeledScales({
		x: xAxisScale,
		y: yAxisScale
	});
	var isSegment = segment && segment.length === 2;
	var endPoints = getEndPoints(scales, isFixedX, isFixedY, isSegment, viewBox, props.position, xAxis.orientation, yAxis.orientation, props);
	if (!endPoints) return null;
	var [{ x: x1, y: y1 }, { x: x2, y: y2 }] = endPoints;
	var clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
	var lineProps = _objectSpread$16(_objectSpread$16({ clipPath }, svgPropertiesAndEvents(props)), {}, {
		x1,
		y1,
		x2,
		y2
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx("recharts-reference-line", className) }, renderLine(shape, lineProps), /* @__PURE__ */ import_react.createElement(CartesianLabelContextProvider, rectWithCoords({
		x1,
		y1,
		x2,
		y2
	}), /* @__PURE__ */ import_react.createElement(CartesianLabelFromLabelProp, { label: props.label }), props.children));
}
function ReferenceLineSettingsDispatcher(props) {
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportReferenceLine, {
		yAxisId: props.yAxisId,
		xAxisId: props.xAxisId,
		ifOverflow: props.ifOverflow,
		x: props.x,
		y: props.y
	}), /* @__PURE__ */ import_react.createElement(ReferenceLineImpl, props));
}
var ReferenceLine = class extends import_react.Component {
	render() {
		return /* @__PURE__ */ import_react.createElement(ReferenceLineSettingsDispatcher, this.props);
	}
};
_defineProperty$17(ReferenceLine, "displayName", "ReferenceLine");
_defineProperty$17(ReferenceLine, "defaultProps", {
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	fill: "none",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1,
	position: "middle"
});

//#endregion
//#region node_modules/recharts/es6/cartesian/ReferenceDot.js
function ownKeys$15(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$15(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$15(Object(t), !0).forEach(function(r$2) {
			_defineProperty$16(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$15(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$16(e, r$1, t) {
	return (r$1 = _toPropertyKey$16(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$16(t) {
	var i = _toPrimitive$16(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$16(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$19() {
	return _extends$19 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$19.apply(null, arguments);
}
var useCoordinate = (x$1, y$1, xAxisId, yAxisId, ifOverflow) => {
	var isX = isNumOrStr(x$1);
	var isY = isNumOrStr(y$1);
	var isPanorama = useIsPanorama();
	var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
	var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
	if (!isX || !isY || xAxisScale == null || yAxisScale == null) return null;
	var scales = createLabeledScales({
		x: xAxisScale,
		y: yAxisScale
	});
	var result = scales.apply({
		x: x$1,
		y: y$1
	}, { bandAware: true });
	if (ifOverflow === "discard" && !scales.isInRange(result)) return null;
	return result;
};
function ReportReferenceDot(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(addDot(props));
		return () => {
			dispatch(removeDot(props));
		};
	});
	return null;
}
var renderDot = (option, props) => {
	var dot;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dot = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") dot = option(props);
	else dot = /* @__PURE__ */ import_react.createElement(Dot, _extends$19({}, props, {
		cx: props.cx,
		cy: props.cy,
		className: "recharts-reference-dot-dot"
	}));
	return dot;
};
function ReferenceDotImpl(props) {
	var { x: x$1, y: y$1, r: r$1 } = props;
	var clipPathId = useClipPathId();
	var coordinate = useCoordinate(x$1, y$1, props.xAxisId, props.yAxisId, props.ifOverflow);
	if (!coordinate) return null;
	var { x: cx, y: cy } = coordinate;
	var { shape, className, ifOverflow } = props;
	var clipPath = ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
	var dotProps = _objectSpread$15(_objectSpread$15({ clipPath }, svgPropertiesAndEvents(props)), {}, {
		cx,
		cy
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx("recharts-reference-dot", className) }, renderDot(shape, dotProps), /* @__PURE__ */ import_react.createElement(CartesianLabelContextProvider, {
		x: cx - r$1,
		y: cy - r$1,
		width: 2 * r$1,
		height: 2 * r$1
	}, /* @__PURE__ */ import_react.createElement(CartesianLabelFromLabelProp, { label: props.label }), props.children));
}
function ReferenceDotSettingsDispatcher(props) {
	var { x: x$1, y: y$1, r: r$1, ifOverflow, yAxisId, xAxisId } = props;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportReferenceDot, {
		y: y$1,
		x: x$1,
		r: r$1,
		yAxisId,
		xAxisId,
		ifOverflow
	}), /* @__PURE__ */ import_react.createElement(ReferenceDotImpl, props));
}
var ReferenceDot = class extends import_react.Component {
	render() {
		return /* @__PURE__ */ import_react.createElement(ReferenceDotSettingsDispatcher, this.props);
	}
};
_defineProperty$16(ReferenceDot, "displayName", "ReferenceDot");
_defineProperty$16(ReferenceDot, "defaultProps", {
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#fff",
	stroke: "#ccc",
	fillOpacity: 1,
	strokeWidth: 1
});

//#endregion
//#region node_modules/recharts/es6/cartesian/ReferenceArea.js
function ownKeys$14(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$14(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$14(Object(t), !0).forEach(function(r$2) {
			_defineProperty$15(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$14(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$15(e, r$1, t) {
	return (r$1 = _toPropertyKey$15(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$15(t) {
	var i = _toPrimitive$15(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$15(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$18() {
	return _extends$18 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$18.apply(null, arguments);
}
var getRect = (hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props) => {
	var { x1: xValue1, x2: xValue2, y1: yValue1, y2: yValue2 } = props;
	if (xAxisScale == null || yAxisScale == null) return null;
	var scales = createLabeledScales({
		x: xAxisScale,
		y: yAxisScale
	});
	var p1 = {
		x: hasX1 ? scales.x.apply(xValue1, { position: "start" }) : scales.x.rangeMin,
		y: hasY1 ? scales.y.apply(yValue1, { position: "start" }) : scales.y.rangeMin
	};
	var p2 = {
		x: hasX2 ? scales.x.apply(xValue2, { position: "end" }) : scales.x.rangeMax,
		y: hasY2 ? scales.y.apply(yValue2, { position: "end" }) : scales.y.rangeMax
	};
	if (props.ifOverflow === "discard" && (!scales.isInRange(p1) || !scales.isInRange(p2))) return null;
	return rectWithPoints(p1, p2);
};
var renderRect = (option, props) => {
	var rect;
	if (/* @__PURE__ */ import_react.isValidElement(option)) rect = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") rect = option(props);
	else rect = /* @__PURE__ */ import_react.createElement(Rectangle, _extends$18({}, props, { className: "recharts-reference-area-rect" }));
	return rect;
};
function ReportReferenceArea(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(addArea(props));
		return () => {
			dispatch(removeArea(props));
		};
	});
	return null;
}
function ReferenceAreaImpl(props) {
	var { x1, x2, y1, y2, className, shape, xAxisId, yAxisId } = props;
	var clipPathId = useClipPathId();
	var isPanorama = useIsPanorama();
	var xAxisScale = useAppSelector((state) => selectAxisScale(state, "xAxis", xAxisId, isPanorama));
	var yAxisScale = useAppSelector((state) => selectAxisScale(state, "yAxis", yAxisId, isPanorama));
	if (xAxisScale == null || !yAxisScale == null) return null;
	var hasX1 = isNumOrStr(x1);
	var hasX2 = isNumOrStr(x2);
	var hasY1 = isNumOrStr(y1);
	var hasY2 = isNumOrStr(y2);
	if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) return null;
	var rect = getRect(hasX1, hasX2, hasY1, hasY2, xAxisScale, yAxisScale, props);
	if (!rect && !shape) return null;
	var clipPath = props.ifOverflow === "hidden" ? "url(#".concat(clipPathId, ")") : void 0;
	return /* @__PURE__ */ import_react.createElement(Layer, { className: clsx("recharts-reference-area", className) }, renderRect(shape, _objectSpread$14(_objectSpread$14({ clipPath }, svgPropertiesAndEvents(props)), rect)), /* @__PURE__ */ import_react.createElement(CartesianLabelContextProvider, rect, /* @__PURE__ */ import_react.createElement(CartesianLabelFromLabelProp, { label: props.label }), props.children));
}
function ReferenceAreaSettingsDispatcher(props) {
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportReferenceArea, {
		yAxisId: props.yAxisId,
		xAxisId: props.xAxisId,
		ifOverflow: props.ifOverflow,
		x1: props.x1,
		x2: props.x2,
		y1: props.y1,
		y2: props.y2
	}), /* @__PURE__ */ import_react.createElement(ReferenceAreaImpl, props));
}
var ReferenceArea = class extends import_react.Component {
	render() {
		return /* @__PURE__ */ import_react.createElement(ReferenceAreaSettingsDispatcher, this.props);
	}
};
_defineProperty$15(ReferenceArea, "displayName", "ReferenceArea");
_defineProperty$15(ReferenceArea, "defaultProps", {
	ifOverflow: "discard",
	xAxisId: 0,
	yAxisId: 0,
	r: 10,
	fill: "#ccc",
	fillOpacity: .5,
	stroke: "none",
	strokeWidth: 1
});

//#endregion
//#region node_modules/recharts/es6/util/ShallowEqual.js
function shallowEqual(a$1, b) {
	for (var key in a$1) if ({}.hasOwnProperty.call(a$1, key) && (!{}.hasOwnProperty.call(b, key) || a$1[key] !== b[key])) return false;
	for (var _key in b) if ({}.hasOwnProperty.call(b, _key) && !{}.hasOwnProperty.call(a$1, _key)) return false;
	return true;
}

//#endregion
//#region node_modules/recharts/es6/util/getEveryNthWithCondition.js
/**
* Given an array and a number N, return a new array which contains every nTh
* element of the input array. For n below 1, an empty array is returned.
* If isValid is provided, all candidates must suffice the condition, else undefined is returned.
* @param {T[]} array An input array.
* @param {integer} n A number
* @param {Function} isValid A function to evaluate a candidate form the array
* @returns {T[]} The result array of the same type as the input array.
*/
function getEveryNthWithCondition(array, n, isValid) {
	if (n < 1) return [];
	if (n === 1 && isValid === void 0) return array;
	var result = [];
	for (var i = 0; i < array.length; i += n) if (isValid === void 0 || isValid(array[i]) === true) result.push(array[i]);
	else return;
	return result;
}

//#endregion
//#region node_modules/recharts/es6/util/TickUtils.js
function getAngledTickWidth(contentSize, unitSize, angle) {
	var size = {
		width: contentSize.width + unitSize.width,
		height: contentSize.height + unitSize.height
	};
	return getAngledRectangleWidth(size, angle);
}
function getTickBoundaries(viewBox, sign$1, sizeKey) {
	var isWidth = sizeKey === "width";
	var { x: x$1, y: y$1, width, height } = viewBox;
	if (sign$1 === 1) return {
		start: isWidth ? x$1 : y$1,
		end: isWidth ? x$1 + width : y$1 + height
	};
	return {
		start: isWidth ? x$1 + width : y$1 + height,
		end: isWidth ? x$1 : y$1
	};
}
function isVisible(sign$1, tickPosition, getSize, start, end) {
	if (sign$1 * tickPosition < sign$1 * start || sign$1 * tickPosition > sign$1 * end) return false;
	var size = getSize();
	return sign$1 * (tickPosition - sign$1 * size / 2 - start) >= 0 && sign$1 * (tickPosition + sign$1 * size / 2 - end) <= 0;
}
function getNumberIntervalTicks(ticks$1, interval) {
	return getEveryNthWithCondition(ticks$1, interval + 1);
}

//#endregion
//#region node_modules/recharts/es6/cartesian/getEquidistantTicks.js
function getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var { start: initialStart, end } = boundaries;
	var index = 0;
	var stepsize = 1;
	var start = initialStart;
	var _loop = function _loop$1() {
		var entry = ticks$1 === null || ticks$1 === void 0 ? void 0 : ticks$1[index];
		if (entry === void 0) return { v: getEveryNthWithCondition(ticks$1, stepsize) };
		var i = index;
		var size;
		var getSize = () => {
			if (size === void 0) size = getTickSize(entry, i);
			return size;
		};
		var tickCoord = entry.coordinate;
		var isShow = index === 0 || isVisible(sign$1, tickCoord, getSize, start, end);
		if (!isShow) {
			index = 0;
			start = initialStart;
			stepsize += 1;
		}
		if (isShow) {
			start = tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			index += stepsize;
		}
	}, _ret;
	while (stepsize <= result.length) {
		_ret = _loop();
		if (_ret) return _ret.v;
	}
	return [];
}

//#endregion
//#region node_modules/recharts/es6/cartesian/getTicks.js
function ownKeys$13(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$13(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$13(Object(t), !0).forEach(function(r$2) {
			_defineProperty$14(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$13(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$14(e, r$1, t) {
	return (r$1 = _toPropertyKey$14(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$14(t) {
	var i = _toPrimitive$14(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$14(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var { start } = boundaries;
	var { end } = boundaries;
	var _loop = function _loop$1(i$1) {
		var entry = result[i$1];
		var size;
		var getSize = () => {
			if (size === void 0) size = getTickSize(entry, i$1);
			return size;
		};
		if (i$1 === len - 1) {
			var gap = sign$1 * (entry.coordinate + sign$1 * getSize() / 2 - end);
			result[i$1] = entry = _objectSpread$13(_objectSpread$13({}, entry), {}, { tickCoord: gap > 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$1] = entry = _objectSpread$13(_objectSpread$13({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			end = entry.tickCoord - sign$1 * (getSize() / 2 + minTickGap);
			result[i$1] = _objectSpread$13(_objectSpread$13({}, entry), {}, { isShow: true });
		}
	};
	for (var i = len - 1; i >= 0; i--) _loop(i);
	return result;
}
function getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, preserveEnd) {
	var result = (ticks$1 || []).slice();
	var len = result.length;
	var { start, end } = boundaries;
	if (preserveEnd) {
		var tail = ticks$1[len - 1];
		var tailSize = getTickSize(tail, len - 1);
		var tailGap = sign$1 * (tail.coordinate + sign$1 * tailSize / 2 - end);
		result[len - 1] = tail = _objectSpread$13(_objectSpread$13({}, tail), {}, { tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign$1 : tail.coordinate });
		if (isVisible(sign$1, tail.tickCoord, () => tailSize, start, end)) {
			end = tail.tickCoord - sign$1 * (tailSize / 2 + minTickGap);
			result[len - 1] = _objectSpread$13(_objectSpread$13({}, tail), {}, { isShow: true });
		}
	}
	var count = preserveEnd ? len - 1 : len;
	var _loop2 = function _loop2$1(i$1) {
		var entry = result[i$1];
		var size;
		var getSize = () => {
			if (size === void 0) size = getTickSize(entry, i$1);
			return size;
		};
		if (i$1 === 0) {
			var gap = sign$1 * (entry.coordinate - sign$1 * getSize() / 2 - start);
			result[i$1] = entry = _objectSpread$13(_objectSpread$13({}, entry), {}, { tickCoord: gap < 0 ? entry.coordinate - gap * sign$1 : entry.coordinate });
		} else result[i$1] = entry = _objectSpread$13(_objectSpread$13({}, entry), {}, { tickCoord: entry.coordinate });
		if (isVisible(sign$1, entry.tickCoord, getSize, start, end)) {
			start = entry.tickCoord + sign$1 * (getSize() / 2 + minTickGap);
			result[i$1] = _objectSpread$13(_objectSpread$13({}, entry), {}, { isShow: true });
		}
	};
	for (var i = 0; i < count; i++) _loop2(i);
	return result;
}
function getTicks(props, fontSize, letterSpacing) {
	var { tick, ticks: ticks$1, viewBox, minTickGap, orientation, interval, tickFormatter, unit: unit$1, angle } = props;
	if (!ticks$1 || !ticks$1.length || !tick) return [];
	if (isNumber(interval) || Global.isSsr) {
		var _getNumberIntervalTic;
		return (_getNumberIntervalTic = getNumberIntervalTicks(ticks$1, isNumber(interval) ? interval : 0)) !== null && _getNumberIntervalTic !== void 0 ? _getNumberIntervalTic : [];
	}
	var candidates = [];
	var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
	var unitSize = unit$1 && sizeKey === "width" ? getStringSize(unit$1, {
		fontSize,
		letterSpacing
	}) : {
		width: 0,
		height: 0
	};
	var getTickSize = (content, index) => {
		var value = typeof tickFormatter === "function" ? tickFormatter(content.value, index) : content.value;
		return sizeKey === "width" ? getAngledTickWidth(getStringSize(value, {
			fontSize,
			letterSpacing
		}), unitSize, angle) : getStringSize(value, {
			fontSize,
			letterSpacing
		})[sizeKey];
	};
	var sign$1 = ticks$1.length >= 2 ? mathSign(ticks$1[1].coordinate - ticks$1[0].coordinate) : 1;
	var boundaries = getTickBoundaries(viewBox, sign$1, sizeKey);
	if (interval === "equidistantPreserveStart") return getEquidistantTicks(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	if (interval === "preserveStart" || interval === "preserveStartEnd") candidates = getTicksStart(sign$1, boundaries, getTickSize, ticks$1, minTickGap, interval === "preserveStartEnd");
	else candidates = getTicksEnd(sign$1, boundaries, getTickSize, ticks$1, minTickGap);
	return candidates.filter((entry) => entry.isShow);
}

//#endregion
//#region node_modules/recharts/es6/util/YAxisUtils.js
/**
* Calculates the width of the Y-axis based on the tick labels and the axis label.
* @param params - The parameters object.
* @param [params.ticks] - An array-like object of tick elements, each with a `getBoundingClientRect` method.
* @param [params.label] - The axis label element, with a `getBoundingClientRect` method.
* @param [params.labelGapWithTick=5] - The gap between the label and the tick.
* @param [params.tickSize=0] - The length of the tick line.
* @param [params.tickMargin=0] - The margin between the tick line and the tick text.
* @returns The calculated width of the Y-axis.
*/
var getCalculatedYAxisWidth = (_ref$1) => {
	var { ticks: ticks$1, label, labelGapWithTick = 5, tickSize = 0, tickMargin = 0 } = _ref$1;
	var maxTickWidth = 0;
	if (ticks$1) {
		Array.from(ticks$1).forEach((tickNode) => {
			if (tickNode) {
				var bbox = tickNode.getBoundingClientRect();
				if (bbox.width > maxTickWidth) maxTickWidth = bbox.width;
			}
		});
		var labelWidth = label ? label.getBoundingClientRect().width : 0;
		var tickWidth = tickSize + tickMargin;
		var updatedYAxisWidth = maxTickWidth + tickWidth + labelWidth + (label ? labelGapWithTick : 0);
		return Math.round(updatedYAxisWidth);
	}
	return 0;
};

//#endregion
//#region node_modules/recharts/es6/cartesian/CartesianAxis.js
var import_get$3 = /* @__PURE__ */ __toESM(require_get());
var _excluded$14 = [
	"axisLine",
	"width",
	"height",
	"className",
	"hide",
	"ticks"
], _excluded2$8 = ["viewBox"], _excluded3$5 = ["viewBox"];
function _objectWithoutProperties$14(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$14(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$14(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$17() {
	return _extends$17 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$17.apply(null, arguments);
}
function ownKeys$12(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$12(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$12(Object(t), !0).forEach(function(r$2) {
			_defineProperty$13(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$12(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$13(e, r$1, t) {
	return (r$1 = _toPropertyKey$13(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$13(t) {
	var i = _toPrimitive$13(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$13(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/** The orientation of the axis in correspondence to the chart */
/** A unit to be appended to a value */
/** The formatter function of tick */
var defaultCartesianAxisProps = {
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	viewBox: {
		x: 0,
		y: 0,
		width: 0,
		height: 0
	},
	orientation: "bottom",
	ticks: [],
	stroke: "#666",
	tickLine: true,
	axisLine: true,
	tick: true,
	mirror: false,
	minTickGap: 5,
	tickSize: 6,
	tickMargin: 2,
	interval: "preserveEnd"
};
function AxisLine(axisLineProps) {
	var { x: x$1, y: y$1, width, height, orientation, mirror, axisLine, otherSvgProps } = axisLineProps;
	if (!axisLine) return null;
	var props = _objectSpread$12(_objectSpread$12(_objectSpread$12({}, otherSvgProps), svgPropertiesNoEvents(axisLine)), {}, { fill: "none" });
	if (orientation === "top" || orientation === "bottom") {
		var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
		props = _objectSpread$12(_objectSpread$12({}, props), {}, {
			x1: x$1,
			y1: y$1 + needHeight * height,
			x2: x$1 + width,
			y2: y$1 + needHeight * height
		});
	} else {
		var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
		props = _objectSpread$12(_objectSpread$12({}, props), {}, {
			x1: x$1 + needWidth * width,
			y1: y$1,
			x2: x$1 + needWidth * width,
			y2: y$1 + height
		});
	}
	return /* @__PURE__ */ import_react.createElement("line", _extends$17({}, props, { className: clsx("recharts-cartesian-axis-line", (0, import_get$3.default)(axisLine, "className")) }));
}
/**
* Calculate the coordinates of endpoints in ticks.
* @param data The data of a simple tick.
* @param x The x-coordinate of the axis.
* @param y The y-coordinate of the axis.
* @param width The width of the axis.
* @param height The height of the axis.
* @param orientation The orientation of the axis.
* @param tickSize The length of the tick line.
* @param mirror If true, the ticks are mirrored.
* @param tickMargin The margin between the tick line and the tick text.
* @returns An object with `line` and `tick` coordinates.
* `line` is the coordinates for the tick line, and `tick` is the coordinate for the tick text.
*/
function getTickLineCoord(data, x$1, y$1, width, height, orientation, tickSize, mirror, tickMargin) {
	var x1, x2, y1, y2, tx, ty;
	var sign$1 = mirror ? -1 : 1;
	var finalTickSize = data.tickSize || tickSize;
	var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
	switch (orientation) {
		case "top":
			x1 = x2 = data.coordinate;
			y2 = y$1 + +!mirror * height;
			y1 = y2 - sign$1 * finalTickSize;
			ty = y1 - sign$1 * tickMargin;
			tx = tickCoord;
			break;
		case "left":
			y1 = y2 = data.coordinate;
			x2 = x$1 + +!mirror * width;
			x1 = x2 - sign$1 * finalTickSize;
			tx = x1 - sign$1 * tickMargin;
			ty = tickCoord;
			break;
		case "right":
			y1 = y2 = data.coordinate;
			x2 = x$1 + +mirror * width;
			x1 = x2 + sign$1 * finalTickSize;
			tx = x1 + sign$1 * tickMargin;
			ty = tickCoord;
			break;
		default:
			x1 = x2 = data.coordinate;
			y2 = y$1 + +mirror * height;
			y1 = y2 + sign$1 * finalTickSize;
			ty = y1 + sign$1 * tickMargin;
			tx = tickCoord;
			break;
	}
	return {
		line: {
			x1,
			y1,
			x2,
			y2
		},
		tick: {
			x: tx,
			y: ty
		}
	};
}
/**
* @param orientation The orientation of the axis.
* @param mirror If true, the ticks are mirrored.
* @returns The text anchor of the tick.
*/
function getTickTextAnchor(orientation, mirror) {
	switch (orientation) {
		case "left": return mirror ? "start" : "end";
		case "right": return mirror ? "end" : "start";
		default: return "middle";
	}
}
/**
* @param orientation The orientation of the axis.
* @param mirror If true, the ticks are mirrored.
* @returns The vertical text anchor of the tick.
*/
function getTickVerticalAnchor(orientation, mirror) {
	switch (orientation) {
		case "left":
		case "right": return "middle";
		case "top": return mirror ? "start" : "end";
		default: return mirror ? "end" : "start";
	}
}
function TickItem(props) {
	var { option, tickProps, value } = props;
	var tickItem;
	var combinedClassName = clsx(tickProps.className, "recharts-cartesian-axis-tick-value");
	if (/* @__PURE__ */ import_react.isValidElement(option)) tickItem = /* @__PURE__ */ import_react.cloneElement(option, _objectSpread$12(_objectSpread$12({}, tickProps), {}, { className: combinedClassName }));
	else if (typeof option === "function") tickItem = option(_objectSpread$12(_objectSpread$12({}, tickProps), {}, { className: combinedClassName }));
	else {
		var className = "recharts-cartesian-axis-tick-value";
		if (typeof option !== "boolean") className = clsx(className, option === null || option === void 0 ? void 0 : option.className);
		tickItem = /* @__PURE__ */ import_react.createElement(Text, _extends$17({}, tickProps, { className }), value);
	}
	return tickItem;
}
function Ticks(props) {
	var { ticks: ticks$1 = [], tick, tickLine, stroke, tickFormatter, unit: unit$1, padding, tickTextProps, orientation, mirror, x: x$1, y: y$1, width, height, tickSize, tickMargin, fontSize, letterSpacing, getTicksConfig, events } = props;
	var finalTicks = getTicks(_objectSpread$12(_objectSpread$12({}, getTicksConfig), {}, { ticks: ticks$1 }), fontSize, letterSpacing);
	var textAnchor = getTickTextAnchor(orientation, mirror);
	var verticalAnchor = getTickVerticalAnchor(orientation, mirror);
	var axisProps = svgPropertiesNoEvents(getTicksConfig);
	var customTickProps = svgPropertiesNoEventsFromUnknown(tick);
	var tickLinePropsObject = {};
	if (typeof tickLine === "object") tickLinePropsObject = tickLine;
	var tickLineProps = _objectSpread$12(_objectSpread$12({}, axisProps), {}, { fill: "none" }, tickLinePropsObject);
	var items = finalTicks.map((entry, i) => {
		var { line: lineCoord, tick: tickCoord } = getTickLineCoord(entry, x$1, y$1, width, height, orientation, tickSize, mirror, tickMargin);
		var tickProps = _objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12({
			textAnchor,
			verticalAnchor
		}, axisProps), {}, {
			stroke: "none",
			fill: stroke
		}, customTickProps), tickCoord), {}, {
			index: i,
			payload: entry,
			visibleTicksCount: finalTicks.length,
			tickFormatter,
			padding
		}, tickTextProps);
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$17({
			className: "recharts-cartesian-axis-tick",
			key: "tick-".concat(entry.value, "-").concat(entry.coordinate, "-").concat(entry.tickCoord)
		}, adaptEventsOfChild(events, entry, i)), tickLine && /* @__PURE__ */ import_react.createElement("line", _extends$17({}, tickLineProps, lineCoord, { className: clsx("recharts-cartesian-axis-tick-line", (0, import_get$3.default)(tickLine, "className")) })), tick && /* @__PURE__ */ import_react.createElement(TickItem, {
			option: tick,
			tickProps,
			value: "".concat(typeof tickFormatter === "function" ? tickFormatter(entry.value, i) : entry.value).concat(unit$1 || "")
		}));
	});
	if (items.length > 0) return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-axis-ticks" }, items);
	return null;
}
var CartesianAxisComponent = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { axisLine, width, height, className, hide, ticks: ticks$1 } = props, rest = _objectWithoutProperties$14(props, _excluded$14);
	var [fontSize, setFontSize] = (0, import_react.useState)("");
	var [letterSpacing, setLetterSpacing] = (0, import_react.useState)("");
	var tickRefs = (0, import_react.useRef)(null);
	(0, import_react.useImperativeHandle)(ref, () => ({ getCalculatedWidth: () => {
		var _props$labelRef;
		return getCalculatedYAxisWidth({
			ticks: tickRefs.current,
			label: (_props$labelRef = props.labelRef) === null || _props$labelRef === void 0 ? void 0 : _props$labelRef.current,
			labelGapWithTick: 5,
			tickSize: props.tickSize,
			tickMargin: props.tickMargin
		});
	} }));
	var layerRef = (0, import_react.useCallback)((el) => {
		if (el) {
			var tickNodes = el.getElementsByClassName("recharts-cartesian-axis-tick-value");
			tickRefs.current = tickNodes;
			var tick = tickNodes[0];
			if (tick) {
				var computedStyle = window.getComputedStyle(tick);
				var calculatedFontSize = computedStyle.fontSize;
				var calculatedLetterSpacing = computedStyle.letterSpacing;
				if (calculatedFontSize !== fontSize || calculatedLetterSpacing !== letterSpacing) {
					setFontSize(calculatedFontSize);
					setLetterSpacing(calculatedLetterSpacing);
				}
			}
		}
	}, [fontSize, letterSpacing]);
	if (hide) return null;
	if (width != null && width <= 0 || height != null && height <= 0) return null;
	return /* @__PURE__ */ import_react.createElement(Layer, {
		className: clsx("recharts-cartesian-axis", className),
		ref: layerRef
	}, /* @__PURE__ */ import_react.createElement(AxisLine, {
		x: props.x,
		y: props.y,
		width,
		height,
		orientation: props.orientation,
		mirror: props.mirror,
		axisLine,
		otherSvgProps: svgPropertiesNoEvents(props)
	}), /* @__PURE__ */ import_react.createElement(Ticks, {
		ticks: ticks$1,
		tick: props.tick,
		tickLine: props.tickLine,
		stroke: props.stroke,
		tickFormatter: props.tickFormatter,
		unit: props.unit,
		padding: props.padding,
		tickTextProps: props.tickTextProps,
		orientation: props.orientation,
		mirror: props.mirror,
		x: props.x,
		y: props.y,
		width: props.width,
		height: props.height,
		tickSize: props.tickSize,
		tickMargin: props.tickMargin,
		fontSize,
		letterSpacing,
		getTicksConfig: props,
		events: rest
	}), /* @__PURE__ */ import_react.createElement(CartesianLabelContextProvider, {
		x: props.x,
		y: props.y,
		width: props.width,
		height: props.height
	}, /* @__PURE__ */ import_react.createElement(CartesianLabelFromLabelProp, {
		label: props.label,
		labelRef: props.labelRef
	}), props.children));
});
var MemoCartesianAxis = /* @__PURE__ */ import_react.memo(CartesianAxisComponent, (prevProps, nextProps) => {
	var { viewBox: prevViewBox } = prevProps, prevRestProps = _objectWithoutProperties$14(prevProps, _excluded2$8);
	var { viewBox: nextViewBox } = nextProps, nextRestProps = _objectWithoutProperties$14(nextProps, _excluded3$5);
	return shallowEqual(prevViewBox, nextViewBox) && shallowEqual(prevRestProps, nextRestProps);
});
var CartesianAxis = /* @__PURE__ */ import_react.forwardRef((outsideProps, ref) => {
	var props = resolveDefaultProps(outsideProps, defaultCartesianAxisProps);
	return /* @__PURE__ */ import_react.createElement(MemoCartesianAxis, _extends$17({}, props, { ref }));
});
CartesianAxis.displayName = "CartesianAxis";

//#endregion
//#region node_modules/recharts/es6/cartesian/CartesianGrid.js
var _excluded$13 = [
	"x1",
	"y1",
	"x2",
	"y2",
	"key"
], _excluded2$7 = ["offset"], _excluded3$4 = ["xAxisId", "yAxisId"], _excluded4$2 = ["xAxisId", "yAxisId"];
function ownKeys$11(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$11(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$11(Object(t), !0).forEach(function(r$2) {
			_defineProperty$12(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$11(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$12(e, r$1, t) {
	return (r$1 = _toPropertyKey$12(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$12(t) {
	var i = _toPrimitive$12(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$12(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$16() {
	return _extends$16 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$16.apply(null, arguments);
}
function _objectWithoutProperties$13(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$13(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$13(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
/**
* The <CartesianGrid horizontal
*/
var Background = (props) => {
	var { fill } = props;
	if (!fill || fill === "none") return null;
	var { fillOpacity, x: x$1, y: y$1, width, height, ry } = props;
	return /* @__PURE__ */ import_react.createElement("rect", {
		x: x$1,
		y: y$1,
		ry,
		width,
		height,
		stroke: "none",
		fill,
		fillOpacity,
		className: "recharts-cartesian-grid-bg"
	});
};
function renderLineItem(option, props) {
	var lineItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) lineItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") lineItem = option(props);
	else {
		var { x1, y1, x2, y2, key } = props, others = _objectWithoutProperties$13(props, _excluded$13);
		var _svgPropertiesNoEvent = svgPropertiesNoEvents(others), { offset: __ } = _svgPropertiesNoEvent, restOfFilteredProps = _objectWithoutProperties$13(_svgPropertiesNoEvent, _excluded2$7);
		lineItem = /* @__PURE__ */ import_react.createElement("line", _extends$16({}, restOfFilteredProps, {
			x1,
			y1,
			x2,
			y2,
			fill: "none",
			key
		}));
	}
	return lineItem;
}
function HorizontalGridLines(props) {
	var { x: x$1, width, horizontal = true, horizontalPoints } = props;
	if (!horizontal || !horizontalPoints || !horizontalPoints.length) return null;
	var { xAxisId, yAxisId } = props, otherLineItemProps = _objectWithoutProperties$13(props, _excluded3$4);
	var items = horizontalPoints.map((entry, i) => {
		var lineItemProps = _objectSpread$11(_objectSpread$11({}, otherLineItemProps), {}, {
			x1: x$1,
			y1: entry,
			x2: x$1 + width,
			y2: entry,
			key: "line-".concat(i),
			index: i
		});
		return renderLineItem(horizontal, lineItemProps);
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-horizontal" }, items);
}
function VerticalGridLines(props) {
	var { y: y$1, height, vertical = true, verticalPoints } = props;
	if (!vertical || !verticalPoints || !verticalPoints.length) return null;
	var { xAxisId, yAxisId } = props, otherLineItemProps = _objectWithoutProperties$13(props, _excluded4$2);
	var items = verticalPoints.map((entry, i) => {
		var lineItemProps = _objectSpread$11(_objectSpread$11({}, otherLineItemProps), {}, {
			x1: entry,
			y1: y$1,
			x2: entry,
			y2: y$1 + height,
			key: "line-".concat(i),
			index: i
		});
		return renderLineItem(vertical, lineItemProps);
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid-vertical" }, items);
}
function HorizontalStripes(props) {
	var { horizontalFill, fillOpacity, x: x$1, y: y$1, width, height, horizontalPoints, horizontal = true } = props;
	if (!horizontal || !horizontalFill || !horizontalFill.length) return null;
	var roundedSortedHorizontalPoints = horizontalPoints.map((e) => Math.round(e + y$1 - y$1)).sort((a$1, b) => a$1 - b);
	if (y$1 !== roundedSortedHorizontalPoints[0]) roundedSortedHorizontalPoints.unshift(0);
	var items = roundedSortedHorizontalPoints.map((entry, i) => {
		var lineHeight = !roundedSortedHorizontalPoints[i + 1] ? y$1 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
		if (lineHeight <= 0) return null;
		var colorIndex = i % horizontalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i),
			y: entry,
			x: x$1,
			height: lineHeight,
			width,
			stroke: "none",
			fill: horizontalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-horizontal" }, items);
}
function VerticalStripes(props) {
	var { vertical = true, verticalFill, fillOpacity, x: x$1, y: y$1, width, height, verticalPoints } = props;
	if (!vertical || !verticalFill || !verticalFill.length) return null;
	var roundedSortedVerticalPoints = verticalPoints.map((e) => Math.round(e + x$1 - x$1)).sort((a$1, b) => a$1 - b);
	if (x$1 !== roundedSortedVerticalPoints[0]) roundedSortedVerticalPoints.unshift(0);
	var items = roundedSortedVerticalPoints.map((entry, i) => {
		var lineWidth = !roundedSortedVerticalPoints[i + 1] ? x$1 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
		if (lineWidth <= 0) return null;
		var colorIndex = i % verticalFill.length;
		return /* @__PURE__ */ import_react.createElement("rect", {
			key: "react-".concat(i),
			x: entry,
			y: y$1,
			width: lineWidth,
			height,
			stroke: "none",
			fill: verticalFill[colorIndex],
			fillOpacity,
			className: "recharts-cartesian-grid-bg"
		});
	});
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-gridstripes-vertical" }, items);
}
var defaultVerticalCoordinatesGenerator = (_ref$1, syncWithTicks) => {
	var { xAxis, width, height, offset } = _ref$1;
	return getCoordinatesOfGrid(getTicks(_objectSpread$11(_objectSpread$11(_objectSpread$11({}, defaultCartesianAxisProps), xAxis), {}, {
		ticks: getTicksOfAxis(xAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.left, offset.left + offset.width, syncWithTicks);
};
var defaultHorizontalCoordinatesGenerator = (_ref2, syncWithTicks) => {
	var { yAxis, width, height, offset } = _ref2;
	return getCoordinatesOfGrid(getTicks(_objectSpread$11(_objectSpread$11(_objectSpread$11({}, defaultCartesianAxisProps), yAxis), {}, {
		ticks: getTicksOfAxis(yAxis, true),
		viewBox: {
			x: 0,
			y: 0,
			width,
			height
		}
	})), offset.top, offset.top + offset.height, syncWithTicks);
};
var defaultProps$6 = {
	horizontal: true,
	vertical: true,
	horizontalPoints: [],
	verticalPoints: [],
	stroke: "#ccc",
	fill: "none",
	verticalFill: [],
	horizontalFill: [],
	xAxisId: 0,
	yAxisId: 0
};
function CartesianGrid(props) {
	var chartWidth = useChartWidth();
	var chartHeight = useChartHeight();
	var offset = useOffsetInternal();
	var propsIncludingDefaults = _objectSpread$11(_objectSpread$11({}, resolveDefaultProps(props, defaultProps$6)), {}, {
		x: isNumber(props.x) ? props.x : offset.left,
		y: isNumber(props.y) ? props.y : offset.top,
		width: isNumber(props.width) ? props.width : offset.width,
		height: isNumber(props.height) ? props.height : offset.height
	});
	var { xAxisId, yAxisId, x: x$1, y: y$1, width, height, syncWithTicks, horizontalValues, verticalValues } = propsIncludingDefaults;
	var isPanorama = useIsPanorama();
	var xAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "xAxis", xAxisId, isPanorama));
	var yAxis = useAppSelector((state) => selectAxisPropsNeededForCartesianGridTicksGenerator(state, "yAxis", yAxisId, isPanorama));
	if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x$1) || x$1 !== +x$1 || !isNumber(y$1) || y$1 !== +y$1) return null;
	var verticalCoordinatesGenerator = propsIncludingDefaults.verticalCoordinatesGenerator || defaultVerticalCoordinatesGenerator;
	var horizontalCoordinatesGenerator = propsIncludingDefaults.horizontalCoordinatesGenerator || defaultHorizontalCoordinatesGenerator;
	var { horizontalPoints, verticalPoints } = propsIncludingDefaults;
	if ((!horizontalPoints || !horizontalPoints.length) && typeof horizontalCoordinatesGenerator === "function") {
		var isHorizontalValues = horizontalValues && horizontalValues.length;
		var generatorResult = horizontalCoordinatesGenerator({
			yAxis: yAxis ? _objectSpread$11(_objectSpread$11({}, yAxis), {}, { ticks: isHorizontalValues ? horizontalValues : yAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isHorizontalValues ? true : syncWithTicks);
		warn(Array.isArray(generatorResult), "horizontalCoordinatesGenerator should return Array but instead it returned [".concat(typeof generatorResult, "]"));
		if (Array.isArray(generatorResult)) horizontalPoints = generatorResult;
	}
	if ((!verticalPoints || !verticalPoints.length) && typeof verticalCoordinatesGenerator === "function") {
		var isVerticalValues = verticalValues && verticalValues.length;
		var _generatorResult = verticalCoordinatesGenerator({
			xAxis: xAxis ? _objectSpread$11(_objectSpread$11({}, xAxis), {}, { ticks: isVerticalValues ? verticalValues : xAxis.ticks }) : void 0,
			width: chartWidth,
			height: chartHeight,
			offset
		}, isVerticalValues ? true : syncWithTicks);
		warn(Array.isArray(_generatorResult), "verticalCoordinatesGenerator should return Array but instead it returned [".concat(typeof _generatorResult, "]"));
		if (Array.isArray(_generatorResult)) verticalPoints = _generatorResult;
	}
	return /* @__PURE__ */ import_react.createElement("g", { className: "recharts-cartesian-grid" }, /* @__PURE__ */ import_react.createElement(Background, {
		fill: propsIncludingDefaults.fill,
		fillOpacity: propsIncludingDefaults.fillOpacity,
		x: propsIncludingDefaults.x,
		y: propsIncludingDefaults.y,
		width: propsIncludingDefaults.width,
		height: propsIncludingDefaults.height,
		ry: propsIncludingDefaults.ry
	}), /* @__PURE__ */ import_react.createElement(HorizontalStripes, _extends$16({}, propsIncludingDefaults, { horizontalPoints })), /* @__PURE__ */ import_react.createElement(VerticalStripes, _extends$16({}, propsIncludingDefaults, { verticalPoints })), /* @__PURE__ */ import_react.createElement(HorizontalGridLines, _extends$16({}, propsIncludingDefaults, {
		offset,
		horizontalPoints,
		xAxis,
		yAxis
	})), /* @__PURE__ */ import_react.createElement(VerticalGridLines, _extends$16({}, propsIncludingDefaults, {
		offset,
		verticalPoints,
		xAxis,
		yAxis
	})));
}
CartesianGrid.displayName = "CartesianGrid";

//#endregion
//#region node_modules/recharts/es6/state/selectors/lineSelectors.js
var selectXAxisWithScale$2 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectXAxisTicks$2 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale$2 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectYAxisTicks$2 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectBandSize$1 = createSelector([
	selectChartLayout,
	selectXAxisWithScale$2,
	selectYAxisWithScale$2,
	selectXAxisTicks$2,
	selectYAxisTicks$2
], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
	if (isCategoricalAxis(layout, "xAxis")) return getBandSizeOfAxis(xAxis, xAxisTicks, false);
	return getBandSizeOfAxis(yAxis, yAxisTicks, false);
});
var pickLineId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
function isLineSettings(item) {
	return item.type === "line";
}
var selectSynchronisedLineSettings = createSelector([selectUnfilteredCartesianItems, pickLineId], (graphicalItems, id) => graphicalItems.filter(isLineSettings).find((x$1) => x$1.id === id));
var selectLinePoints = createSelector([
	selectChartLayout,
	selectXAxisWithScale$2,
	selectYAxisWithScale$2,
	selectXAxisTicks$2,
	selectYAxisTicks$2,
	selectSynchronisedLineSettings,
	selectBandSize$1,
	selectChartDataWithIndexesIfNotInPanorama
], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, lineSettings, bandSize, _ref$1) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref$1;
	if (lineSettings == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) return;
	var { dataKey, data } = lineSettings;
	var displayedData;
	if (data != null && data.length > 0) displayedData = data;
	else displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
	if (displayedData == null) return;
	return computeLinePoints({
		layout,
		xAxis,
		yAxis,
		xAxisTicks,
		yAxisTicks,
		dataKey,
		bandSize,
		displayedData
	});
});

//#endregion
//#region node_modules/recharts/es6/util/getRadiusAndStrokeWidthFromDot.js
function getRadiusAndStrokeWidthFromDot(dot) {
	var props = svgPropertiesNoEventsFromUnknown(dot);
	var defaultR = 3;
	var defaultStrokeWidth = 2;
	if (props != null) {
		var { r: r$1, strokeWidth } = props;
		var realR = Number(r$1);
		var realStrokeWidth = Number(strokeWidth);
		if (Number.isNaN(realR) || realR < 0) realR = defaultR;
		if (Number.isNaN(realStrokeWidth) || realStrokeWidth < 0) realStrokeWidth = defaultStrokeWidth;
		return {
			r: realR,
			strokeWidth: realStrokeWidth
		};
	}
	return {
		r: defaultR,
		strokeWidth: defaultStrokeWidth
	};
}

//#endregion
//#region node_modules/recharts/es6/cartesian/Line.js
var _excluded$12 = ["id"], _excluded2$6 = [
	"type",
	"layout",
	"connectNulls",
	"needClip"
], _excluded3$3 = [
	"activeDot",
	"animateNewValues",
	"animationBegin",
	"animationDuration",
	"animationEasing",
	"connectNulls",
	"dot",
	"hide",
	"isAnimationActive",
	"label",
	"legendType",
	"xAxisId",
	"yAxisId",
	"id"
];
function ownKeys$10(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$10(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$10(Object(t), !0).forEach(function(r$2) {
			_defineProperty$11(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$10(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$11(e, r$1, t) {
	return (r$1 = _toPropertyKey$11(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$11(t) {
	var i = _toPrimitive$11(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$11(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$12(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$12(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$12(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$15() {
	return _extends$15 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$15.apply(null, arguments);
}
/**
* Internal props, combination of external props + defaultProps + private Recharts state
*/
/**
* External props, intended for end users to fill in
*/
/**
* Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.
*/
var computeLegendPayloadFromAreaData$1 = (props) => {
	var { dataKey, name, stroke, legendType, hide } = props;
	return [{
		inactive: hide,
		dataKey,
		type: legendType,
		color: stroke,
		value: getTooltipNameProp(name, dataKey),
		payload: props
	}];
};
function getTooltipEntrySettings$6(props) {
	var { dataKey, data, stroke, strokeWidth, fill, name, hide, unit: unit$1 } = props;
	return {
		dataDefinedOnItem: data,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			nameKey: void 0,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: props.tooltipType,
			color: props.stroke,
			unit: unit$1
		}
	};
}
var generateSimpleStrokeDasharray = (totalLength, length) => {
	return "".concat(length, "px ").concat(totalLength - length, "px");
};
function repeat(lines, count) {
	var linesUnit = lines.length % 2 !== 0 ? [...lines, 0] : lines;
	var result = [];
	for (var i = 0; i < count; ++i) result = [...result, ...linesUnit];
	return result;
}
var getStrokeDasharray = (length, totalLength, lines) => {
	var lineLength = lines.reduce((pre, next) => pre + next);
	if (!lineLength) return generateSimpleStrokeDasharray(totalLength, length);
	var count = Math.floor(length / lineLength);
	var remainLength = length % lineLength;
	var restLength = totalLength - length;
	var remainLines = [];
	for (var i = 0, sum = 0; i < lines.length; sum += lines[i], ++i) if (sum + lines[i] > remainLength) {
		remainLines = [...lines.slice(0, i), remainLength - sum];
		break;
	}
	var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
	return [
		...repeat(lines, count),
		...remainLines,
		...emptyLines
	].map((line) => "".concat(line, "px")).join(", ");
};
function renderDotItem$1(option, props) {
	var dotItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dotItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") dotItem = option(props);
	else {
		var className = clsx("recharts-line-dot", typeof option !== "boolean" ? option.className : "");
		dotItem = /* @__PURE__ */ import_react.createElement(Dot, _extends$15({}, props, { className }));
	}
	return dotItem;
}
function shouldRenderDots$1(points, dot) {
	if (points == null) return false;
	if (dot) return true;
	return points.length === 1;
}
function Dots$1(_ref$1) {
	var { clipPathId, points, props } = _ref$1;
	var { dot, dataKey, needClip } = props;
	if (!shouldRenderDots$1(points, dot)) return null;
	var { id } = props, propsWithoutId = _objectWithoutProperties$12(props, _excluded$12);
	var clipDot = isClipDot(dot);
	var lineProps = svgPropertiesNoEvents(propsWithoutId);
	var customDotProps = svgPropertiesAndEventsFromUnknown(dot);
	var dots = points.map((entry, i) => {
		var dotProps = _objectSpread$10(_objectSpread$10(_objectSpread$10({
			key: "dot-".concat(i),
			r: 3
		}, lineProps), customDotProps), {}, {
			index: i,
			cx: entry.x,
			cy: entry.y,
			dataKey,
			value: entry.value,
			payload: entry.payload,
			points
		});
		return renderDotItem$1(dot, dotProps);
	});
	var dotsProps = { clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0 };
	return /* @__PURE__ */ import_react.createElement(Layer, _extends$15({
		className: "recharts-line-dots",
		key: "dots"
	}, dotsProps), dots);
}
function LineLabelListProvider(_ref2) {
	var { showLabels, children, points } = _ref2;
	var labelListEntries = (0, import_react.useMemo)(() => {
		return points === null || points === void 0 ? void 0 : points.map((point$3) => {
			var viewBox = {
				x: point$3.x,
				y: point$3.y,
				width: 0,
				height: 0
			};
			return _objectSpread$10(_objectSpread$10({}, viewBox), {}, {
				value: point$3.value,
				payload: point$3.payload,
				viewBox,
				parentViewBox: void 0,
				fill: void 0
			});
		});
	}, [points]);
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: showLabels ? labelListEntries : null }, children);
}
function StaticCurve(_ref3) {
	var { clipPathId, pathRef, points, strokeDasharray, props } = _ref3;
	var { type, layout, connectNulls, needClip } = props, others = _objectWithoutProperties$12(props, _excluded2$6);
	var curveProps = _objectSpread$10(_objectSpread$10({}, svgPropertiesAndEvents(others)), {}, {
		fill: "none",
		className: "recharts-line-curve",
		clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0,
		points,
		type,
		layout,
		connectNulls,
		strokeDasharray: strokeDasharray !== null && strokeDasharray !== void 0 ? strokeDasharray : props.strokeDasharray
	});
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ import_react.createElement(Curve, _extends$15({}, curveProps, { pathRef })), /* @__PURE__ */ import_react.createElement(Dots$1, {
		points,
		clipPathId,
		props
	}));
}
function getTotalLength(mainCurve) {
	try {
		return mainCurve && mainCurve.getTotalLength && mainCurve.getTotalLength() || 0;
	} catch (_unused) {
		return 0;
	}
}
function CurveWithAnimation(_ref4) {
	var { clipPathId, props, pathRef, previousPointsRef, longestAnimatedLengthRef } = _ref4;
	var { points, strokeDasharray, isAnimationActive, animationBegin, animationDuration, animationEasing, animateNewValues, width, height, onAnimationEnd, onAnimationStart } = props;
	var prevPoints = previousPointsRef.current;
	var animationId = useAnimationId(props, "recharts-line-");
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var showLabels = !isAnimating;
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	var totalLength = getTotalLength(pathRef.current);
	var startingPoint = longestAnimatedLengthRef.current;
	return /* @__PURE__ */ import_react.createElement(LineLabelListProvider, {
		points,
		showLabels
	}, props.children, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationEnd: handleAnimationEnd,
		onAnimationStart: handleAnimationStart,
		key: animationId
	}, (t) => {
		var lengthInterpolated = interpolate(startingPoint, totalLength + startingPoint, t);
		var curLength = Math.min(lengthInterpolated, totalLength);
		var currentStrokeDasharray;
		if (isAnimationActive) if (strokeDasharray) {
			var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map((num) => parseFloat(num));
			currentStrokeDasharray = getStrokeDasharray(curLength, totalLength, lines);
		} else currentStrokeDasharray = generateSimpleStrokeDasharray(totalLength, curLength);
		else currentStrokeDasharray = strokeDasharray == null ? void 0 : String(strokeDasharray);
		if (prevPoints) {
			var prevPointsDiffFactor = prevPoints.length / points.length;
			var stepData = t === 1 ? points : points.map((entry, index) => {
				var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
				if (prevPoints[prevPointIndex]) {
					var prev = prevPoints[prevPointIndex];
					return _objectSpread$10(_objectSpread$10({}, entry), {}, {
						x: interpolate(prev.x, entry.x, t),
						y: interpolate(prev.y, entry.y, t)
					});
				}
				if (animateNewValues) return _objectSpread$10(_objectSpread$10({}, entry), {}, {
					x: interpolate(width * 2, entry.x, t),
					y: interpolate(height / 2, entry.y, t)
				});
				return _objectSpread$10(_objectSpread$10({}, entry), {}, {
					x: entry.x,
					y: entry.y
				});
			});
			previousPointsRef.current = stepData;
			return /* @__PURE__ */ import_react.createElement(StaticCurve, {
				props,
				points: stepData,
				clipPathId,
				pathRef,
				strokeDasharray: currentStrokeDasharray
			});
		}
		if (t > 0 && totalLength > 0) {
			previousPointsRef.current = points;
			longestAnimatedLengthRef.current = curLength;
		}
		return /* @__PURE__ */ import_react.createElement(StaticCurve, {
			props,
			points,
			clipPathId,
			pathRef,
			strokeDasharray: currentStrokeDasharray
		});
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }));
}
function RenderCurve(_ref5) {
	var { clipPathId, props } = _ref5;
	var previousPointsRef = (0, import_react.useRef)(null);
	var longestAnimatedLengthRef = (0, import_react.useRef)(0);
	var pathRef = (0, import_react.useRef)(null);
	return /* @__PURE__ */ import_react.createElement(CurveWithAnimation, {
		props,
		clipPathId,
		previousPointsRef,
		longestAnimatedLengthRef,
		pathRef
	});
}
var errorBarDataPointFormatter$1 = (dataPoint, dataKey) => {
	return {
		x: dataPoint.x,
		y: dataPoint.y,
		value: dataPoint.value,
		errorVal: getValueByDataKey(dataPoint.payload, dataKey)
	};
};
var LineWithState = class extends import_react.Component {
	render() {
		var { hide, dot, points, className, xAxisId, yAxisId, top, left, width, height, id, needClip } = this.props;
		if (hide) return null;
		var layerClass = clsx("recharts-line", className);
		var clipPathId = id;
		var { r: r$1, strokeWidth } = getRadiusAndStrokeWidthFromDot(dot);
		var clipDot = isClipDot(dot);
		var dotSize = r$1 * 2 + strokeWidth;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClip && /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement(GraphicalItemClipPath, {
			clipPathId,
			xAxisId,
			yAxisId
		}), !clipDot && /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-dots-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
			x: left - dotSize / 2,
			y: top - dotSize / 2,
			width: width + dotSize,
			height: height + dotSize
		}))), /* @__PURE__ */ import_react.createElement(SetErrorBarContext, {
			xAxisId,
			yAxisId,
			data: points,
			dataPointFormatter: errorBarDataPointFormatter$1,
			errorBarOffset: 0
		}, /* @__PURE__ */ import_react.createElement(RenderCurve, {
			props: this.props,
			clipPathId
		}))), /* @__PURE__ */ import_react.createElement(ActivePoints, {
			activeDot: this.props.activeDot,
			points,
			mainColor: this.props.stroke,
			itemDataKey: this.props.dataKey
		}));
	}
};
var defaultLineProps = {
	activeDot: true,
	animateNewValues: true,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease",
	connectNulls: false,
	dot: true,
	fill: "#fff",
	hide: false,
	isAnimationActive: !Global.isSsr,
	label: false,
	legendType: "line",
	stroke: "#3182bd",
	strokeWidth: 1,
	xAxisId: 0,
	yAxisId: 0
};
function LineImpl(props) {
	var _resolveDefaultProps = resolveDefaultProps(props, defaultLineProps), { activeDot, animateNewValues, animationBegin, animationDuration, animationEasing, connectNulls, dot, hide, isAnimationActive, label, legendType, xAxisId, yAxisId, id } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$12(_resolveDefaultProps, _excluded3$3);
	var { needClip } = useNeedsClip(xAxisId, yAxisId);
	var plotArea = usePlotArea();
	var layout = useChartLayout();
	var isPanorama = useIsPanorama();
	var points = useAppSelector((state) => selectLinePoints(state, xAxisId, yAxisId, isPanorama, id));
	if (layout !== "horizontal" && layout !== "vertical" || points == null || plotArea == null) return null;
	var { height, width, x: left, y: top } = plotArea;
	return /* @__PURE__ */ import_react.createElement(LineWithState, _extends$15({}, everythingElse, {
		id,
		connectNulls,
		dot,
		activeDot,
		animateNewValues,
		animationBegin,
		animationDuration,
		animationEasing,
		isAnimationActive,
		hide,
		label,
		legendType,
		xAxisId,
		yAxisId,
		points,
		layout,
		height,
		width,
		left,
		top,
		needClip
	}));
}
function computeLinePoints(_ref6) {
	var { layout, xAxis, yAxis, xAxisTicks, yAxisTicks, dataKey, bandSize, displayedData } = _ref6;
	return displayedData.map((entry, index) => {
		var value = getValueByDataKey(entry, dataKey);
		if (layout === "horizontal") {
			var _x = getCateCoordinateOfLine({
				axis: xAxis,
				ticks: xAxisTicks,
				bandSize,
				entry,
				index
			});
			var _y = isNullish(value) ? null : yAxis.scale(value);
			return {
				x: _x,
				y: _y,
				value,
				payload: entry
			};
		}
		var x$1 = isNullish(value) ? null : xAxis.scale(value);
		var y$1 = getCateCoordinateOfLine({
			axis: yAxis,
			ticks: yAxisTicks,
			bandSize,
			entry,
			index
		});
		if (x$1 == null || y$1 == null) return null;
		return {
			x: x$1,
			y: y$1,
			value,
			payload: entry
		};
	}).filter(Boolean);
}
function LineFn(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultLineProps);
	var isPanorama = useIsPanorama();
	return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
		id: props.id,
		type: "line"
	}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetLegendPayload, { legendPayload: computeLegendPayloadFromAreaData$1(props) }), /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$6,
		args: props
	}), /* @__PURE__ */ import_react.createElement(SetCartesianGraphicalItem, {
		type: "line",
		id,
		data: props.data,
		xAxisId: props.xAxisId,
		yAxisId: props.yAxisId,
		zAxisId: 0,
		dataKey: props.dataKey,
		hide: props.hide,
		isPanorama
	}), /* @__PURE__ */ import_react.createElement(LineImpl, _extends$15({}, props, { id }))));
}
var Line = /* @__PURE__ */ import_react.memo(LineFn);
Line.displayName = "Line";

//#endregion
//#region node_modules/recharts/es6/state/selectors/areaSelectors.js
var selectXAxisWithScale$1 = (state, xAxisId, _yAxisId, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectXAxisTicks$1 = (state, xAxisId, _yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale$1 = (state, _xAxisId, yAxisId, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectYAxisTicks$1 = (state, _xAxisId, yAxisId, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectBandSize = createSelector([
	selectChartLayout,
	selectXAxisWithScale$1,
	selectYAxisWithScale$1,
	selectXAxisTicks$1,
	selectYAxisTicks$1
], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks) => {
	if (isCategoricalAxis(layout, "xAxis")) return getBandSizeOfAxis(xAxis, xAxisTicks, false);
	return getBandSizeOfAxis(yAxis, yAxisTicks, false);
});
var pickAreaId = (_state, _xAxisId, _yAxisId, _isPanorama, id) => id;
var selectSynchronisedAreaSettings = createSelector([selectUnfilteredCartesianItems, pickAreaId], (graphicalItems, id) => graphicalItems.filter((item) => item.type === "area").find((item) => item.id === id));
var selectGraphicalItemStackedData = (state, xAxisId, yAxisId, isPanorama, id) => {
	var _stackGroups$stackId;
	var areaSettings = selectSynchronisedAreaSettings(state, xAxisId, yAxisId, isPanorama, id);
	if (areaSettings == null) return;
	var layout = selectChartLayout(state);
	var isXAxisCategorical = isCategoricalAxis(layout, "xAxis");
	var stackGroups;
	if (isXAxisCategorical) stackGroups = selectStackGroups(state, "yAxis", yAxisId, isPanorama);
	else stackGroups = selectStackGroups(state, "xAxis", xAxisId, isPanorama);
	if (stackGroups == null) return;
	var { stackId } = areaSettings;
	var stackSeriesIdentifier = getStackSeriesIdentifier(areaSettings);
	if (stackId == null || stackSeriesIdentifier == null) return;
	var groups = (_stackGroups$stackId = stackGroups[stackId]) === null || _stackGroups$stackId === void 0 ? void 0 : _stackGroups$stackId.stackedData;
	return groups === null || groups === void 0 ? void 0 : groups.find((v) => v.key === stackSeriesIdentifier);
};
var selectArea = createSelector([
	selectChartLayout,
	selectXAxisWithScale$1,
	selectYAxisWithScale$1,
	selectXAxisTicks$1,
	selectYAxisTicks$1,
	selectGraphicalItemStackedData,
	selectChartDataWithIndexesIfNotInPanorama,
	selectBandSize,
	selectSynchronisedAreaSettings
], (layout, xAxis, yAxis, xAxisTicks, yAxisTicks, stackedData, _ref$1, bandSize, areaSettings) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref$1;
	if (areaSettings == null || layout !== "horizontal" && layout !== "vertical" || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || xAxisTicks.length === 0 || yAxisTicks.length === 0 || bandSize == null) return;
	var { data } = areaSettings;
	var displayedData;
	if (data && data.length > 0) displayedData = data;
	else displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
	if (displayedData == null) return;
	return computeArea({
		layout,
		xAxis,
		yAxis,
		xAxisTicks,
		yAxisTicks,
		dataStartIndex,
		areaSettings,
		stackedData,
		displayedData,
		chartBaseValue: void 0,
		bandSize
	});
});

//#endregion
//#region node_modules/recharts/es6/cartesian/Area.js
var _excluded$11 = ["id"], _excluded2$5 = [
	"activeDot",
	"animationBegin",
	"animationDuration",
	"animationEasing",
	"connectNulls",
	"dot",
	"fill",
	"fillOpacity",
	"hide",
	"isAnimationActive",
	"legendType",
	"stroke",
	"xAxisId",
	"yAxisId"
];
function _objectWithoutProperties$11(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$11(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$11(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$9(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$9(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$9(Object(t), !0).forEach(function(r$2) {
			_defineProperty$10(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$9(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$10(e, r$1, t) {
	return (r$1 = _toPropertyKey$10(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$10(t) {
	var i = _toPrimitive$10(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$10(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$14() {
	return _extends$14 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$14.apply(null, arguments);
}
/**
* Internal props, combination of external props + defaultProps + private Recharts state
*/
/**
* External props, intended for end users to fill in
*/
/**
* Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.
*/
function getLegendItemColor(stroke, fill) {
	return stroke && stroke !== "none" ? stroke : fill;
}
var computeLegendPayloadFromAreaData = (props) => {
	var { dataKey, name, stroke, fill, legendType, hide } = props;
	return [{
		inactive: hide,
		dataKey,
		type: legendType,
		color: getLegendItemColor(stroke, fill),
		value: getTooltipNameProp(name, dataKey),
		payload: props
	}];
};
function getTooltipEntrySettings$5(props) {
	var { dataKey, data, stroke, strokeWidth, fill, name, hide, unit: unit$1 } = props;
	return {
		dataDefinedOnItem: data,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			nameKey: void 0,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: props.tooltipType,
			color: getLegendItemColor(stroke, fill),
			unit: unit$1
		}
	};
}
var renderDotItem = (option, props) => {
	var dotItem;
	if (/* @__PURE__ */ import_react.isValidElement(option)) dotItem = /* @__PURE__ */ import_react.cloneElement(option, props);
	else if (typeof option === "function") dotItem = option(props);
	else {
		var className = clsx("recharts-area-dot", typeof option !== "boolean" ? option.className : "");
		dotItem = /* @__PURE__ */ import_react.createElement(Dot, _extends$14({}, props, { className }));
	}
	return dotItem;
};
function shouldRenderDots(points, dot) {
	if (points == null) return false;
	if (dot) return true;
	return points.length === 1;
}
function Dots(_ref$1) {
	var { clipPathId, points, props } = _ref$1;
	var { needClip, dot, dataKey } = props;
	if (!shouldRenderDots(points, dot)) return null;
	var clipDot = isClipDot(dot);
	var areaProps = svgPropertiesNoEvents(props);
	var customDotProps = svgPropertiesAndEventsFromUnknown(dot);
	var dots = points.map((entry, i) => {
		var dotProps = _objectSpread$9(_objectSpread$9(_objectSpread$9({
			key: "dot-".concat(i),
			r: 3
		}, areaProps), customDotProps), {}, {
			index: i,
			cx: entry.x,
			cy: entry.y,
			dataKey,
			value: entry.value,
			payload: entry.payload,
			points
		});
		return renderDotItem(dot, dotProps);
	});
	var dotsProps = { clipPath: needClip ? "url(#clipPath-".concat(clipDot ? "" : "dots-").concat(clipPathId, ")") : void 0 };
	return /* @__PURE__ */ import_react.createElement(Layer, _extends$14({ className: "recharts-area-dots" }, dotsProps), dots);
}
function AreaLabelListProvider(_ref2) {
	var { showLabels, children, points } = _ref2;
	var labelListEntries = points.map((point$3) => {
		var viewBox = {
			x: point$3.x,
			y: point$3.y,
			width: 0,
			height: 0
		};
		return _objectSpread$9(_objectSpread$9({}, viewBox), {}, {
			value: point$3.value,
			payload: point$3.payload,
			parentViewBox: void 0,
			viewBox,
			fill: void 0
		});
	});
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: showLabels ? labelListEntries : null }, children);
}
function StaticArea(_ref3) {
	var { points, baseLine, needClip, clipPathId, props } = _ref3;
	var { layout, type, stroke, connectNulls, isRange } = props;
	var { id } = props, propsWithoutId = _objectWithoutProperties$11(props, _excluded$11);
	var allOtherProps = svgPropertiesNoEvents(propsWithoutId);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, (points === null || points === void 0 ? void 0 : points.length) > 1 && /* @__PURE__ */ import_react.createElement(Layer, { clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : void 0 }, /* @__PURE__ */ import_react.createElement(Curve, _extends$14({}, allOtherProps, {
		id,
		points,
		connectNulls,
		type,
		baseLine,
		layout,
		stroke: "none",
		className: "recharts-area-area"
	})), stroke !== "none" && /* @__PURE__ */ import_react.createElement(Curve, _extends$14({}, allOtherProps, {
		className: "recharts-area-curve",
		layout,
		type,
		connectNulls,
		fill: "none",
		points
	})), stroke !== "none" && isRange && /* @__PURE__ */ import_react.createElement(Curve, _extends$14({}, allOtherProps, {
		className: "recharts-area-curve",
		layout,
		type,
		connectNulls,
		fill: "none",
		points: baseLine
	}))), /* @__PURE__ */ import_react.createElement(Dots, {
		points,
		props: propsWithoutId,
		clipPathId
	}));
}
function VerticalRect(_ref4) {
	var { alpha: alpha$1, baseLine, points, strokeWidth } = _ref4;
	var startY = points[0].y;
	var endY = points[points.length - 1].y;
	if (!isWellBehavedNumber(startY) || !isWellBehavedNumber(endY)) return null;
	var height = alpha$1 * Math.abs(startY - endY);
	var maxX = Math.max(...points.map((entry) => entry.x || 0));
	if (isNumber(baseLine)) maxX = Math.max(baseLine, maxX);
	else if (baseLine && Array.isArray(baseLine) && baseLine.length) maxX = Math.max(...baseLine.map((entry) => entry.x || 0), maxX);
	if (isNumber(maxX)) return /* @__PURE__ */ import_react.createElement("rect", {
		x: 0,
		y: startY < endY ? startY : startY - height,
		width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
		height: Math.floor(height)
	});
	return null;
}
function HorizontalRect(_ref5) {
	var { alpha: alpha$1, baseLine, points, strokeWidth } = _ref5;
	var startX = points[0].x;
	var endX = points[points.length - 1].x;
	if (!isWellBehavedNumber(startX) || !isWellBehavedNumber(endX)) return null;
	var width = alpha$1 * Math.abs(startX - endX);
	var maxY = Math.max(...points.map((entry) => entry.y || 0));
	if (isNumber(baseLine)) maxY = Math.max(baseLine, maxY);
	else if (baseLine && Array.isArray(baseLine) && baseLine.length) maxY = Math.max(...baseLine.map((entry) => entry.y || 0), maxY);
	if (isNumber(maxY)) return /* @__PURE__ */ import_react.createElement("rect", {
		x: startX < endX ? startX : startX - width,
		y: 0,
		width,
		height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
	});
	return null;
}
function ClipRect(_ref6) {
	var { alpha: alpha$1, layout, points, baseLine, strokeWidth } = _ref6;
	if (layout === "vertical") return /* @__PURE__ */ import_react.createElement(VerticalRect, {
		alpha: alpha$1,
		points,
		baseLine,
		strokeWidth
	});
	return /* @__PURE__ */ import_react.createElement(HorizontalRect, {
		alpha: alpha$1,
		points,
		baseLine,
		strokeWidth
	});
}
function AreaWithAnimation(_ref7) {
	var { needClip, clipPathId, props, previousPointsRef, previousBaselineRef } = _ref7;
	var { points, baseLine, isAnimationActive, animationBegin, animationDuration, animationEasing, onAnimationStart, onAnimationEnd } = props;
	var animationId = useAnimationId(props, "recharts-area-");
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var showLabels = !isAnimating;
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	var prevPoints = previousPointsRef.current;
	var prevBaseLine = previousBaselineRef.current;
	return /* @__PURE__ */ import_react.createElement(AreaLabelListProvider, {
		showLabels,
		points
	}, props.children, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationEnd: handleAnimationEnd,
		onAnimationStart: handleAnimationStart,
		key: animationId
	}, (t) => {
		if (prevPoints) {
			var prevPointsDiffFactor = prevPoints.length / points.length;
			var stepPoints = t === 1 ? points : points.map((entry, index) => {
				var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
				if (prevPoints[prevPointIndex]) {
					var prev = prevPoints[prevPointIndex];
					return _objectSpread$9(_objectSpread$9({}, entry), {}, {
						x: interpolate(prev.x, entry.x, t),
						y: interpolate(prev.y, entry.y, t)
					});
				}
				return entry;
			});
			var stepBaseLine;
			if (isNumber(baseLine)) stepBaseLine = interpolate(prevBaseLine, baseLine, t);
			else if (isNullish(baseLine) || isNan(baseLine)) stepBaseLine = interpolate(prevBaseLine, 0, t);
			else stepBaseLine = baseLine.map((entry, index) => {
				var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
				if (Array.isArray(prevBaseLine) && prevBaseLine[prevPointIndex]) {
					var prev = prevBaseLine[prevPointIndex];
					return _objectSpread$9(_objectSpread$9({}, entry), {}, {
						x: interpolate(prev.x, entry.x, t),
						y: interpolate(prev.y, entry.y, t)
					});
				}
				return entry;
			});
			if (t > 0) {
				previousPointsRef.current = stepPoints;
				previousBaselineRef.current = stepBaseLine;
			}
			return /* @__PURE__ */ import_react.createElement(StaticArea, {
				points: stepPoints,
				baseLine: stepBaseLine,
				needClip,
				clipPathId,
				props
			});
		}
		if (t > 0) {
			previousPointsRef.current = points;
			previousBaselineRef.current = baseLine;
		}
		return /* @__PURE__ */ import_react.createElement(Layer, null, isAnimationActive && /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement("clipPath", { id: "animationClipPath-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement(ClipRect, {
			alpha: t,
			points,
			baseLine,
			layout: props.layout,
			strokeWidth: props.strokeWidth
		}))), /* @__PURE__ */ import_react.createElement(Layer, { clipPath: "url(#animationClipPath-".concat(clipPathId, ")") }, /* @__PURE__ */ import_react.createElement(StaticArea, {
			points,
			baseLine,
			needClip,
			clipPathId,
			props
		})));
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }));
}
function RenderArea(_ref8) {
	var { needClip, clipPathId, props } = _ref8;
	var previousPointsRef = (0, import_react.useRef)(null);
	var previousBaselineRef = (0, import_react.useRef)();
	return /* @__PURE__ */ import_react.createElement(AreaWithAnimation, {
		needClip,
		clipPathId,
		props,
		previousPointsRef,
		previousBaselineRef
	});
}
var AreaWithState = class extends import_react.PureComponent {
	render() {
		var { hide, dot, points, className, top, left, needClip, xAxisId, yAxisId, width, height, id, baseLine } = this.props;
		if (hide) return null;
		var layerClass = clsx("recharts-area", className);
		var clipPathId = id;
		var { r: r$1, strokeWidth } = getRadiusAndStrokeWidthFromDot(dot);
		var clipDot = isClipDot(dot);
		var dotSize = r$1 * 2 + strokeWidth;
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, needClip && /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement(GraphicalItemClipPath, {
			clipPathId,
			xAxisId,
			yAxisId
		}), !clipDot && /* @__PURE__ */ import_react.createElement("clipPath", { id: "clipPath-dots-".concat(clipPathId) }, /* @__PURE__ */ import_react.createElement("rect", {
			x: left - dotSize / 2,
			y: top - dotSize / 2,
			width: width + dotSize,
			height: height + dotSize
		}))), /* @__PURE__ */ import_react.createElement(RenderArea, {
			needClip,
			clipPathId,
			props: this.props
		})), /* @__PURE__ */ import_react.createElement(ActivePoints, {
			points,
			mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
			itemDataKey: this.props.dataKey,
			activeDot: this.props.activeDot
		}), this.props.isRange && Array.isArray(baseLine) && /* @__PURE__ */ import_react.createElement(ActivePoints, {
			points: baseLine,
			mainColor: getLegendItemColor(this.props.stroke, this.props.fill),
			itemDataKey: this.props.dataKey,
			activeDot: this.props.activeDot
		}));
	}
};
var defaultAreaProps = {
	activeDot: true,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "ease",
	connectNulls: false,
	dot: false,
	fill: "#3182bd",
	fillOpacity: .6,
	hide: false,
	isAnimationActive: !Global.isSsr,
	legendType: "line",
	stroke: "#3182bd",
	xAxisId: 0,
	yAxisId: 0
};
function AreaImpl(props) {
	var _useAppSelector;
	var _resolveDefaultProps = resolveDefaultProps(props, defaultAreaProps), { activeDot, animationBegin, animationDuration, animationEasing, connectNulls, dot, fill, fillOpacity, hide, isAnimationActive, legendType, stroke, xAxisId, yAxisId } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$11(_resolveDefaultProps, _excluded2$5);
	var layout = useChartLayout();
	var chartName = useChartName();
	var { needClip } = useNeedsClip(xAxisId, yAxisId);
	var isPanorama = useIsPanorama();
	var { points, isRange, baseLine } = (_useAppSelector = useAppSelector((state) => selectArea(state, xAxisId, yAxisId, isPanorama, props.id))) !== null && _useAppSelector !== void 0 ? _useAppSelector : {};
	var plotArea = usePlotArea();
	if (layout !== "horizontal" && layout !== "vertical" || plotArea == null) return null;
	if (chartName !== "AreaChart" && chartName !== "ComposedChart") return null;
	var { height, width, x: left, y: top } = plotArea;
	if (!points || !points.length) return null;
	return /* @__PURE__ */ import_react.createElement(AreaWithState, _extends$14({}, everythingElse, {
		activeDot,
		animationBegin,
		animationDuration,
		animationEasing,
		baseLine,
		connectNulls,
		dot,
		fill,
		fillOpacity,
		height,
		hide,
		layout,
		isAnimationActive,
		isRange,
		legendType,
		needClip,
		points,
		stroke,
		width,
		left,
		top,
		xAxisId,
		yAxisId
	}));
}
var getBaseValue = (layout, chartBaseValue, itemBaseValue, xAxis, yAxis) => {
	var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
	if (isNumber(baseValue)) return baseValue;
	var numericAxis = layout === "horizontal" ? yAxis : xAxis;
	var domain = numericAxis.scale.domain();
	if (numericAxis.type === "number") {
		var domainMax = Math.max(domain[0], domain[1]);
		var domainMin = Math.min(domain[0], domain[1]);
		if (baseValue === "dataMin") return domainMin;
		if (baseValue === "dataMax") return domainMax;
		return domainMax < 0 ? domainMax : Math.max(Math.min(domain[0], domain[1]), 0);
	}
	if (baseValue === "dataMin") return domain[0];
	if (baseValue === "dataMax") return domain[1];
	return domain[0];
};
function computeArea(_ref9) {
	var { areaSettings: { connectNulls, baseValue: itemBaseValue, dataKey }, stackedData, layout, chartBaseValue, xAxis, yAxis, displayedData, dataStartIndex, xAxisTicks, yAxisTicks, bandSize } = _ref9;
	var hasStack = stackedData && stackedData.length;
	var baseValue = getBaseValue(layout, chartBaseValue, itemBaseValue, xAxis, yAxis);
	var isHorizontalLayout = layout === "horizontal";
	var isRange = false;
	var points = displayedData.map((entry, index) => {
		var value;
		if (hasStack) value = stackedData[dataStartIndex + index];
		else {
			value = getValueByDataKey(entry, dataKey);
			if (!Array.isArray(value)) value = [baseValue, value];
			else isRange = true;
		}
		var isBreakPoint = value[1] == null || hasStack && !connectNulls && getValueByDataKey(entry, dataKey) == null;
		if (isHorizontalLayout) return {
			x: getCateCoordinateOfLine({
				axis: xAxis,
				ticks: xAxisTicks,
				bandSize,
				entry,
				index
			}),
			y: isBreakPoint ? null : yAxis.scale(value[1]),
			value,
			payload: entry
		};
		return {
			x: isBreakPoint ? null : xAxis.scale(value[1]),
			y: getCateCoordinateOfLine({
				axis: yAxis,
				ticks: yAxisTicks,
				bandSize,
				entry,
				index
			}),
			value,
			payload: entry
		};
	});
	var baseLine;
	if (hasStack || isRange) baseLine = points.map((entry) => {
		var x$1 = Array.isArray(entry.value) ? entry.value[0] : null;
		if (isHorizontalLayout) return {
			x: entry.x,
			y: x$1 != null && entry.y != null ? yAxis.scale(x$1) : null,
			payload: entry.payload
		};
		return {
			x: x$1 != null ? xAxis.scale(x$1) : null,
			y: entry.y,
			payload: entry.payload
		};
	});
	else baseLine = isHorizontalLayout ? yAxis.scale(baseValue) : xAxis.scale(baseValue);
	return {
		points,
		baseLine,
		isRange
	};
}
function AreaFn(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultAreaProps);
	var isPanorama = useIsPanorama();
	return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
		id: props.id,
		type: "area"
	}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetLegendPayload, { legendPayload: computeLegendPayloadFromAreaData(props) }), /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$5,
		args: props
	}), /* @__PURE__ */ import_react.createElement(SetCartesianGraphicalItem, {
		type: "area",
		id,
		data: props.data,
		dataKey: props.dataKey,
		xAxisId: props.xAxisId,
		yAxisId: props.yAxisId,
		zAxisId: 0,
		stackId: getNormalizedStackId(props.stackId),
		hide: props.hide,
		barSize: void 0,
		baseValue: props.baseValue,
		isPanorama,
		connectNulls: props.connectNulls
	}), /* @__PURE__ */ import_react.createElement(AreaImpl, _extends$14({}, props, { id }))));
}
var Area = /* @__PURE__ */ import_react.memo(AreaFn);
Area.displayName = "Area";

//#endregion
//#region node_modules/recharts/es6/cartesian/ZAxis.js
function _defineProperty$9(e, r$1, t) {
	return (r$1 = _toPropertyKey$9(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$9(t) {
	var i = _toPrimitive$9(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$9(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function SetZAxisSettings(settings) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(addZAxis(settings));
		return () => {
			dispatch(removeZAxis(settings));
		};
	}, [settings, dispatch]);
	return null;
}
var ZAxis = class extends import_react.Component {
	render() {
		return /* @__PURE__ */ import_react.createElement(SetZAxisSettings, {
			domain: this.props.domain,
			id: this.props.zAxisId,
			dataKey: this.props.dataKey,
			name: this.props.name,
			unit: this.props.unit,
			range: this.props.range,
			scale: this.props.scale,
			type: this.props.type,
			allowDuplicatedCategory: implicitZAxis.allowDuplicatedCategory,
			allowDataOverflow: implicitZAxis.allowDataOverflow,
			reversed: implicitZAxis.reversed,
			includeHidden: implicitZAxis.includeHidden
		});
	}
};
_defineProperty$9(ZAxis, "displayName", "ZAxis");
_defineProperty$9(ZAxis, "defaultProps", {
	zAxisId: 0,
	range: implicitZAxis.range,
	scale: implicitZAxis.scale,
	type: implicitZAxis.type
});

//#endregion
//#region node_modules/recharts/es6/util/ScatterUtils.js
var _excluded$10 = ["option", "isActive"];
function _extends$13() {
	return _extends$13 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$13.apply(null, arguments);
}
function _objectWithoutProperties$10(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$10(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$10(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ScatterSymbol(_ref$1) {
	var { option, isActive } = _ref$1, props = _objectWithoutProperties$10(_ref$1, _excluded$10);
	if (typeof option === "string") return /* @__PURE__ */ import_react.createElement(Shape, _extends$13({
		option: /* @__PURE__ */ import_react.createElement(Symbols, _extends$13({ type: option }, props)),
		isActive,
		shapeType: "symbols"
	}, props));
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$13({
		option,
		isActive,
		shapeType: "symbols"
	}, props));
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/scatterSelectors.js
var selectXAxisWithScale = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "xAxis", xAxisId, isPanorama);
var selectXAxisTicks = (state, xAxisId, _yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "xAxis", xAxisId, isPanorama);
var selectYAxisWithScale = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectAxisWithScale(state, "yAxis", yAxisId, isPanorama);
var selectYAxisTicks = (state, _xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectTicksOfGraphicalItem(state, "yAxis", yAxisId, isPanorama);
var selectZAxis = (state, _xAxisId, _yAxisId, zAxisId) => selectZAxisWithScale(state, "zAxis", zAxisId, false);
var pickScatterId = (_state, _xAxisId, _yAxisId, _zAxisId, id) => id;
var pickCells = (_state, _xAxisId, _yAxisId, _zAxisId, _id, cells) => cells;
var scatterChartDataSelector = (state, xAxisId, yAxisId, _zAxisId, _id, _cells, isPanorama) => selectChartDataWithIndexesIfNotInPanorama(state, xAxisId, yAxisId, isPanorama);
var selectSynchronisedScatterSettings = createSelector([selectUnfilteredCartesianItems, pickScatterId], (graphicalItems, id) => {
	return graphicalItems.filter((item) => item.type === "scatter").find((item) => item.id === id);
});
var selectScatterPoints = createSelector([
	scatterChartDataSelector,
	selectXAxisWithScale,
	selectXAxisTicks,
	selectYAxisWithScale,
	selectYAxisTicks,
	selectZAxis,
	selectSynchronisedScatterSettings,
	pickCells
], (_ref$1, xAxis, xAxisTicks, yAxis, yAxisTicks, zAxis, scatterSettings, cells) => {
	var { chartData, dataStartIndex, dataEndIndex } = _ref$1;
	if (scatterSettings == null) return;
	var displayedData;
	if ((scatterSettings === null || scatterSettings === void 0 ? void 0 : scatterSettings.data) != null && scatterSettings.data.length > 0) displayedData = scatterSettings.data;
	else displayedData = chartData === null || chartData === void 0 ? void 0 : chartData.slice(dataStartIndex, dataEndIndex + 1);
	if (displayedData == null || xAxis == null || yAxis == null || xAxisTicks == null || yAxisTicks == null || (xAxisTicks === null || xAxisTicks === void 0 ? void 0 : xAxisTicks.length) === 0 || (yAxisTicks === null || yAxisTicks === void 0 ? void 0 : yAxisTicks.length) === 0) return;
	return computeScatterPoints({
		displayedData,
		xAxis,
		yAxis,
		zAxis,
		scatterSettings,
		xAxisTicks,
		yAxisTicks,
		cells
	});
});

//#endregion
//#region node_modules/recharts/es6/cartesian/Scatter.js
var _excluded$9 = [
	"onMouseEnter",
	"onClick",
	"onMouseLeave"
], _excluded2$4 = ["id"], _excluded3$2 = [
	"animationBegin",
	"animationDuration",
	"animationEasing",
	"hide",
	"isAnimationActive",
	"legendType",
	"lineJointType",
	"lineType",
	"shape",
	"xAxisId",
	"yAxisId",
	"zAxisId"
];
function _objectWithoutProperties$9(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$9(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$9(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$12() {
	return _extends$12 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$12.apply(null, arguments);
}
function ownKeys$8(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$8(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$8(Object(t), !0).forEach(function(r$2) {
			_defineProperty$8(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$8(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$8(e, r$1, t) {
	return (r$1 = _toPropertyKey$8(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$8(t) {
	var i = _toPrimitive$8(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$8(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* Internal props, combination of external props + defaultProps + private Recharts state
*/
/**
* External props, intended for end users to fill in
*/
/**
* Because of naming conflict, we are forced to ignore certain (valid) SVG attributes.
*/
var computeLegendPayloadFromScatterProps = (props) => {
	var { dataKey, name, fill, legendType, hide } = props;
	return [{
		inactive: hide,
		dataKey,
		type: legendType,
		color: fill,
		value: getTooltipNameProp(name, dataKey),
		payload: props
	}];
};
function ScatterLine(_ref$1) {
	var { points, props } = _ref$1;
	var { line, lineType, lineJointType } = props;
	if (!line) return null;
	var scatterProps = svgPropertiesNoEvents(props);
	var customLineProps = svgPropertiesNoEventsFromUnknown(line);
	var linePoints, lineItem;
	if (lineType === "joint") linePoints = points.map((entry) => ({
		x: entry.cx,
		y: entry.cy
	}));
	else if (lineType === "fitting") {
		var { xmin, xmax, a: a$1, b } = getLinearRegression(points);
		var linearExp = (x$1) => a$1 * x$1 + b;
		linePoints = [{
			x: xmin,
			y: linearExp(xmin)
		}, {
			x: xmax,
			y: linearExp(xmax)
		}];
	}
	var lineProps = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, scatterProps), {}, {
		fill: "none",
		stroke: scatterProps && scatterProps.fill
	}, customLineProps), {}, { points: linePoints });
	if (/* @__PURE__ */ import_react.isValidElement(line)) lineItem = /* @__PURE__ */ import_react.cloneElement(line, lineProps);
	else if (typeof line === "function") lineItem = line(lineProps);
	else lineItem = /* @__PURE__ */ import_react.createElement(Curve, _extends$12({}, lineProps, { type: lineJointType }));
	return /* @__PURE__ */ import_react.createElement(Layer, {
		className: "recharts-scatter-line",
		key: "recharts-scatter-line"
	}, lineItem);
}
function ScatterLabelListProvider(_ref2) {
	var { showLabels, points, children } = _ref2;
	var chartViewBox = useViewBox();
	var labelListEntries = (0, import_react.useMemo)(() => {
		return points === null || points === void 0 ? void 0 : points.map((point$3) => {
			var viewBox = {
				x: point$3.x,
				y: point$3.y,
				width: point$3.width,
				height: point$3.height
			};
			return _objectSpread$8(_objectSpread$8({}, viewBox), {}, {
				value: void 0,
				payload: point$3.payload,
				viewBox,
				parentViewBox: chartViewBox,
				fill: void 0
			});
		});
	}, [chartViewBox, points]);
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: showLabels ? labelListEntries : null }, children);
}
function ScatterSymbols(props) {
	var { points, allOtherScatterProps } = props;
	var { shape, activeShape, dataKey } = allOtherScatterProps;
	var activeIndex = useAppSelector(selectActiveTooltipIndex);
	var { onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps } = allOtherScatterProps, restOfAllOtherProps = _objectWithoutProperties$9(allOtherScatterProps, _excluded$9);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherScatterProps.dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherScatterProps.dataKey);
	if (points == null) return null;
	var { id } = allOtherScatterProps, allOtherPropsWithoutId = _objectWithoutProperties$9(allOtherScatterProps, _excluded2$4);
	var baseProps = svgPropertiesNoEvents(allOtherPropsWithoutId);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ScatterLine, {
		points,
		props: allOtherPropsWithoutId
	}), points.map((entry, i) => {
		var isActive = activeShape && activeIndex === String(i);
		var option = isActive ? activeShape : shape;
		var symbolProps = _objectSpread$8(_objectSpread$8(_objectSpread$8({ key: "symbol-".concat(i) }, baseProps), entry), {}, {
			[DATA_ITEM_INDEX_ATTRIBUTE_NAME]: i,
			[DATA_ITEM_DATAKEY_ATTRIBUTE_NAME]: String(dataKey)
		});
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$12({
			key: "symbol-".concat(entry === null || entry === void 0 ? void 0 : entry.cx, "-").concat(entry === null || entry === void 0 ? void 0 : entry.cy, "-").concat(entry === null || entry === void 0 ? void 0 : entry.size, "-").concat(i),
			className: "recharts-scatter-symbol"
		}, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
			onMouseEnter: onMouseEnterFromContext(entry, i),
			onMouseLeave: onMouseLeaveFromContext(entry, i),
			onClick: onClickFromContext(entry, i)
		}), /* @__PURE__ */ import_react.createElement(ScatterSymbol, _extends$12({
			option,
			isActive
		}, symbolProps)));
	}));
}
function SymbolsWithAnimation(_ref3) {
	var { previousPointsRef, props } = _ref3;
	var { points, isAnimationActive, animationBegin, animationDuration, animationEasing } = props;
	var prevPoints = previousPointsRef.current;
	var animationId = useAnimationId(props, "recharts-scatter-");
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		setIsAnimating(false);
	}, []);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		setIsAnimating(true);
	}, []);
	var showLabels = !isAnimating;
	return /* @__PURE__ */ import_react.createElement(ScatterLabelListProvider, {
		showLabels,
		points
	}, props.children, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		onAnimationEnd: handleAnimationEnd,
		onAnimationStart: handleAnimationStart,
		key: animationId
	}, (t) => {
		var stepData = t === 1 ? points : points === null || points === void 0 ? void 0 : points.map((entry, index) => {
			var prev = prevPoints && prevPoints[index];
			if (prev) {
				var interpolatorCx = interpolateNumber(prev.cx, entry.cx);
				var interpolatorCy = interpolateNumber(prev.cy, entry.cy);
				var interpolatorSize = interpolateNumber(prev.size, entry.size);
				return _objectSpread$8(_objectSpread$8({}, entry), {}, {
					cx: interpolatorCx(t),
					cy: interpolatorCy(t),
					size: interpolatorSize(t)
				});
			}
			var interpolator = interpolateNumber(0, entry.size);
			return _objectSpread$8(_objectSpread$8({}, entry), {}, { size: interpolator(t) });
		});
		if (t > 0) previousPointsRef.current = stepData;
		return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement(ScatterSymbols, {
			points: stepData,
			allOtherScatterProps: props,
			showLabels
		}));
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }));
}
function getTooltipEntrySettings$4(props) {
	var { dataKey, points, stroke, strokeWidth, fill, name, hide, tooltipType } = props;
	return {
		dataDefinedOnItem: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPayload),
		positions: points === null || points === void 0 ? void 0 : points.map((p) => p.tooltipPosition),
		settings: {
			stroke,
			strokeWidth,
			fill,
			nameKey: void 0,
			dataKey,
			name: getTooltipNameProp(name, dataKey),
			hide,
			type: tooltipType,
			color: fill,
			unit: ""
		}
	};
}
function computeScatterPoints(_ref4) {
	var { displayedData, xAxis, yAxis, zAxis, scatterSettings, xAxisTicks, yAxisTicks, cells } = _ref4;
	var xAxisDataKey = isNullish(xAxis.dataKey) ? scatterSettings.dataKey : xAxis.dataKey;
	var yAxisDataKey = isNullish(yAxis.dataKey) ? scatterSettings.dataKey : yAxis.dataKey;
	var zAxisDataKey = zAxis && zAxis.dataKey;
	var defaultRangeZ = zAxis ? zAxis.range : ZAxis.defaultProps.range;
	var defaultZ = defaultRangeZ && defaultRangeZ[0];
	var xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;
	var yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;
	return displayedData.map((entry, index) => {
		var x$1 = getValueByDataKey(entry, xAxisDataKey);
		var y$1 = getValueByDataKey(entry, yAxisDataKey);
		var z = !isNullish(zAxisDataKey) && getValueByDataKey(entry, zAxisDataKey) || "-";
		var tooltipPayload = [{
			name: isNullish(xAxis.dataKey) ? scatterSettings.name : xAxis.name || xAxis.dataKey,
			unit: xAxis.unit || "",
			value: x$1,
			payload: entry,
			dataKey: xAxisDataKey,
			type: scatterSettings.tooltipType
		}, {
			name: isNullish(yAxis.dataKey) ? scatterSettings.name : yAxis.name || yAxis.dataKey,
			unit: yAxis.unit || "",
			value: y$1,
			payload: entry,
			dataKey: yAxisDataKey,
			type: scatterSettings.tooltipType
		}];
		if (z !== "-") tooltipPayload.push({
			name: zAxis.name || zAxis.dataKey,
			unit: zAxis.unit || "",
			value: z,
			payload: entry,
			dataKey: zAxisDataKey,
			type: scatterSettings.tooltipType
		});
		var cx = getCateCoordinateOfLine({
			axis: xAxis,
			ticks: xAxisTicks,
			bandSize: xBandSize,
			entry,
			index,
			dataKey: xAxisDataKey
		});
		var cy = getCateCoordinateOfLine({
			axis: yAxis,
			ticks: yAxisTicks,
			bandSize: yBandSize,
			entry,
			index,
			dataKey: yAxisDataKey
		});
		var size = z !== "-" ? zAxis.scale(z) : defaultZ;
		var radius = Math.sqrt(Math.max(size, 0) / Math.PI);
		return _objectSpread$8(_objectSpread$8({}, entry), {}, {
			cx,
			cy,
			x: cx - radius,
			y: cy - radius,
			width: 2 * radius,
			height: 2 * radius,
			size,
			node: {
				x: x$1,
				y: y$1,
				z
			},
			tooltipPayload,
			tooltipPosition: {
				x: cx,
				y: cy
			},
			payload: entry
		}, cells && cells[index] && cells[index].props);
	});
}
var errorBarDataPointFormatter = (dataPoint, dataKey, direction) => {
	return {
		x: dataPoint.cx,
		y: dataPoint.cy,
		value: direction === "x" ? +dataPoint.node.x : +dataPoint.node.y,
		errorVal: getValueByDataKey(dataPoint, dataKey)
	};
};
function ScatterWithId(props) {
	var { hide, points, className, needClip, xAxisId, yAxisId, id } = props;
	var previousPointsRef = (0, import_react.useRef)(null);
	if (hide) return null;
	var layerClass = clsx("recharts-scatter", className);
	var clipPathId = id;
	return /* @__PURE__ */ import_react.createElement(Layer, {
		className: layerClass,
		clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
		id
	}, needClip && /* @__PURE__ */ import_react.createElement("defs", null, /* @__PURE__ */ import_react.createElement(GraphicalItemClipPath, {
		clipPathId,
		xAxisId,
		yAxisId
	})), /* @__PURE__ */ import_react.createElement(SetErrorBarContext, {
		xAxisId,
		yAxisId,
		data: points,
		dataPointFormatter: errorBarDataPointFormatter,
		errorBarOffset: 0
	}, /* @__PURE__ */ import_react.createElement(Layer, { key: "recharts-scatter-symbols" }, /* @__PURE__ */ import_react.createElement(SymbolsWithAnimation, {
		props,
		previousPointsRef
	}))));
}
var defaultScatterProps = {
	xAxisId: 0,
	yAxisId: 0,
	zAxisId: 0,
	legendType: "circle",
	lineType: "joint",
	lineJointType: "linear",
	data: [],
	shape: "circle",
	hide: false,
	isAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 400,
	animationEasing: "linear"
};
function ScatterImpl(props) {
	var _resolveDefaultProps = resolveDefaultProps(props, defaultScatterProps), { animationBegin, animationDuration, animationEasing, hide, isAnimationActive, legendType, lineJointType, lineType, shape, xAxisId, yAxisId, zAxisId } = _resolveDefaultProps, everythingElse = _objectWithoutProperties$9(_resolveDefaultProps, _excluded3$2);
	var { needClip } = useNeedsClip(xAxisId, yAxisId);
	var cells = (0, import_react.useMemo)(() => findAllByType(props.children, Cell), [props.children]);
	var isPanorama = useIsPanorama();
	var points = useAppSelector((state) => {
		return selectScatterPoints(state, xAxisId, yAxisId, zAxisId, props.id, cells, isPanorama);
	});
	if (needClip == null) return null;
	if (points == null) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$4,
		args: _objectSpread$8(_objectSpread$8({}, props), {}, { points })
	}), /* @__PURE__ */ import_react.createElement(ScatterWithId, _extends$12({}, everythingElse, {
		xAxisId,
		yAxisId,
		zAxisId,
		lineType,
		lineJointType,
		legendType,
		shape,
		hide,
		isAnimationActive,
		animationBegin,
		animationDuration,
		animationEasing,
		points,
		needClip
	})));
}
function ScatterFn(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultScatterProps);
	var isPanorama = useIsPanorama();
	return /* @__PURE__ */ import_react.createElement(RegisterGraphicalItemId, {
		id: props.id,
		type: "scatter"
	}, (id) => /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetLegendPayload, { legendPayload: computeLegendPayloadFromScatterProps(props) }), /* @__PURE__ */ import_react.createElement(SetCartesianGraphicalItem, {
		type: "scatter",
		id,
		data: props.data,
		xAxisId: props.xAxisId,
		yAxisId: props.yAxisId,
		zAxisId: props.zAxisId,
		dataKey: props.dataKey,
		hide: props.hide,
		name: props.name,
		tooltipType: props.tooltipType,
		isPanorama
	}), /* @__PURE__ */ import_react.createElement(ScatterImpl, _extends$12({}, props, { id }))));
}
var Scatter = /* @__PURE__ */ import_react.memo(ScatterFn);
Scatter.displayName = "Scatter";

//#endregion
//#region node_modules/recharts/es6/cartesian/XAxis.js
var _excluded$8 = ["dangerouslySetInnerHTML", "ticks"], _excluded2$3 = ["id"], _excluded3$1 = ["domain"], _excluded4$1 = ["domain"];
function _extends$11() {
	return _extends$11 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$11.apply(null, arguments);
}
function _objectWithoutProperties$8(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$8(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$8(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function SetXAxisSettings(settings) {
	var dispatch = useAppDispatch();
	(0, import_react.useLayoutEffect)(() => {
		dispatch(addXAxis(settings));
		return () => {
			dispatch(removeXAxis(settings));
		};
	}, [settings, dispatch]);
	return null;
}
var XAxisImpl = (props) => {
	var { xAxisId, className } = props;
	var viewBox = useAppSelector(selectAxisViewBox);
	var isPanorama = useIsPanorama();
	var axisType = "xAxis";
	var scale = useAppSelector((state) => selectAxisScale(state, axisType, xAxisId, isPanorama));
	var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, xAxisId, isPanorama));
	var axisSize = useAppSelector((state) => selectXAxisSize(state, xAxisId));
	var position$1 = useAppSelector((state) => selectXAxisPosition(state, xAxisId));
	var synchronizedSettings = useAppSelector((state) => selectXAxisSettingsNoDefaults(state, xAxisId));
	if (axisSize == null || position$1 == null || synchronizedSettings == null) return null;
	var { dangerouslySetInnerHTML, ticks: ticks$1 } = props, allOtherProps = _objectWithoutProperties$8(props, _excluded$8);
	var { id } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$8(synchronizedSettings, _excluded2$3);
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$11({}, allOtherProps, restSynchronizedSettings, {
		scale,
		x: position$1.x,
		y: position$1.y,
		width: axisSize.width,
		height: axisSize.height,
		className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
		viewBox,
		ticks: cartesianTickItems
	}));
};
var xAxisDefaultProps = {
	allowDataOverflow: implicitXAxis.allowDataOverflow,
	allowDecimals: implicitXAxis.allowDecimals,
	allowDuplicatedCategory: implicitXAxis.allowDuplicatedCategory,
	height: implicitXAxis.height,
	hide: false,
	mirror: implicitXAxis.mirror,
	orientation: implicitXAxis.orientation,
	padding: implicitXAxis.padding,
	reversed: implicitXAxis.reversed,
	scale: implicitXAxis.scale,
	tickCount: implicitXAxis.tickCount,
	type: implicitXAxis.type,
	xAxisId: 0
};
var XAxisSettingsDispatcher = (outsideProps) => {
	var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
	var props = resolveDefaultProps(outsideProps, xAxisDefaultProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetXAxisSettings, {
		interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
		id: props.xAxisId,
		scale: props.scale,
		type: props.type,
		padding: props.padding,
		allowDataOverflow: props.allowDataOverflow,
		domain: props.domain,
		dataKey: props.dataKey,
		allowDuplicatedCategory: props.allowDuplicatedCategory,
		allowDecimals: props.allowDecimals,
		tickCount: props.tickCount,
		includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
		reversed: props.reversed,
		ticks: props.ticks,
		height: props.height,
		orientation: props.orientation,
		mirror: props.mirror,
		hide: props.hide,
		unit: props.unit,
		name: props.name,
		angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
		minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
		tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
		tickFormatter: props.tickFormatter
	}), /* @__PURE__ */ import_react.createElement(XAxisImpl, props));
};
var XAxisMemoComparator = (prevProps, nextProps) => {
	var { domain: prevDomain } = prevProps, prevRest = _objectWithoutProperties$8(prevProps, _excluded3$1);
	var { domain: nextDomain } = nextProps, nextRest = _objectWithoutProperties$8(nextProps, _excluded4$1);
	if (!shallowEqual(prevRest, nextRest)) return false;
	if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
	return shallowEqual({ domain: prevDomain }, { domain: nextDomain });
};
var XAxis = /* @__PURE__ */ import_react.memo(XAxisSettingsDispatcher, XAxisMemoComparator);
XAxis.displayName = "XAxis";

//#endregion
//#region node_modules/recharts/es6/cartesian/YAxis.js
var _excluded$7 = ["dangerouslySetInnerHTML", "ticks"], _excluded2$2 = ["id"], _excluded3 = ["domain"], _excluded4 = ["domain"];
function _extends$10() {
	return _extends$10 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$10.apply(null, arguments);
}
function _objectWithoutProperties$7(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$7(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$7(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function SetYAxisSettings(settings) {
	var dispatch = useAppDispatch();
	(0, import_react.useLayoutEffect)(() => {
		dispatch(addYAxis(settings));
		return () => {
			dispatch(removeYAxis(settings));
		};
	}, [settings, dispatch]);
	return null;
}
var YAxisImpl = (props) => {
	var { yAxisId, className, width, label } = props;
	var cartesianAxisRef = (0, import_react.useRef)(null);
	var labelRef = (0, import_react.useRef)(null);
	var viewBox = useAppSelector(selectAxisViewBox);
	var isPanorama = useIsPanorama();
	var dispatch = useAppDispatch();
	var axisType = "yAxis";
	var scale = useAppSelector((state) => selectAxisScale(state, axisType, yAxisId, isPanorama));
	var axisSize = useAppSelector((state) => selectYAxisSize(state, yAxisId));
	var position$1 = useAppSelector((state) => selectYAxisPosition(state, yAxisId));
	var cartesianTickItems = useAppSelector((state) => selectTicksOfAxis(state, axisType, yAxisId, isPanorama));
	var synchronizedSettings = useAppSelector((state) => selectYAxisSettingsNoDefaults(state, yAxisId));
	(0, import_react.useLayoutEffect)(() => {
		if (width !== "auto" || !axisSize || isLabelContentAFunction(label) || /* @__PURE__ */ (0, import_react.isValidElement)(label) || synchronizedSettings == null) return;
		var axisComponent = cartesianAxisRef.current;
		if (!axisComponent) return;
		var updatedYAxisWidth = axisComponent.getCalculatedWidth();
		if (Math.round(axisSize.width) !== Math.round(updatedYAxisWidth)) dispatch(updateYAxisWidth({
			id: yAxisId,
			width: updatedYAxisWidth
		}));
	}, [
		cartesianTickItems,
		axisSize,
		dispatch,
		label,
		yAxisId,
		width,
		synchronizedSettings
	]);
	if (axisSize == null || position$1 == null || synchronizedSettings == null) return null;
	var { dangerouslySetInnerHTML, ticks: ticks$1 } = props, allOtherProps = _objectWithoutProperties$7(props, _excluded$7);
	var { id } = synchronizedSettings, restSynchronizedSettings = _objectWithoutProperties$7(synchronizedSettings, _excluded2$2);
	return /* @__PURE__ */ import_react.createElement(CartesianAxis, _extends$10({}, allOtherProps, restSynchronizedSettings, {
		ref: cartesianAxisRef,
		labelRef,
		scale,
		x: position$1.x,
		y: position$1.y,
		tickTextProps: width === "auto" ? { width: void 0 } : { width },
		width: axisSize.width,
		height: axisSize.height,
		className: clsx("recharts-".concat(axisType, " ").concat(axisType), className),
		viewBox,
		ticks: cartesianTickItems
	}));
};
var yAxisDefaultProps = {
	allowDataOverflow: implicitYAxis.allowDataOverflow,
	allowDecimals: implicitYAxis.allowDecimals,
	allowDuplicatedCategory: implicitYAxis.allowDuplicatedCategory,
	hide: false,
	mirror: implicitYAxis.mirror,
	orientation: implicitYAxis.orientation,
	padding: implicitYAxis.padding,
	reversed: implicitYAxis.reversed,
	scale: implicitYAxis.scale,
	tickCount: implicitYAxis.tickCount,
	type: implicitYAxis.type,
	width: implicitYAxis.width,
	yAxisId: 0
};
var YAxisSettingsDispatcher = (outsideProps) => {
	var _props$interval, _props$includeHidden, _props$angle, _props$minTickGap, _props$tick;
	var props = resolveDefaultProps(outsideProps, yAxisDefaultProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetYAxisSettings, {
		interval: (_props$interval = props.interval) !== null && _props$interval !== void 0 ? _props$interval : "preserveEnd",
		id: props.yAxisId,
		scale: props.scale,
		type: props.type,
		domain: props.domain,
		allowDataOverflow: props.allowDataOverflow,
		dataKey: props.dataKey,
		allowDuplicatedCategory: props.allowDuplicatedCategory,
		allowDecimals: props.allowDecimals,
		tickCount: props.tickCount,
		padding: props.padding,
		includeHidden: (_props$includeHidden = props.includeHidden) !== null && _props$includeHidden !== void 0 ? _props$includeHidden : false,
		reversed: props.reversed,
		ticks: props.ticks,
		width: props.width,
		orientation: props.orientation,
		mirror: props.mirror,
		hide: props.hide,
		unit: props.unit,
		name: props.name,
		angle: (_props$angle = props.angle) !== null && _props$angle !== void 0 ? _props$angle : 0,
		minTickGap: (_props$minTickGap = props.minTickGap) !== null && _props$minTickGap !== void 0 ? _props$minTickGap : 5,
		tick: (_props$tick = props.tick) !== null && _props$tick !== void 0 ? _props$tick : true,
		tickFormatter: props.tickFormatter
	}), /* @__PURE__ */ import_react.createElement(YAxisImpl, props));
};
var YAxisMemoComparator = (prevProps, nextProps) => {
	var { domain: prevDomain } = prevProps, prevRest = _objectWithoutProperties$7(prevProps, _excluded3);
	var { domain: nextDomain } = nextProps, nextRest = _objectWithoutProperties$7(nextProps, _excluded4);
	if (!shallowEqual(prevRest, nextRest)) return false;
	if (Array.isArray(prevDomain) && prevDomain.length === 2 && Array.isArray(nextDomain) && nextDomain.length === 2) return prevDomain[0] === nextDomain[0] && prevDomain[1] === nextDomain[1];
	return shallowEqual({ domain: prevDomain }, { domain: nextDomain });
};
var YAxis = /* @__PURE__ */ import_react.memo(YAxisSettingsDispatcher, YAxisMemoComparator);
YAxis.displayName = "YAxis";

//#endregion
//#region node_modules/recharts/es6/animation/CSSTransitionAnimate.js
var defaultProps$5 = {
	begin: 0,
	duration: 1e3,
	easing: "ease",
	isActive: true,
	canBegin: true,
	onAnimationEnd: () => {},
	onAnimationStart: () => {}
};
function CSSTransitionAnimate(outsideProps) {
	var props = resolveDefaultProps(outsideProps, defaultProps$5);
	var { animationId, from: from$1, to: to$1, attributeName, isActive, canBegin, duration, easing, begin, onAnimationEnd, onAnimationStart: onAnimationStartFromProps, children } = props;
	var animationManager = useAnimationManager(animationId + attributeName, props.animationManager);
	var [style, setStyle] = (0, import_react.useState)(() => {
		if (!isActive) return to$1;
		return from$1;
	});
	var initialized = (0, import_react.useRef)(false);
	var onAnimationStart = (0, import_react.useCallback)(() => {
		setStyle(from$1);
		onAnimationStartFromProps();
	}, [from$1, onAnimationStartFromProps]);
	(0, import_react.useEffect)(() => {
		if (!isActive || !canBegin) return noop;
		initialized.current = true;
		var unsubscribe = animationManager.subscribe(setStyle);
		animationManager.start([
			onAnimationStart,
			begin,
			to$1,
			duration,
			onAnimationEnd
		]);
		return () => {
			animationManager.stop();
			if (unsubscribe) unsubscribe();
			onAnimationEnd();
		};
	}, [
		isActive,
		canBegin,
		duration,
		easing,
		begin,
		onAnimationStart,
		onAnimationEnd,
		animationManager,
		to$1,
		from$1
	]);
	if (!isActive) return children({ [attributeName]: to$1 });
	if (!canBegin) return children({ [attributeName]: from$1 });
	if (initialized.current) {
		var transition = getTransitionVal([attributeName], duration, easing);
		return children({
			transition,
			[attributeName]: style
		});
	}
	return children({ [attributeName]: from$1 });
}

//#endregion
//#region node_modules/recharts/es6/cartesian/ErrorBar.js
var _excluded$6 = [
	"direction",
	"width",
	"dataKey",
	"isAnimationActive",
	"animationBegin",
	"animationDuration",
	"animationEasing"
];
function _extends$9() {
	return _extends$9 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$9.apply(null, arguments);
}
function ownKeys$7(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$7(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$7(Object(t), !0).forEach(function(r$2) {
			_defineProperty$7(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$7(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$7(e, r$1, t) {
	return (r$1 = _toPropertyKey$7(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$7(t) {
	var i = _toPrimitive$7(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$7(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _objectWithoutProperties$6(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$6(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$6(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
/**
* So usually the direction is decided by the chart layout.
* Horizontal layout means error bars are vertical means direction=y
* Vertical layout means error bars are horizontal means direction=x
*
* Except! In Scatter chart, error bars can go both ways.
*
* So this property is only ever used in Scatter chart, and ignored elsewhere.
*/
/**
* External ErrorBar props, visible for users of the library
*/
/**
* Props after defaults, and required props have been applied.
*/
function ErrorBarImpl(props) {
	var { direction, width, dataKey, isAnimationActive, animationBegin, animationDuration, animationEasing } = props, others = _objectWithoutProperties$6(props, _excluded$6);
	var svgProps = svgPropertiesNoEvents(others);
	var { data, dataPointFormatter, xAxisId, yAxisId, errorBarOffset: offset } = useErrorBarContext();
	var xAxis = useXAxis(xAxisId);
	var yAxis = useYAxis(yAxisId);
	if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.scale) == null || (yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale) == null || data == null) return null;
	if (direction === "x" && xAxis.type !== "number") return null;
	var errorBars = data.map((entry) => {
		var { x: x$1, y: y$1, value, errorVal } = dataPointFormatter(entry, dataKey, direction);
		if (!errorVal || x$1 == null || y$1 == null) return null;
		var lineCoordinates = [];
		var lowBound, highBound;
		if (Array.isArray(errorVal)) [lowBound, highBound] = errorVal;
		else lowBound = highBound = errorVal;
		if (direction === "x") {
			var { scale } = xAxis;
			var yMid = y$1 + offset;
			var yMin = yMid + width;
			var yMax = yMid - width;
			var xMin = scale(value - lowBound);
			var xMax = scale(value + highBound);
			lineCoordinates.push({
				x1: xMax,
				y1: yMin,
				x2: xMax,
				y2: yMax
			});
			lineCoordinates.push({
				x1: xMin,
				y1: yMid,
				x2: xMax,
				y2: yMid
			});
			lineCoordinates.push({
				x1: xMin,
				y1: yMin,
				x2: xMin,
				y2: yMax
			});
		} else if (direction === "y") {
			var { scale: _scale } = yAxis;
			var xMid = x$1 + offset;
			var _xMin = xMid - width;
			var _xMax = xMid + width;
			var _yMin = _scale(value - lowBound);
			var _yMax = _scale(value + highBound);
			lineCoordinates.push({
				x1: _xMin,
				y1: _yMax,
				x2: _xMax,
				y2: _yMax
			});
			lineCoordinates.push({
				x1: xMid,
				y1: _yMin,
				x2: xMid,
				y2: _yMax
			});
			lineCoordinates.push({
				x1: _xMin,
				y1: _yMin,
				x2: _xMax,
				y2: _yMin
			});
		}
		var scaleDirection = direction === "x" ? "scaleX" : "scaleY";
		var transformOrigin = "".concat(x$1 + offset, "px ").concat(y$1 + offset, "px");
		return /* @__PURE__ */ import_react.createElement(Layer, _extends$9({
			className: "recharts-errorBar",
			key: "bar-".concat(lineCoordinates.map((c$1) => "".concat(c$1.x1, "-").concat(c$1.x2, "-").concat(c$1.y1, "-").concat(c$1.y2)))
		}, svgProps), lineCoordinates.map((c$1) => {
			var lineStyle = isAnimationActive ? { transformOrigin } : void 0;
			return /* @__PURE__ */ import_react.createElement(CSSTransitionAnimate, {
				animationId: "error-bar-".concat(direction, "_").concat(c$1.x1, "-").concat(c$1.x2, "-").concat(c$1.y1, "-").concat(c$1.y2),
				from: "".concat(scaleDirection, "(0)"),
				to: "".concat(scaleDirection, "(1)"),
				attributeName: "transform",
				begin: animationBegin,
				easing: animationEasing,
				isActive: isAnimationActive,
				duration: animationDuration,
				key: "errorbar-".concat(c$1.x1, "-").concat(c$1.x2, "-").concat(c$1.y1, "-").concat(c$1.y2)
			}, (style) => /* @__PURE__ */ import_react.createElement("line", _extends$9({}, c$1, { style: _objectSpread$7(_objectSpread$7({}, lineStyle), style) })));
		}));
	});
	return /* @__PURE__ */ import_react.createElement(Layer, { className: "recharts-errorBars" }, errorBars);
}
function useErrorBarDirection(directionFromProps) {
	var layout = useChartLayout();
	if (directionFromProps != null) return directionFromProps;
	if (layout != null) return layout === "horizontal" ? "y" : "x";
	return "x";
}
var errorBarDefaultProps = {
	stroke: "black",
	strokeWidth: 1.5,
	width: 5,
	offset: 0,
	isAnimationActive: true,
	animationBegin: 0,
	animationDuration: 400,
	animationEasing: "ease-in-out"
};
function ErrorBarInternal(props) {
	var realDirection = useErrorBarDirection(props.direction);
	var { width, isAnimationActive, animationBegin, animationDuration, animationEasing } = resolveDefaultProps(props, errorBarDefaultProps);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportErrorBarSettings, {
		dataKey: props.dataKey,
		direction: realDirection
	}), /* @__PURE__ */ import_react.createElement(ErrorBarImpl, _extends$9({}, props, {
		direction: realDirection,
		width,
		isAnimationActive,
		animationBegin,
		animationDuration,
		animationEasing
	})));
}
var ErrorBar = class extends import_react.Component {
	render() {
		return /* @__PURE__ */ import_react.createElement(ErrorBarInternal, this.props);
	}
};
_defineProperty$7(ErrorBar, "defaultProps", errorBarDefaultProps);
_defineProperty$7(ErrorBar, "displayName", "ErrorBar");

//#endregion
//#region node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js
var require_use_sync_external_store_with_selector_development = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/cjs/use-sync-external-store-with-selector.development.js": ((exports) => {
	(function() {
		function is$1(x$1, y$1) {
			return x$1 === y$1 && (0 !== x$1 || 1 / x$1 === 1 / y$1) || x$1 !== x$1 && y$1 !== y$1;
		}
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		var React = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is$1, useSyncExternalStore = React.useSyncExternalStore, useRef$20 = React.useRef, useEffect$23 = React.useEffect, useMemo$11 = React.useMemo, useDebugValue = React.useDebugValue;
		exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
			var instRef = useRef$20(null);
			if (null === instRef.current) {
				var inst = {
					hasValue: !1,
					value: null
				};
				instRef.current = inst;
			} else inst = instRef.current;
			instRef = useMemo$11(function() {
				function memoizedSelector(nextSnapshot) {
					if (!hasMemo) {
						hasMemo = !0;
						memoizedSnapshot = nextSnapshot;
						nextSnapshot = selector(nextSnapshot);
						if (void 0 !== isEqual && inst.hasValue) {
							var currentSelection = inst.value;
							if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
						}
						return memoizedSelection = nextSnapshot;
					}
					currentSelection = memoizedSelection;
					if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
					var nextSelection = selector(nextSnapshot);
					if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
					memoizedSnapshot = nextSnapshot;
					return memoizedSelection = nextSelection;
				}
				var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
				return [function() {
					return memoizedSelector(getSnapshot());
				}, null === maybeGetServerSnapshot ? void 0 : function() {
					return memoizedSelector(maybeGetServerSnapshot());
				}];
			}, [
				getSnapshot,
				getServerSnapshot,
				selector,
				isEqual
			]);
			var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
			useEffect$23(function() {
				inst.hasValue = !0;
				inst.value = value;
			}, [value]);
			useDebugValue(value);
			return value;
		};
		"undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
}) });

//#endregion
//#region node_modules/use-sync-external-store/with-selector.js
var require_with_selector = /* @__PURE__ */ __commonJS({ "node_modules/use-sync-external-store/with-selector.js": ((exports, module) => {
	module.exports = require_use_sync_external_store_with_selector_development();
}) });

//#endregion
//#region node_modules/react-redux/dist/react-redux.mjs
var import_with_selector = /* @__PURE__ */ __toESM(require_with_selector(), 1);
var REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref");
var REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo");
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Memo = REACT_MEMO_TYPE;
function defaultNoopBatch(callback) {
	callback();
}
function createListenerCollection() {
	let first = null;
	let last$4 = null;
	return {
		clear() {
			first = null;
			last$4 = null;
		},
		notify() {
			defaultNoopBatch(() => {
				let listener$1 = first;
				while (listener$1) {
					listener$1.callback();
					listener$1 = listener$1.next;
				}
			});
		},
		get() {
			const listeners = [];
			let listener$1 = first;
			while (listener$1) {
				listeners.push(listener$1);
				listener$1 = listener$1.next;
			}
			return listeners;
		},
		subscribe(callback) {
			let isSubscribed = true;
			const listener$1 = last$4 = {
				callback,
				next: null,
				prev: last$4
			};
			if (listener$1.prev) listener$1.prev.next = listener$1;
			else first = listener$1;
			return function unsubscribe() {
				if (!isSubscribed || first === null) return;
				isSubscribed = false;
				if (listener$1.next) listener$1.next.prev = listener$1.prev;
				else last$4 = listener$1.prev;
				if (listener$1.prev) listener$1.prev.next = listener$1.next;
				else first = listener$1.next;
			};
		}
	};
}
var nullListeners = {
	notify() {},
	get: () => []
};
function createSubscription(store, parentSub) {
	let unsubscribe;
	let listeners = nullListeners;
	let subscriptionsAmount = 0;
	let selfSubscribed = false;
	function addNestedSub(listener$1) {
		trySubscribe();
		const cleanupListener = listeners.subscribe(listener$1);
		let removed = false;
		return () => {
			if (!removed) {
				removed = true;
				cleanupListener();
				tryUnsubscribe();
			}
		};
	}
	function notifyNestedSubs() {
		listeners.notify();
	}
	function handleChangeWrapper() {
		if (subscription.onStateChange) subscription.onStateChange();
	}
	function isSubscribed() {
		return selfSubscribed;
	}
	function trySubscribe() {
		subscriptionsAmount++;
		if (!unsubscribe) {
			unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
			listeners = createListenerCollection();
		}
	}
	function tryUnsubscribe() {
		subscriptionsAmount--;
		if (unsubscribe && subscriptionsAmount === 0) {
			unsubscribe();
			unsubscribe = void 0;
			listeners.clear();
			listeners = nullListeners;
		}
	}
	function trySubscribeSelf() {
		if (!selfSubscribed) {
			selfSubscribed = true;
			trySubscribe();
		}
	}
	function tryUnsubscribeSelf() {
		if (selfSubscribed) {
			selfSubscribed = false;
			tryUnsubscribe();
		}
	}
	const subscription = {
		addNestedSub,
		notifyNestedSubs,
		handleChangeWrapper,
		isSubscribed,
		trySubscribe: trySubscribeSelf,
		tryUnsubscribe: tryUnsubscribeSelf,
		getListeners: () => listeners
	};
	return subscription;
}
var canUseDOM = () => !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isDOM = /* @__PURE__ */ canUseDOM();
var isRunningInReactNative = () => typeof navigator !== "undefined" && navigator.product === "ReactNative";
var isReactNative = /* @__PURE__ */ isRunningInReactNative();
var getUseIsomorphicLayoutEffect = () => isDOM || isReactNative ? import_react.useLayoutEffect : import_react.useEffect;
var useIsomorphicLayoutEffect = /* @__PURE__ */ getUseIsomorphicLayoutEffect();
var FORWARD_REF_STATICS = {
	$$typeof: true,
	render: true,
	defaultProps: true,
	displayName: true,
	propTypes: true
};
var MEMO_STATICS = {
	$$typeof: true,
	compare: true,
	defaultProps: true,
	displayName: true,
	propTypes: true,
	type: true
};
var TYPE_STATICS = {
	[ForwardRef]: FORWARD_REF_STATICS,
	[Memo]: MEMO_STATICS
};
var objectPrototype = Object.prototype;
var ContextKey = /* @__PURE__ */ Symbol.for(`react-redux-context`);
var gT = typeof globalThis !== "undefined" ? globalThis : {};
function getContext() {
	if (!import_react.createContext) return {};
	const contextMap = gT[ContextKey] ??= /* @__PURE__ */ new Map();
	let realContext = contextMap.get(import_react.createContext);
	if (!realContext) {
		realContext = import_react.createContext(null);
		realContext.displayName = "ReactRedux";
		contextMap.set(import_react.createContext, realContext);
	}
	return realContext;
}
var ReactReduxContext = /* @__PURE__ */ getContext();
function Provider(providerProps) {
	const { children, context, serverState, store } = providerProps;
	const contextValue = import_react.useMemo(() => {
		const subscription = createSubscription(store);
		const baseContextValue = {
			store,
			subscription,
			getServerState: serverState ? () => serverState : void 0
		};
		{
			const { identityFunctionCheck = "once", stabilityCheck = "once" } = providerProps;
			return /* @__PURE__ */ Object.assign(baseContextValue, {
				stabilityCheck,
				identityFunctionCheck
			});
		}
	}, [store, serverState]);
	const previousState = import_react.useMemo(() => store.getState(), [store]);
	useIsomorphicLayoutEffect(() => {
		const { subscription } = contextValue;
		subscription.onStateChange = subscription.notifyNestedSubs;
		subscription.trySubscribe();
		if (previousState !== store.getState()) subscription.notifyNestedSubs();
		return () => {
			subscription.tryUnsubscribe();
			subscription.onStateChange = void 0;
		};
	}, [contextValue, previousState]);
	const Context = context || ReactReduxContext;
	return /* @__PURE__ */ import_react.createElement(Context.Provider, { value: contextValue }, children);
}
var Provider_default = Provider;

//#endregion
//#region node_modules/recharts/es6/state/selectors/selectActivePropsFromChartPointer.js
var pickChartPointer = (_state, chartPointer) => chartPointer;
var selectActivePropsFromChartPointer = createSelector([
	pickChartPointer,
	selectChartLayout,
	selectPolarViewBox,
	selectTooltipAxisType,
	selectTooltipAxisRangeWithReverse,
	selectTooltipAxisTicks,
	selectOrderedTooltipTicks,
	selectChartOffsetInternal
], combineActiveProps);

//#endregion
//#region node_modules/recharts/es6/util/getChartPointer.js
/**
* Computes the chart coordinates from the mouse event.
*
* The coordinates are relative to the top-left corner of the chart,
* where the top-left corner of the chart is (0, 0).
* Moving right, the x-coordinate increases, and moving down, the y-coordinate increases.
*
* The coordinates are rounded to the nearest integer and are including a CSS transform scale.
* So a chart that's scaled will return the same coordinates as a chart that's not scaled.
*
* @param event The mouse event from React event handlers
* @return chartPointer The chart coordinates relative to the top-left corner of the chart
*/
var getChartPointer = (event) => {
	var rect = event.currentTarget.getBoundingClientRect();
	var scaleX = rect.width / event.currentTarget.offsetWidth;
	var scaleY = rect.height / event.currentTarget.offsetHeight;
	return {
		chartX: Math.round((event.clientX - rect.left) / scaleX),
		chartY: Math.round((event.clientY - rect.top) / scaleY)
	};
};

//#endregion
//#region node_modules/recharts/es6/state/mouseEventsMiddleware.js
var mouseClickAction = createAction("mouseClick");
var mouseClickMiddleware = createListenerMiddleware();
mouseClickMiddleware.startListening({
	actionCreator: mouseClickAction,
	effect: (action, listenerApi) => {
		var mousePointer = action.payload;
		var activeProps = selectActivePropsFromChartPointer(listenerApi.getState(), getChartPointer(mousePointer));
		if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) listenerApi.dispatch(setMouseClickAxisIndex({
			activeIndex: activeProps.activeIndex,
			activeDataKey: void 0,
			activeCoordinate: activeProps.activeCoordinate
		}));
	}
});
var mouseMoveAction = createAction("mouseMove");
var mouseMoveMiddleware = createListenerMiddleware();
mouseMoveMiddleware.startListening({
	actionCreator: mouseMoveAction,
	effect: (action, listenerApi) => {
		var mousePointer = action.payload;
		var state = listenerApi.getState();
		var tooltipEventType = selectTooltipEventType(state, state.tooltip.settings.shared);
		var activeProps = selectActivePropsFromChartPointer(state, getChartPointer(mousePointer));
		if (tooltipEventType === "axis") if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) listenerApi.dispatch(setMouseOverAxisIndex({
			activeIndex: activeProps.activeIndex,
			activeDataKey: void 0,
			activeCoordinate: activeProps.activeCoordinate
		}));
		else listenerApi.dispatch(mouseLeaveChart());
	}
});

//#endregion
//#region node_modules/recharts/es6/state/reduxDevtoolsJsonStringifyReplacer.js
function reduxDevtoolsJsonStringifyReplacer(_key, value) {
	if (value instanceof HTMLElement) return "HTMLElement <".concat(value.tagName, " class=\"").concat(value.className, "\">");
	if (value === window) return "global.window";
	return value;
}

//#endregion
//#region node_modules/recharts/es6/state/rootPropsSlice.js
/**
* These are chart options that users can choose - which means they can also
* choose to change them which should trigger a re-render.
*/
var initialState = {
	accessibilityLayer: true,
	barCategoryGap: "10%",
	barGap: 4,
	barSize: void 0,
	className: void 0,
	maxBarSize: void 0,
	stackOffset: "none",
	syncId: void 0,
	syncMethod: "index"
};
var rootPropsSlice = createSlice({
	name: "rootProps",
	initialState,
	reducers: { updateOptions: (state, action) => {
		var _action$payload$barGa;
		state.accessibilityLayer = action.payload.accessibilityLayer;
		state.barCategoryGap = action.payload.barCategoryGap;
		state.barGap = (_action$payload$barGa = action.payload.barGap) !== null && _action$payload$barGa !== void 0 ? _action$payload$barGa : initialState.barGap;
		state.barSize = action.payload.barSize;
		state.maxBarSize = action.payload.maxBarSize;
		state.stackOffset = action.payload.stackOffset;
		state.syncId = action.payload.syncId;
		state.syncMethod = action.payload.syncMethod;
		state.className = action.payload.className;
	} }
});
var rootPropsReducer = rootPropsSlice.reducer;
var { updateOptions } = rootPropsSlice.actions;

//#endregion
//#region node_modules/recharts/es6/state/polarOptionsSlice.js
var polarOptionsSlice = createSlice({
	name: "polarOptions",
	initialState: null,
	reducers: { updatePolarOptions: (_state, action) => {
		return action.payload;
	} }
});
var { updatePolarOptions } = polarOptionsSlice.actions;
var polarOptionsReducer = polarOptionsSlice.reducer;

//#endregion
//#region node_modules/recharts/es6/state/keyboardEventsMiddleware.js
var keyDownAction = createAction("keyDown");
var focusAction = createAction("focus");
var keyboardEventsMiddleware = createListenerMiddleware();
keyboardEventsMiddleware.startListening({
	actionCreator: keyDownAction,
	effect: (action, listenerApi) => {
		var state = listenerApi.getState();
		if (!(state.rootProps.accessibilityLayer !== false)) return;
		var { keyboardInteraction } = state.tooltip;
		var key = action.payload;
		if (key !== "ArrowRight" && key !== "ArrowLeft" && key !== "Enter") return;
		var currentIndex = Number(combineActiveTooltipIndex(keyboardInteraction, selectTooltipDisplayedData(state)));
		var tooltipTicks = selectTooltipAxisTicks(state);
		if (key === "Enter") {
			var _coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(keyboardInteraction.index));
			listenerApi.dispatch(setKeyboardInteraction({
				active: !keyboardInteraction.active,
				activeIndex: keyboardInteraction.index,
				activeDataKey: keyboardInteraction.dataKey,
				activeCoordinate: _coordinate
			}));
			return;
		}
		var directionMultiplier = selectChartDirection(state) === "left-to-right" ? 1 : -1;
		var nextIndex = currentIndex + (key === "ArrowRight" ? 1 : -1) * directionMultiplier;
		if (tooltipTicks == null || nextIndex >= tooltipTicks.length || nextIndex < 0) return;
		var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
		listenerApi.dispatch(setKeyboardInteraction({
			active: true,
			activeIndex: nextIndex.toString(),
			activeDataKey: void 0,
			activeCoordinate: coordinate
		}));
	}
});
keyboardEventsMiddleware.startListening({
	actionCreator: focusAction,
	effect: (_action, listenerApi) => {
		var state = listenerApi.getState();
		if (!(state.rootProps.accessibilityLayer !== false)) return;
		var { keyboardInteraction } = state.tooltip;
		if (keyboardInteraction.active) return;
		if (keyboardInteraction.index == null) {
			var nextIndex = "0";
			var coordinate = selectCoordinateForDefaultIndex(state, "axis", "hover", String(nextIndex));
			listenerApi.dispatch(setKeyboardInteraction({
				activeDataKey: void 0,
				active: true,
				activeIndex: nextIndex,
				activeCoordinate: coordinate
			}));
		}
	}
});

//#endregion
//#region node_modules/recharts/es6/state/externalEventsMiddleware.js
var externalEventAction = createAction("externalEvent");
var externalEventsMiddleware = createListenerMiddleware();
externalEventsMiddleware.startListening({
	actionCreator: externalEventAction,
	effect: (action, listenerApi) => {
		if (action.payload.handler == null) return;
		var state = listenerApi.getState();
		var nextState = {
			activeCoordinate: selectActiveTooltipCoordinate(state),
			activeDataKey: selectActiveTooltipDataKey(state),
			activeIndex: selectActiveTooltipIndex(state),
			activeLabel: selectActiveLabel(state),
			activeTooltipIndex: selectActiveTooltipIndex(state),
			isTooltipActive: selectIsTooltipActive(state)
		};
		action.payload.handler(nextState, action.payload.reactEvent);
	}
});

//#endregion
//#region node_modules/recharts/es6/state/selectors/touchSelectors.js
var selectAllTooltipPayloadConfiguration = createSelector([selectTooltipState], (tooltipState) => tooltipState.tooltipItemPayloads);
var selectTooltipCoordinate = createSelector([
	selectAllTooltipPayloadConfiguration,
	selectTooltipPayloadSearcher,
	(_state, tooltipIndex, _dataKey) => tooltipIndex,
	(_state, _tooltipIndex, dataKey) => dataKey
], (allTooltipConfigurations, tooltipPayloadSearcher, tooltipIndex, dataKey) => {
	var mostRelevantTooltipConfiguration = allTooltipConfigurations.find((tooltipConfiguration) => {
		return tooltipConfiguration.settings.dataKey === dataKey;
	});
	if (mostRelevantTooltipConfiguration == null) return;
	var { positions } = mostRelevantTooltipConfiguration;
	if (positions == null) return;
	return tooltipPayloadSearcher(positions, tooltipIndex);
});

//#endregion
//#region node_modules/recharts/es6/state/touchEventsMiddleware.js
var touchEventAction = createAction("touchMove");
var touchEventMiddleware = createListenerMiddleware();
touchEventMiddleware.startListening({
	actionCreator: touchEventAction,
	effect: (action, listenerApi) => {
		var touchEvent = action.payload;
		var state = listenerApi.getState();
		var tooltipEventType = selectTooltipEventType(state, state.tooltip.settings.shared);
		if (tooltipEventType === "axis") {
			var activeProps = selectActivePropsFromChartPointer(state, getChartPointer({
				clientX: touchEvent.touches[0].clientX,
				clientY: touchEvent.touches[0].clientY,
				currentTarget: touchEvent.currentTarget
			}));
			if ((activeProps === null || activeProps === void 0 ? void 0 : activeProps.activeIndex) != null) listenerApi.dispatch(setMouseOverAxisIndex({
				activeIndex: activeProps.activeIndex,
				activeDataKey: void 0,
				activeCoordinate: activeProps.activeCoordinate
			}));
		} else if (tooltipEventType === "item") {
			var _target$getAttribute;
			var touch = touchEvent.touches[0];
			var target = document.elementFromPoint(touch.clientX, touch.clientY);
			if (!target || !target.getAttribute) return;
			var itemIndex = target.getAttribute(DATA_ITEM_INDEX_ATTRIBUTE_NAME);
			var dataKey = (_target$getAttribute = target.getAttribute(DATA_ITEM_DATAKEY_ATTRIBUTE_NAME)) !== null && _target$getAttribute !== void 0 ? _target$getAttribute : void 0;
			var coordinate = selectTooltipCoordinate(listenerApi.getState(), itemIndex, dataKey);
			listenerApi.dispatch(setActiveMouseOverItemIndex({
				activeDataKey: dataKey,
				activeIndex: itemIndex,
				activeCoordinate: coordinate
			}));
		}
	}
});

//#endregion
//#region node_modules/recharts/es6/state/store.js
var rootReducer = combineReducers({
	brush: brushReducer,
	cartesianAxis: cartesianAxisReducer,
	chartData: chartDataReducer,
	errorBars: errorBarReducer,
	graphicalItems: graphicalItemsReducer,
	layout: chartLayoutReducer,
	legend: legendReducer,
	options: optionsReducer,
	polarAxis: polarAxisReducer,
	polarOptions: polarOptionsReducer,
	referenceElements: referenceElementsReducer,
	rootProps: rootPropsReducer,
	tooltip: tooltipReducer
});
var createRechartsStore = function createRechartsStore$1(preloadedState$1) {
	var chartName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Chart";
	return configureStore({
		reducer: rootReducer,
		preloadedState: preloadedState$1,
		middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false }).concat([
			mouseClickMiddleware.middleware,
			mouseMoveMiddleware.middleware,
			keyboardEventsMiddleware.middleware,
			externalEventsMiddleware.middleware,
			touchEventMiddleware.middleware
		]),
		enhancers: (getDefaultEnhancers) => {
			var enhancers = getDefaultEnhancers;
			if (typeof getDefaultEnhancers === "function") enhancers = getDefaultEnhancers();
			return enhancers.concat(autoBatchEnhancer({ type: "raf" }));
		},
		devTools: Global.devToolsEnabled && {
			serialize: { replacer: reduxDevtoolsJsonStringifyReplacer },
			name: "recharts-".concat(chartName)
		}
	});
};

//#endregion
//#region node_modules/recharts/es6/state/RechartsStoreProvider.js
function RechartsStoreProvider(_ref$1) {
	var { preloadedState: preloadedState$1, children, reduxStoreName } = _ref$1;
	var isPanorama = useIsPanorama();
	var storeRef = (0, import_react.useRef)(null);
	if (isPanorama) return children;
	if (storeRef.current == null) storeRef.current = createRechartsStore(preloadedState$1, reduxStoreName);
	var nonNullContext = RechartsReduxContext;
	return /* @__PURE__ */ import_react.createElement(Provider_default, {
		context: nonNullContext,
		store: storeRef.current
	}, children);
}

//#endregion
//#region node_modules/recharts/es6/state/ReportMainChartProps.js
/**
* "Main" props are props that are only accepted on the main chart,
* as opposed to the small panorama chart inside a Brush.
*/
function ReportMainChartProps(_ref$1) {
	var { layout, margin } = _ref$1;
	var dispatch = useAppDispatch();
	var isPanorama = useIsPanorama();
	(0, import_react.useEffect)(() => {
		if (!isPanorama) {
			dispatch(setLayout(layout));
			dispatch(setMargin(margin));
		}
	}, [
		dispatch,
		isPanorama,
		layout,
		margin
	]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/state/ReportChartProps.js
function ReportChartProps(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(updateOptions(props));
	}, [dispatch, props]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/container/RootSurface.js
var _excluded$5 = ["children"];
function _objectWithoutProperties$5(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$5(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$5(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$8() {
	return _extends$8 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$8.apply(null, arguments);
}
var FULL_WIDTH_AND_HEIGHT = {
	width: "100%",
	height: "100%",
	display: "block"
};
var MainChartSurface = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var width = useChartWidth();
	var height = useChartHeight();
	var hasAccessibilityLayer = useAccessibilityLayer();
	if (!isPositiveNumber(width) || !isPositiveNumber(height)) return null;
	var { children, otherAttributes, title, desc } = props;
	var tabIndex, role;
	if (typeof otherAttributes.tabIndex === "number") tabIndex = otherAttributes.tabIndex;
	else tabIndex = hasAccessibilityLayer ? 0 : void 0;
	if (typeof otherAttributes.role === "string") role = otherAttributes.role;
	else role = hasAccessibilityLayer ? "application" : void 0;
	return /* @__PURE__ */ import_react.createElement(Surface, _extends$8({}, otherAttributes, {
		title,
		desc,
		role,
		tabIndex,
		width,
		height,
		style: FULL_WIDTH_AND_HEIGHT,
		ref
	}), children);
});
var BrushPanoramaSurface = (_ref$1) => {
	var { children } = _ref$1;
	var brushDimensions = useAppSelector(selectBrushDimensions);
	if (!brushDimensions) return null;
	var { width, height, y: y$1, x: x$1 } = brushDimensions;
	return /* @__PURE__ */ import_react.createElement(Surface, {
		width,
		height,
		x: x$1,
		y: y$1
	}, children);
};
var RootSurface = /* @__PURE__ */ (0, import_react.forwardRef)((_ref2, ref) => {
	var { children } = _ref2, rest = _objectWithoutProperties$5(_ref2, _excluded$5);
	if (useIsPanorama()) return /* @__PURE__ */ import_react.createElement(BrushPanoramaSurface, null, children);
	return /* @__PURE__ */ import_react.createElement(MainChartSurface, _extends$8({ ref }, rest), children);
});

//#endregion
//#region node_modules/recharts/es6/util/useReportScale.js
function useReportScale() {
	var dispatch = useAppDispatch();
	var [ref, setRef] = (0, import_react.useState)(null);
	var scale = useAppSelector(selectContainerScale);
	(0, import_react.useEffect)(() => {
		if (ref == null) return;
		var newScale = ref.getBoundingClientRect().width / ref.offsetWidth;
		if (isWellBehavedNumber(newScale) && newScale !== scale) dispatch(setScale(newScale));
	}, [
		ref,
		dispatch,
		scale
	]);
	return setRef;
}

//#endregion
//#region node_modules/recharts/es6/chart/RechartsWrapper.js
function ownKeys$6(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$6(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$6(Object(t), !0).forEach(function(r$2) {
			_defineProperty$6(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$6(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$6(e, r$1, t) {
	return (r$1 = _toPropertyKey$6(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$6(t) {
	var i = _toPrimitive$6(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$6(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function _extends$7() {
	return _extends$7 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$7.apply(null, arguments);
}
var EventSynchronizer = () => {
	useSynchronisedEventsFromOtherCharts();
	return null;
};
function getNumberOrZero(value) {
	if (typeof value === "number") return value;
	if (typeof value === "string") {
		var parsed = parseFloat(value);
		if (!Number.isNaN(parsed)) return parsed;
	}
	return 0;
}
var ResponsiveDiv = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var _props$style, _props$style2;
	var observerRef = (0, import_react.useRef)(null);
	var [sizes, setSizes] = (0, import_react.useState)({
		containerWidth: getNumberOrZero((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.width),
		containerHeight: getNumberOrZero((_props$style2 = props.style) === null || _props$style2 === void 0 ? void 0 : _props$style2.height)
	});
	var setContainerSize = (0, import_react.useCallback)((newWidth, newHeight) => {
		setSizes((prevState) => {
			var roundedWidth = Math.round(newWidth);
			var roundedHeight = Math.round(newHeight);
			if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) return prevState;
			return {
				containerWidth: roundedWidth,
				containerHeight: roundedHeight
			};
		});
	}, []);
	var innerRef = (0, import_react.useCallback)((node) => {
		if (typeof ref === "function") ref(node);
		if (node != null) {
			var { width: containerWidth, height: containerHeight } = node.getBoundingClientRect();
			setContainerSize(containerWidth, containerHeight);
			var callback = (entries) => {
				var { width, height } = entries[0].contentRect;
				setContainerSize(width, height);
			};
			var observer = new ResizeObserver(callback);
			observer.observe(node);
			observerRef.current = observer;
		}
	}, [ref, setContainerSize]);
	(0, import_react.useEffect)(() => {
		return () => {
			var observer = observerRef.current;
			if (observer != null) observer.disconnect();
		};
	}, [setContainerSize]);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width: sizes.containerWidth,
		height: sizes.containerHeight
	}), /* @__PURE__ */ import_react.createElement("div", _extends$7({ ref: innerRef }, props)));
});
var ReadSizeOnceDiv = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { width, height } = props;
	var [sizes, setSizes] = (0, import_react.useState)({
		containerWidth: getNumberOrZero(width),
		containerHeight: getNumberOrZero(height)
	});
	var setContainerSize = (0, import_react.useCallback)((newWidth, newHeight) => {
		setSizes((prevState) => {
			var roundedWidth = Math.round(newWidth);
			var roundedHeight = Math.round(newHeight);
			if (prevState.containerWidth === roundedWidth && prevState.containerHeight === roundedHeight) return prevState;
			return {
				containerWidth: roundedWidth,
				containerHeight: roundedHeight
			};
		});
	}, []);
	var innerRef = (0, import_react.useCallback)((node) => {
		if (typeof ref === "function") ref(node);
		if (node != null) {
			var { width: containerWidth, height: containerHeight } = node.getBoundingClientRect();
			setContainerSize(containerWidth, containerHeight);
		}
	}, [ref, setContainerSize]);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width: sizes.containerWidth,
		height: sizes.containerHeight
	}), /* @__PURE__ */ import_react.createElement("div", _extends$7({ ref: innerRef }, props)));
});
var StaticDiv = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { width, height } = props;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width,
		height
	}), /* @__PURE__ */ import_react.createElement("div", _extends$7({ ref }, props)));
});
var NonResponsiveDiv = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { width, height } = props;
	if (isPercent(width) || isPercent(height)) return /* @__PURE__ */ import_react.createElement(ReadSizeOnceDiv, _extends$7({}, props, { ref }));
	return /* @__PURE__ */ import_react.createElement(StaticDiv, _extends$7({}, props, { ref }));
});
function getWrapperDivComponent(responsive) {
	return responsive === true ? ResponsiveDiv : NonResponsiveDiv;
}
var RechartsWrapper = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { children, className, height: heightFromProps, onClick, onContextMenu, onDoubleClick, onMouseDown, onMouseEnter, onMouseLeave, onMouseMove, onMouseUp, onTouchEnd, onTouchMove, onTouchStart, style, width: widthFromProps, responsive, dispatchTouchEvents = true } = props;
	var containerRef = (0, import_react.useRef)(null);
	var dispatch = useAppDispatch();
	var [tooltipPortal, setTooltipPortal] = (0, import_react.useState)(null);
	var [legendPortal, setLegendPortal] = (0, import_react.useState)(null);
	var setScaleRef = useReportScale();
	var responsiveContainerCalculations = useResponsiveContainerContext();
	var width = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.width) > 0 ? responsiveContainerCalculations.width : widthFromProps;
	var height = (responsiveContainerCalculations === null || responsiveContainerCalculations === void 0 ? void 0 : responsiveContainerCalculations.height) > 0 ? responsiveContainerCalculations.height : heightFromProps;
	var innerRef = (0, import_react.useCallback)((node) => {
		setScaleRef(node);
		if (typeof ref === "function") ref(node);
		setTooltipPortal(node);
		setLegendPortal(node);
		if (node != null) containerRef.current = node;
	}, [
		setScaleRef,
		ref,
		setTooltipPortal,
		setLegendPortal
	]);
	var myOnClick = (0, import_react.useCallback)((e) => {
		dispatch(mouseClickAction(e));
		dispatch(externalEventAction({
			handler: onClick,
			reactEvent: e
		}));
	}, [dispatch, onClick]);
	var myOnMouseEnter = (0, import_react.useCallback)((e) => {
		dispatch(mouseMoveAction(e));
		dispatch(externalEventAction({
			handler: onMouseEnter,
			reactEvent: e
		}));
	}, [dispatch, onMouseEnter]);
	var myOnMouseLeave = (0, import_react.useCallback)((e) => {
		dispatch(mouseLeaveChart());
		dispatch(externalEventAction({
			handler: onMouseLeave,
			reactEvent: e
		}));
	}, [dispatch, onMouseLeave]);
	var myOnMouseMove = (0, import_react.useCallback)((e) => {
		dispatch(mouseMoveAction(e));
		dispatch(externalEventAction({
			handler: onMouseMove,
			reactEvent: e
		}));
	}, [dispatch, onMouseMove]);
	var onFocus = (0, import_react.useCallback)(() => {
		dispatch(focusAction());
	}, [dispatch]);
	var onKeyDown = (0, import_react.useCallback)((e) => {
		dispatch(keyDownAction(e.key));
	}, [dispatch]);
	var myOnContextMenu = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onContextMenu,
			reactEvent: e
		}));
	}, [dispatch, onContextMenu]);
	var myOnDoubleClick = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onDoubleClick,
			reactEvent: e
		}));
	}, [dispatch, onDoubleClick]);
	var myOnMouseDown = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onMouseDown,
			reactEvent: e
		}));
	}, [dispatch, onMouseDown]);
	var myOnMouseUp = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onMouseUp,
			reactEvent: e
		}));
	}, [dispatch, onMouseUp]);
	var myOnTouchStart = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onTouchStart,
			reactEvent: e
		}));
	}, [dispatch, onTouchStart]);
	var myOnTouchMove = (0, import_react.useCallback)((e) => {
		if (dispatchTouchEvents) dispatch(touchEventAction(e));
		dispatch(externalEventAction({
			handler: onTouchMove,
			reactEvent: e
		}));
	}, [
		dispatch,
		dispatchTouchEvents,
		onTouchMove
	]);
	var myOnTouchEnd = (0, import_react.useCallback)((e) => {
		dispatch(externalEventAction({
			handler: onTouchEnd,
			reactEvent: e
		}));
	}, [dispatch, onTouchEnd]);
	var WrapperDiv = getWrapperDivComponent(responsive);
	return /* @__PURE__ */ import_react.createElement(TooltipPortalContext.Provider, { value: tooltipPortal }, /* @__PURE__ */ import_react.createElement(LegendPortalContext.Provider, { value: legendPortal }, /* @__PURE__ */ import_react.createElement(WrapperDiv, {
		width: width !== null && width !== void 0 ? width : style === null || style === void 0 ? void 0 : style.width,
		height: height !== null && height !== void 0 ? height : style === null || style === void 0 ? void 0 : style.height,
		className: clsx("recharts-wrapper", className),
		style: _objectSpread$6({
			position: "relative",
			cursor: "default",
			width,
			height
		}, style),
		onClick: myOnClick,
		onContextMenu: myOnContextMenu,
		onDoubleClick: myOnDoubleClick,
		onFocus,
		onKeyDown,
		onMouseDown: myOnMouseDown,
		onMouseEnter: myOnMouseEnter,
		onMouseLeave: myOnMouseLeave,
		onMouseMove: myOnMouseMove,
		onMouseUp: myOnMouseUp,
		onTouchEnd: myOnTouchEnd,
		onTouchMove: myOnTouchMove,
		onTouchStart: myOnTouchStart,
		ref: innerRef
	}, /* @__PURE__ */ import_react.createElement(EventSynchronizer, null), children)));
});

//#endregion
//#region node_modules/recharts/es6/chart/CategoricalChart.js
var _excluded$4 = [
	"width",
	"height",
	"responsive",
	"children",
	"className",
	"style",
	"compact",
	"title",
	"desc"
];
function _objectWithoutProperties$4(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$4(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$4(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
var CategoricalChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var { width, height, responsive, children, className, style, compact, title, desc } = props, others = _objectWithoutProperties$4(props, _excluded$4);
	var attrs = svgPropertiesNoEvents(others);
	if (compact) return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width,
		height
	}), /* @__PURE__ */ import_react.createElement(RootSurface, {
		otherAttributes: attrs,
		title,
		desc
	}, children));
	return /* @__PURE__ */ import_react.createElement(RechartsWrapper, {
		className,
		style,
		width,
		height,
		responsive,
		onClick: props.onClick,
		onMouseLeave: props.onMouseLeave,
		onMouseEnter: props.onMouseEnter,
		onMouseMove: props.onMouseMove,
		onMouseDown: props.onMouseDown,
		onMouseUp: props.onMouseUp,
		onContextMenu: props.onContextMenu,
		onDoubleClick: props.onDoubleClick,
		onTouchStart: props.onTouchStart,
		onTouchMove: props.onTouchMove,
		onTouchEnd: props.onTouchEnd
	}, /* @__PURE__ */ import_react.createElement(RootSurface, {
		otherAttributes: attrs,
		title,
		desc,
		ref
	}, /* @__PURE__ */ import_react.createElement(ClipPathProvider, null, children)));
});

//#endregion
//#region node_modules/recharts/es6/chart/CartesianChart.js
function _extends$6() {
	return _extends$6 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$6.apply(null, arguments);
}
var defaultProps$4 = {
	accessibilityLayer: true,
	layout: "horizontal",
	stackOffset: "none",
	barCategoryGap: "10%",
	barGap: 4,
	margin: {
		top: 5,
		right: 5,
		bottom: 5,
		left: 5
	},
	reverseStackOrder: false,
	syncMethod: "index",
	responsive: false
};
/**
* These are one-time, immutable options that decide the chart's behavior.
* Users who wish to call CartesianChart may decide to pass these options explicitly,
* but usually we would expect that they use one of the convenience components like BarChart, LineChart, etc.
*/
var CartesianChart = /* @__PURE__ */ (0, import_react.forwardRef)(function CartesianChart$1(props, ref) {
	var _categoricalChartProp;
	var rootChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$4);
	var { chartName, defaultTooltipEventType, validateTooltipEventTypes, tooltipPayloadSearcher, categoricalChartProps } = props;
	var options$2 = {
		chartName,
		defaultTooltipEventType,
		validateTooltipEventTypes,
		tooltipPayloadSearcher,
		eventEmitter: void 0
	};
	return /* @__PURE__ */ import_react.createElement(RechartsStoreProvider, {
		preloadedState: { options: options$2 },
		reduxStoreName: (_categoricalChartProp = categoricalChartProps.id) !== null && _categoricalChartProp !== void 0 ? _categoricalChartProp : chartName
	}, /* @__PURE__ */ import_react.createElement(ChartDataContextProvider, { chartData: categoricalChartProps.data }), /* @__PURE__ */ import_react.createElement(ReportMainChartProps, {
		layout: rootChartProps.layout,
		margin: rootChartProps.margin
	}), /* @__PURE__ */ import_react.createElement(ReportChartProps, {
		accessibilityLayer: rootChartProps.accessibilityLayer,
		barCategoryGap: rootChartProps.barCategoryGap,
		maxBarSize: rootChartProps.maxBarSize,
		stackOffset: rootChartProps.stackOffset,
		barGap: rootChartProps.barGap,
		barSize: rootChartProps.barSize,
		syncId: rootChartProps.syncId,
		syncMethod: rootChartProps.syncMethod,
		className: rootChartProps.className
	}), /* @__PURE__ */ import_react.createElement(CategoricalChart, _extends$6({}, rootChartProps, { ref })));
});

//#endregion
//#region node_modules/recharts/es6/chart/LineChart.js
var allowedTooltipTypes$8 = ["axis"];
var LineChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "LineChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$8,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/BarChart.js
var allowedTooltipTypes$7 = ["axis", "item"];
var BarChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "BarChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$7,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/state/ReportPolarOptions.js
function ReportPolarOptions(props) {
	var dispatch = useAppDispatch();
	(0, import_react.useEffect)(() => {
		dispatch(updatePolarOptions(props));
	}, [dispatch, props]);
	return null;
}

//#endregion
//#region node_modules/recharts/es6/chart/PolarChart.js
var _excluded$3 = ["layout"];
function _extends$5() {
	return _extends$5 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$5.apply(null, arguments);
}
function _objectWithoutProperties$3(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$3(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$3(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
/**
* These default props are the same for all PolarChart components.
*/
var defaultProps$3 = {
	accessibilityLayer: true,
	stackOffset: "none",
	barCategoryGap: "10%",
	barGap: 4,
	margin: {
		top: 5,
		right: 5,
		bottom: 5,
		left: 5
	},
	reverseStackOrder: false,
	syncMethod: "index",
	layout: "radial",
	responsive: false
};
/**
* These props are required for the PolarChart to function correctly.
* Users usually would not need to specify these explicitly,
* because the convenience components like PieChart, RadarChart, etc.
* will provide these defaults.
* We can't have the defaults in this file because each of those convenience components
* have their own opinions about what they should be.
*/
/**
* These are one-time, immutable options that decide the chart's behavior.
* Users who wish to call CartesianChart may decide to pass these options explicitly,
* but usually we would expect that they use one of the convenience components like PieChart, RadarChart, etc.
*/
var PolarChart = /* @__PURE__ */ (0, import_react.forwardRef)(function PolarChart$1(props, ref) {
	var _polarChartProps$id;
	var polarChartProps = resolveDefaultProps(props.categoricalChartProps, defaultProps$3);
	var { layout } = polarChartProps, otherCategoricalProps = _objectWithoutProperties$3(polarChartProps, _excluded$3);
	var { chartName, defaultTooltipEventType, validateTooltipEventTypes, tooltipPayloadSearcher } = props;
	var options$2 = {
		chartName,
		defaultTooltipEventType,
		validateTooltipEventTypes,
		tooltipPayloadSearcher,
		eventEmitter: void 0
	};
	return /* @__PURE__ */ import_react.createElement(RechartsStoreProvider, {
		preloadedState: { options: options$2 },
		reduxStoreName: (_polarChartProps$id = polarChartProps.id) !== null && _polarChartProps$id !== void 0 ? _polarChartProps$id : chartName
	}, /* @__PURE__ */ import_react.createElement(ChartDataContextProvider, { chartData: polarChartProps.data }), /* @__PURE__ */ import_react.createElement(ReportMainChartProps, {
		layout,
		margin: polarChartProps.margin
	}), /* @__PURE__ */ import_react.createElement(ReportChartProps, {
		accessibilityLayer: polarChartProps.accessibilityLayer,
		barCategoryGap: polarChartProps.barCategoryGap,
		maxBarSize: polarChartProps.maxBarSize,
		stackOffset: polarChartProps.stackOffset,
		barGap: polarChartProps.barGap,
		barSize: polarChartProps.barSize,
		syncId: polarChartProps.syncId,
		syncMethod: polarChartProps.syncMethod,
		className: polarChartProps.className
	}), /* @__PURE__ */ import_react.createElement(ReportPolarOptions, {
		cx: polarChartProps.cx,
		cy: polarChartProps.cy,
		startAngle: polarChartProps.startAngle,
		endAngle: polarChartProps.endAngle,
		innerRadius: polarChartProps.innerRadius,
		outerRadius: polarChartProps.outerRadius
	}), /* @__PURE__ */ import_react.createElement(CategoricalChart, _extends$5({}, otherCategoricalProps, { ref })));
});

//#endregion
//#region node_modules/recharts/es6/chart/PieChart.js
var allowedTooltipTypes$6 = ["item"];
var defaultProps$2 = {
	layout: "centric",
	startAngle: 0,
	endAngle: 360,
	cx: "50%",
	cy: "50%",
	innerRadius: 0,
	outerRadius: "80%"
};
var PieChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var propsWithDefaults = resolveDefaultProps(props, defaultProps$2);
	return /* @__PURE__ */ import_react.createElement(PolarChart, {
		chartName: "PieChart",
		defaultTooltipEventType: "item",
		validateTooltipEventTypes: allowedTooltipTypes$6,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: propsWithDefaults,
		ref
	});
});

//#endregion
//#region node_modules/es-toolkit/dist/predicate/isBuffer.js
var require_isBuffer = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/predicate/isBuffer.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isBuffer$1(x$1) {
		return typeof Buffer !== "undefined" && Buffer.isBuffer(x$1);
	}
	exports.isBuffer = isBuffer$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/isPrototype.js
var require_isPrototype = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/isPrototype.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	function isPrototype$1(value) {
		const constructor = value?.constructor;
		const prototype = typeof constructor === "function" ? constructor.prototype : Object.prototype;
		return value === prototype;
	}
	exports.isPrototype = isPrototype$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/predicate/isTypedArray.js
var require_isTypedArray = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/predicate/isTypedArray.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isTypedArray$1 = require_isTypedArray$1();
	function isTypedArray$2(x$1) {
		return isTypedArray$1.isTypedArray(x$1);
	}
	exports.isTypedArray = isTypedArray$2;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/toInteger.js
var require_toInteger = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/toInteger.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var toFinite = require_toFinite();
	function toInteger$1(value) {
		const finite = toFinite.toFinite(value);
		const remainder = finite % 1;
		return remainder ? finite - remainder : finite;
	}
	exports.toInteger = toInteger$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/util/times.js
var require_times = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/util/times.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var toInteger = require_toInteger();
	function times$1(n, getValue$1) {
		n = toInteger.toInteger(n);
		if (n < 1 || !Number.isSafeInteger(n)) return [];
		const result = new Array(n);
		for (let i = 0; i < n; i++) result[i] = typeof getValue$1 === "function" ? getValue$1(i) : i;
		return result;
	}
	exports.times = times$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/keysIn.js
var require_keysIn = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/keysIn.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isBuffer = require_isBuffer();
	var isPrototype = require_isPrototype();
	var isArrayLike$1 = require_isArrayLike();
	var isTypedArray = require_isTypedArray();
	var times = require_times();
	function keysIn$1(object) {
		if (object == null) return [];
		switch (typeof object) {
			case "object":
			case "function":
				if (isArrayLike$1.isArrayLike(object)) return arrayLikeKeysIn(object);
				if (isPrototype.isPrototype(object)) return prototypeKeysIn(object);
				return keysInImpl(object);
			default: return keysInImpl(Object(object));
		}
	}
	function keysInImpl(object) {
		const result = [];
		for (const key in object) result.push(key);
		return result;
	}
	function prototypeKeysIn(object) {
		return keysInImpl(object).filter((key) => key !== "constructor");
	}
	function arrayLikeKeysIn(object) {
		const indices = times.times(object.length, (index) => `${index}`);
		const filteredKeys = new Set(indices);
		if (isBuffer.isBuffer(object)) {
			filteredKeys.add("offset");
			filteredKeys.add("parent");
		}
		if (isTypedArray.isTypedArray(object)) {
			filteredKeys.add("buffer");
			filteredKeys.add("byteLength");
			filteredKeys.add("byteOffset");
		}
		return [...indices, ...keysInImpl(object).filter((key) => !filteredKeys.has(key))];
	}
	exports.keysIn = keysIn$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/unset.js
var require_unset = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/unset.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var get$3 = require_get$1();
	var isUnsafeProperty = require_isUnsafeProperty();
	var isDeepKey$1 = require_isDeepKey();
	var toKey = require_toKey();
	var toPath = require_toPath();
	function unset$1(obj, path$1) {
		if (obj == null) return true;
		switch (typeof path$1) {
			case "symbol":
			case "number":
			case "object":
				if (Array.isArray(path$1)) return unsetWithPath(obj, path$1);
				if (typeof path$1 === "number") path$1 = toKey.toKey(path$1);
				else if (typeof path$1 === "object") if (Object.is(path$1?.valueOf(), -0)) path$1 = "-0";
				else path$1 = String(path$1);
				if (isUnsafeProperty.isUnsafeProperty(path$1)) return false;
				if (obj?.[path$1] === void 0) return true;
				try {
					delete obj[path$1];
					return true;
				} catch {
					return false;
				}
			case "string":
				if (obj?.[path$1] === void 0 && isDeepKey$1.isDeepKey(path$1)) return unsetWithPath(obj, toPath.toPath(path$1));
				if (isUnsafeProperty.isUnsafeProperty(path$1)) return false;
				try {
					delete obj[path$1];
					return true;
				} catch {
					return false;
				}
		}
	}
	function unsetWithPath(obj, path$1) {
		const parent = path$1.length === 1 ? obj : get$3.get(obj, path$1.slice(0, -1));
		const lastKey = path$1[path$1.length - 1];
		if (parent?.[lastKey] === void 0) return true;
		if (isUnsafeProperty.isUnsafeProperty(lastKey)) return false;
		try {
			delete parent[lastKey];
			return true;
		} catch {
			return false;
		}
	}
	exports.unset = unset$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.js
var require_getSymbolsIn = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/_internal/getSymbolsIn.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var getSymbols = require_getSymbols();
	function getSymbolsIn$1(object) {
		const result = [];
		while (object) {
			result.push(...getSymbols.getSymbols(object));
			object = Object.getPrototypeOf(object);
		}
		return result;
	}
	exports.getSymbolsIn = getSymbolsIn$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/array/flatten.js
var require_flatten = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/array/flatten.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var isArrayLike = require_isArrayLike();
	function flatten$1(value, depth = 1) {
		const result = [];
		const flooredDepth = Math.floor(depth);
		if (!isArrayLike.isArrayLike(value)) return result;
		const recursive = (arr, currentDepth) => {
			for (let i = 0; i < arr.length; i++) {
				const item = arr[i];
				if (currentDepth < flooredDepth && (Array.isArray(item) || Boolean(item?.[Symbol.isConcatSpreadable]) || item !== null && typeof item === "object" && Object.prototype.toString.call(item) === "[object Arguments]")) if (Array.isArray(item)) recursive(item, currentDepth + 1);
				else recursive(Array.from(item), currentDepth + 1);
				else result.push(item);
			}
		};
		recursive(Array.from(value), 0);
		return result;
	}
	exports.flatten = flatten$1;
}) });

//#endregion
//#region node_modules/es-toolkit/dist/compat/object/omit.js
var require_omit$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/object/omit.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var cloneDeepWith = require_cloneDeepWith();
	var keysIn = require_keysIn();
	var unset = require_unset();
	var getSymbolsIn = require_getSymbolsIn();
	var isDeepKey = require_isDeepKey();
	var flatten = require_flatten();
	var isPlainObject = require_isPlainObject$1();
	function omit$2(obj, ...keysArr) {
		if (obj == null) return {};
		keysArr = flatten.flatten(keysArr);
		const result = cloneInOmit(obj, keysArr);
		for (let i = 0; i < keysArr.length; i++) {
			let keys = keysArr[i];
			switch (typeof keys) {
				case "object":
					if (!Array.isArray(keys)) keys = Array.from(keys);
					for (let j = 0; j < keys.length; j++) {
						const key = keys[j];
						unset.unset(result, key);
					}
					break;
				case "string":
				case "symbol":
				case "number":
					unset.unset(result, keys);
					break;
			}
		}
		return result;
	}
	function cloneInOmit(obj, keys) {
		if (keys.some((key) => Array.isArray(key) || isDeepKey.isDeepKey(key))) return deepCloneInOmit(obj);
		return shallowCloneInOmit(obj);
	}
	function shallowCloneInOmit(obj) {
		const result = {};
		const keysToCopy = [...keysIn.keysIn(obj), ...getSymbolsIn.getSymbolsIn(obj)];
		for (let i = 0; i < keysToCopy.length; i++) {
			const key = keysToCopy[i];
			result[key] = obj[key];
		}
		return result;
	}
	function deepCloneInOmit(obj) {
		const result = {};
		const keysToCopy = [...keysIn.keysIn(obj), ...getSymbolsIn.getSymbolsIn(obj)];
		for (let i = 0; i < keysToCopy.length; i++) {
			const key = keysToCopy[i];
			result[key] = cloneDeepWith.cloneDeepWith(obj[key], (valueToClone) => {
				if (isPlainObject.isPlainObject(valueToClone)) return;
				return valueToClone;
			});
		}
		return result;
	}
	exports.omit = omit$2;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/omit.js
var require_omit = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/omit.js": ((exports, module) => {
	module.exports = require_omit$1().omit;
}) });

//#endregion
//#region node_modules/recharts/es6/chart/Treemap.js
var import_omit$1 = /* @__PURE__ */ __toESM(require_omit());
var import_get$2 = /* @__PURE__ */ __toESM(require_get());
var _excluded$2 = [
	"width",
	"height",
	"className",
	"style",
	"children",
	"type"
];
function _objectWithoutProperties$2(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$2(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$2(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function _extends$4() {
	return _extends$4 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$4.apply(null, arguments);
}
function ownKeys$5(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$5(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$5(Object(t), !0).forEach(function(r$2) {
			_defineProperty$5(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$5(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$5(e, r$1, t) {
	return (r$1 = _toPropertyKey$5(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$5(t) {
	var i = _toPrimitive$5(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$5(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var NODE_VALUE_KEY = "value";
/**
* This is what end users defines as `data` on Treemap.
*/
/**
* This is what is returned from `squarify`, the final treemap data structure
* that gets rendered and is stored in
*/
var treemapPayloadSearcher = (data, activeIndex) => {
	if (!data || !activeIndex) return;
	return (0, import_get$2.default)(data, activeIndex);
};
var addToTreemapNodeIndex = function addToTreemapNodeIndex$1(indexInChildrenArr) {
	var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
	return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
var options$1 = {
	chartName: "Treemap",
	defaultTooltipEventType: "item",
	validateTooltipEventTypes: ["item"],
	tooltipPayloadSearcher: treemapPayloadSearcher,
	eventEmitter: void 0
};
var computeNode = (_ref$1) => {
	var { depth, node, index, dataKey, nameKey, nestedActiveTooltipIndex } = _ref$1;
	var currentTooltipIndex = depth === 0 ? "" : addToTreemapNodeIndex(index, nestedActiveTooltipIndex);
	var { children } = node;
	var childDepth = depth + 1;
	var computedChildren = children && children.length ? children.map((child, i) => computeNode({
		depth: childDepth,
		node: child,
		index: i,
		dataKey,
		nameKey,
		nestedActiveTooltipIndex: currentTooltipIndex
	})) : null;
	var nodeValue;
	if (computedChildren && computedChildren.length) nodeValue = computedChildren.reduce((result, child) => result + child[NODE_VALUE_KEY], 0);
	else nodeValue = isNan(node[dataKey]) || node[dataKey] <= 0 ? 0 : node[dataKey];
	return _objectSpread$5(_objectSpread$5({}, node), {}, {
		children: computedChildren,
		name: getValueByDataKey(node, nameKey, ""),
		[NODE_VALUE_KEY]: nodeValue,
		depth,
		index,
		tooltipIndex: currentTooltipIndex
	});
};
var filterRect = (node) => ({
	x: node.x,
	y: node.y,
	width: node.width,
	height: node.height
});
var getAreaOfChildren = (children, areaValueRatio) => {
	var ratio = areaValueRatio < 0 ? 0 : areaValueRatio;
	return children.map((child) => {
		var area = child[NODE_VALUE_KEY] * ratio;
		return _objectSpread$5(_objectSpread$5({}, child), {}, { area: isNan(area) || area <= 0 ? 0 : area });
	});
};
var getWorstScore = (row, parentSize, aspectRatio) => {
	var parentArea = parentSize * parentSize;
	var rowArea = row.area * row.area;
	var { min: min$1, max: max$1 } = row.reduce((result, child) => ({
		min: Math.min(result.min, child.area),
		max: Math.max(result.max, child.area)
	}), {
		min: Infinity,
		max: 0
	});
	return rowArea ? Math.max(parentArea * max$1 * aspectRatio / rowArea, rowArea / (parentArea * min$1 * aspectRatio)) : Infinity;
};
var horizontalPosition = (row, parentSize, parentRect, isFlush) => {
	var rowHeight = parentSize ? Math.round(row.area / parentSize) : 0;
	if (isFlush || rowHeight > parentRect.height) rowHeight = parentRect.height;
	var curX = parentRect.x;
	var child;
	for (var i = 0, len = row.length; i < len; i++) {
		child = row[i];
		child.x = curX;
		child.y = parentRect.y;
		child.height = rowHeight;
		child.width = Math.min(rowHeight ? Math.round(child.area / rowHeight) : 0, parentRect.x + parentRect.width - curX);
		curX += child.width;
	}
	if (child != null) child.width += parentRect.x + parentRect.width - curX;
	return _objectSpread$5(_objectSpread$5({}, parentRect), {}, {
		y: parentRect.y + rowHeight,
		height: parentRect.height - rowHeight
	});
};
var verticalPosition = (row, parentSize, parentRect, isFlush) => {
	var rowWidth = parentSize ? Math.round(row.area / parentSize) : 0;
	if (isFlush || rowWidth > parentRect.width) rowWidth = parentRect.width;
	var curY = parentRect.y;
	var child;
	for (var i = 0, len = row.length; i < len; i++) {
		child = row[i];
		child.x = parentRect.x;
		child.y = curY;
		child.width = rowWidth;
		child.height = Math.min(rowWidth ? Math.round(child.area / rowWidth) : 0, parentRect.y + parentRect.height - curY);
		curY += child.height;
	}
	if (child) child.height += parentRect.y + parentRect.height - curY;
	return _objectSpread$5(_objectSpread$5({}, parentRect), {}, {
		x: parentRect.x + rowWidth,
		width: parentRect.width - rowWidth
	});
};
var position = (row, parentSize, parentRect, isFlush) => {
	if (parentSize === parentRect.width) return horizontalPosition(row, parentSize, parentRect, isFlush);
	return verticalPosition(row, parentSize, parentRect, isFlush);
};
var squarify = (node, aspectRatio) => {
	var { children } = node;
	if (children && children.length) {
		var rect = filterRect(node);
		var row = [];
		var best = Infinity;
		var child, score;
		var size = Math.min(rect.width, rect.height);
		var scaleChildren = getAreaOfChildren(children, rect.width * rect.height / node[NODE_VALUE_KEY]);
		var tempChildren = scaleChildren.slice();
		row.area = 0;
		while (tempChildren.length > 0) {
			row.push(child = tempChildren[0]);
			row.area += child.area;
			score = getWorstScore(row, size, aspectRatio);
			if (score <= best) {
				tempChildren.shift();
				best = score;
			} else {
				var _row$pop$area, _row$pop;
				row.area -= (_row$pop$area = (_row$pop = row.pop()) === null || _row$pop === void 0 ? void 0 : _row$pop.area) !== null && _row$pop$area !== void 0 ? _row$pop$area : 0;
				rect = position(row, size, rect, false);
				size = Math.min(rect.width, rect.height);
				row.length = row.area = 0;
				best = Infinity;
			}
		}
		if (row.length) {
			rect = position(row, size, rect, true);
			row.length = row.area = 0;
		}
		return _objectSpread$5(_objectSpread$5({}, node), {}, { children: scaleChildren.map((c$1) => squarify(c$1, aspectRatio)) });
	}
	return node;
};
var defaultTreeMapProps = {
	aspectRatio: .5 * (1 + Math.sqrt(5)),
	dataKey: "value",
	nameKey: "name",
	type: "flat",
	isAnimationActive: !Global.isSsr,
	isUpdateAnimationActive: !Global.isSsr,
	animationBegin: 0,
	animationDuration: 1500,
	animationEasing: "linear"
};
var defaultState = {
	isAnimationFinished: false,
	formatRoot: null,
	currentRoot: null,
	nestIndex: [],
	prevAspectRatio: defaultTreeMapProps.aspectRatio,
	prevDataKey: defaultTreeMapProps.dataKey
};
function ContentItem(_ref2) {
	var { content, nodeProps, type, colorPanel, onMouseEnter, onMouseLeave, onClick } = _ref2;
	if (/* @__PURE__ */ import_react.isValidElement(content)) return /* @__PURE__ */ import_react.createElement(Layer, {
		onMouseEnter,
		onMouseLeave,
		onClick
	}, /* @__PURE__ */ import_react.cloneElement(content, nodeProps));
	if (typeof content === "function") return /* @__PURE__ */ import_react.createElement(Layer, {
		onMouseEnter,
		onMouseLeave,
		onClick
	}, content(nodeProps));
	var { x: x$1, y: y$1, width, height, index } = nodeProps;
	var arrow = null;
	if (width > 10 && height > 10 && nodeProps.children && type === "nest") arrow = /* @__PURE__ */ import_react.createElement(Polygon, { points: [
		{
			x: x$1 + 2,
			y: y$1 + height / 2
		},
		{
			x: x$1 + 6,
			y: y$1 + height / 2 + 3
		},
		{
			x: x$1 + 2,
			y: y$1 + height / 2 + 6
		}
	] });
	var text = null;
	var nameSize = getStringSize(nodeProps.name);
	if (width > 20 && height > 20 && nameSize.width < width && nameSize.height < height) text = /* @__PURE__ */ import_react.createElement("text", {
		x: x$1 + 8,
		y: y$1 + height / 2 + 7,
		fontSize: 14
	}, nodeProps.name);
	var colors = colorPanel || COLOR_PANEL;
	return /* @__PURE__ */ import_react.createElement("g", null, /* @__PURE__ */ import_react.createElement(Rectangle, _extends$4({
		fill: nodeProps.depth < 2 ? colors[index % colors.length] : "rgba(255,255,255,0)",
		stroke: "#fff"
	}, (0, import_omit$1.default)(nodeProps, ["children"]), {
		onMouseEnter,
		onMouseLeave,
		onClick,
		"data-recharts-item-index": nodeProps.tooltipIndex
	})), arrow, text);
}
function ContentItemWithEvents(props) {
	var dispatch = useAppDispatch();
	var activeCoordinate = {
		x: props.nodeProps.x + props.nodeProps.width / 2,
		y: props.nodeProps.y + props.nodeProps.height / 2
	};
	var onMouseEnter = () => {
		dispatch(setActiveMouseOverItemIndex({
			activeIndex: props.nodeProps.tooltipIndex,
			activeDataKey: props.dataKey,
			activeCoordinate
		}));
	};
	var onMouseLeave = () => {};
	var onClick = () => {
		dispatch(setActiveClickItemIndex({
			activeIndex: props.nodeProps.tooltipIndex,
			activeDataKey: props.dataKey,
			activeCoordinate
		}));
	};
	return /* @__PURE__ */ import_react.createElement(ContentItem, _extends$4({}, props, {
		onMouseEnter,
		onMouseLeave,
		onClick
	}));
}
function getTooltipEntrySettings$3(_ref3) {
	var { props, currentRoot } = _ref3;
	var { dataKey, nameKey, stroke, fill } = props;
	return {
		dataDefinedOnItem: currentRoot,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth: void 0,
			fill,
			dataKey,
			nameKey,
			name: void 0,
			hide: false,
			type: void 0,
			color: fill,
			unit: ""
		}
	};
}
var defaultTreemapMargin = {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0
};
function TreemapItem(_ref4) {
	var { content, nodeProps, isLeaf, treemapProps, onNestClick } = _ref4;
	var { isAnimationActive, animationBegin, animationDuration, animationEasing, isUpdateAnimationActive, type, colorPanel, dataKey, onAnimationStart, onAnimationEnd, onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps } = treemapProps;
	var { width, height, x: x$1, y: y$1 } = nodeProps;
	var translateX = -x$1 - width;
	var translateY = 0;
	var onMouseEnter = (e) => {
		if ((isLeaf || type === "nest") && typeof onMouseEnterFromProps === "function") onMouseEnterFromProps(nodeProps, e);
	};
	var onMouseLeave = (e) => {
		if ((isLeaf || type === "nest") && typeof onMouseLeaveFromProps === "function") onMouseLeaveFromProps(nodeProps, e);
	};
	var onClick = () => {
		if (type === "nest") onNestClick(nodeProps);
		if ((isLeaf || type === "nest") && typeof onItemClickFromProps === "function") onItemClickFromProps(nodeProps);
	};
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(CSSTransitionAnimate, {
		animationId: "treemap-".concat(nodeProps.tooltipIndex),
		from: "translate(".concat(translateX, "px, ").concat(translateY, "px)"),
		to: "translate(0, 0)",
		attributeName: "transform",
		begin: animationBegin,
		easing: animationEasing,
		isActive: isAnimationActive,
		duration: animationDuration,
		onAnimationStart: handleAnimationStart,
		onAnimationEnd: handleAnimationEnd
	}, (style) => /* @__PURE__ */ import_react.createElement(Layer, {
		onMouseEnter,
		onMouseLeave,
		onClick,
		style: _objectSpread$5(_objectSpread$5({}, style), {}, { transformOrigin: "".concat(x$1, " ").concat(y$1) })
	}, /* @__PURE__ */ import_react.createElement(ContentItemWithEvents, {
		content,
		dataKey,
		nodeProps: _objectSpread$5(_objectSpread$5({}, nodeProps), {}, {
			isAnimationActive,
			isUpdateAnimationActive: !isUpdateAnimationActive,
			width,
			height,
			x: x$1,
			y: y$1
		}),
		type,
		colorPanel
	})));
}
var TreemapWithState = class extends import_react.PureComponent {
	constructor() {
		super(...arguments);
		_defineProperty$5(this, "state", _objectSpread$5({}, defaultState));
		_defineProperty$5(this, "handleClick", (node) => {
			var { onClick, type } = this.props;
			if (type === "nest" && node.children) {
				var { width, height, dataKey, nameKey, aspectRatio } = this.props;
				var root = computeNode({
					depth: 0,
					node: _objectSpread$5(_objectSpread$5({}, node), {}, {
						x: 0,
						y: 0,
						width,
						height
					}),
					index: 0,
					dataKey,
					nameKey,
					nestedActiveTooltipIndex: node.tooltipIndex
				});
				var formatRoot = squarify(root, aspectRatio);
				var { nestIndex } = this.state;
				nestIndex.push(node);
				this.setState({
					formatRoot,
					currentRoot: root,
					nestIndex
				});
			}
			if (onClick) onClick(node);
		});
		_defineProperty$5(this, "handleTouchMove", (e) => {
			var touchEvent = e.touches[0];
			var target = document.elementFromPoint(touchEvent.clientX, touchEvent.clientY);
			if (!target || !target.getAttribute || this.state.formatRoot == null) return;
			var itemIndex = target.getAttribute("data-recharts-item-index");
			var activeNode = treemapPayloadSearcher(this.state.formatRoot, itemIndex);
			if (!activeNode) return;
			var { dataKey, dispatch } = this.props;
			var activeCoordinate = {
				x: activeNode.x + activeNode.width / 2,
				y: activeNode.y + activeNode.height / 2
			};
			dispatch(setActiveMouseOverItemIndex({
				activeIndex: itemIndex,
				activeDataKey: dataKey,
				activeCoordinate
			}));
		});
	}
	static getDerivedStateFromProps(nextProps, prevState) {
		if (nextProps.data !== prevState.prevData || nextProps.type !== prevState.prevType || nextProps.width !== prevState.prevWidth || nextProps.height !== prevState.prevHeight || nextProps.dataKey !== prevState.prevDataKey || nextProps.aspectRatio !== prevState.prevAspectRatio) {
			var root = computeNode({
				depth: 0,
				node: {
					children: nextProps.data,
					x: 0,
					y: 0,
					width: nextProps.width,
					height: nextProps.height
				},
				index: 0,
				dataKey: nextProps.dataKey,
				nameKey: nextProps.nameKey
			});
			var formatRoot = squarify(root, nextProps.aspectRatio);
			return _objectSpread$5(_objectSpread$5({}, prevState), {}, {
				formatRoot,
				currentRoot: root,
				nestIndex: [root],
				prevAspectRatio: nextProps.aspectRatio,
				prevData: nextProps.data,
				prevWidth: nextProps.width,
				prevHeight: nextProps.height,
				prevDataKey: nextProps.dataKey,
				prevType: nextProps.type
			});
		}
		return null;
	}
	handleNestIndex(node, i) {
		var { nestIndex } = this.state;
		var { width, height, dataKey, nameKey, aspectRatio } = this.props;
		var root = computeNode({
			depth: 0,
			node: _objectSpread$5(_objectSpread$5({}, node), {}, {
				x: 0,
				y: 0,
				width,
				height
			}),
			index: 0,
			dataKey,
			nameKey,
			nestedActiveTooltipIndex: node.tooltipIndex
		});
		var formatRoot = squarify(root, aspectRatio);
		nestIndex = nestIndex.slice(0, i + 1);
		this.setState({
			formatRoot,
			currentRoot: node,
			nestIndex
		});
	}
	renderNode(root, node) {
		var { content, type } = this.props;
		var nodeProps = _objectSpread$5(_objectSpread$5(_objectSpread$5({}, svgPropertiesNoEvents(this.props)), node), {}, { root });
		var isLeaf = !node.children || !node.children.length;
		var { currentRoot } = this.state;
		if (!((currentRoot === null || currentRoot === void 0 ? void 0 : currentRoot.children) || []).filter((item) => item.depth === node.depth && item.name === node.name).length && root.depth && type === "nest") return null;
		return /* @__PURE__ */ import_react.createElement(Layer, {
			key: "recharts-treemap-node-".concat(nodeProps.x, "-").concat(nodeProps.y, "-").concat(nodeProps.name),
			className: "recharts-treemap-depth-".concat(node.depth)
		}, /* @__PURE__ */ import_react.createElement(TreemapItem, {
			isLeaf,
			content,
			nodeProps,
			treemapProps: this.props,
			onNestClick: this.handleClick
		}), node.children && node.children.length ? node.children.map((child) => this.renderNode(node, child)) : null);
	}
	renderAllNodes() {
		var { formatRoot } = this.state;
		if (!formatRoot) return null;
		return this.renderNode(formatRoot, formatRoot);
	}
	renderNestIndex() {
		var { nameKey, nestIndexContent } = this.props;
		var { nestIndex } = this.state;
		return /* @__PURE__ */ import_react.createElement("div", {
			className: "recharts-treemap-nest-index-wrapper",
			style: {
				marginTop: "8px",
				textAlign: "center"
			}
		}, nestIndex.map((item, i) => {
			var name = (0, import_get$2.default)(item, nameKey, "root");
			var content;
			if (/* @__PURE__ */ import_react.isValidElement(nestIndexContent)) content = /* @__PURE__ */ import_react.cloneElement(nestIndexContent, item, i);
			if (typeof nestIndexContent === "function") content = nestIndexContent(item, i);
			else content = name;
			return /* @__PURE__ */ import_react.createElement("div", {
				onClick: this.handleNestIndex.bind(this, item, i),
				key: "nest-index-".concat(uniqueId()),
				className: "recharts-treemap-nest-index-box",
				style: {
					cursor: "pointer",
					display: "inline-block",
					padding: "0 7px",
					background: "#000",
					color: "#fff",
					marginRight: "3px"
				}
			}, content);
		}));
	}
	render() {
		var _this$props = this.props, { width, height, className, style, children, type } = _this$props, others = _objectWithoutProperties$2(_this$props, _excluded$2);
		var attrs = svgPropertiesNoEvents(others);
		return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
			fn: getTooltipEntrySettings$3,
			args: {
				props: this.props,
				currentRoot: this.state.currentRoot
			}
		}), /* @__PURE__ */ import_react.createElement(Surface, _extends$4({}, attrs, {
			width,
			height: type === "nest" ? height - 30 : height,
			onTouchMove: this.handleTouchMove
		}), this.renderAllNodes(), children), type === "nest" && this.renderNestIndex());
	}
};
_defineProperty$5(TreemapWithState, "displayName", "Treemap");
function TreemapDispatchInject(props) {
	var dispatch = useAppDispatch();
	var width = useChartWidth();
	var height = useChartHeight();
	if (!isPositiveNumber(width) || !isPositiveNumber(height)) return null;
	return /* @__PURE__ */ import_react.createElement(TreemapWithState, _extends$4({}, props, {
		width,
		height,
		dispatch
	}));
}
function Treemap(outsideProps) {
	var _props$className;
	var props = resolveDefaultProps(outsideProps, defaultTreeMapProps);
	var { className, style, width, height } = props;
	var [tooltipPortal, setTooltipPortal] = (0, import_react.useState)(null);
	return /* @__PURE__ */ import_react.createElement(RechartsStoreProvider, {
		preloadedState: { options: options$1 },
		reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "Treemap"
	}, /* @__PURE__ */ import_react.createElement(ReportChartMargin, { margin: defaultTreemapMargin }), /* @__PURE__ */ import_react.createElement(RechartsWrapper, {
		dispatchTouchEvents: false,
		className,
		style,
		width,
		height,
		responsive: false,
		ref: (node) => {
			if (tooltipPortal == null && node != null) setTooltipPortal(node);
		},
		onMouseEnter: void 0,
		onMouseLeave: void 0,
		onClick: void 0,
		onMouseMove: void 0,
		onMouseDown: void 0,
		onMouseUp: void 0,
		onContextMenu: void 0,
		onDoubleClick: void 0,
		onTouchStart: void 0,
		onTouchMove: void 0,
		onTouchEnd: void 0
	}, /* @__PURE__ */ import_react.createElement(TooltipPortalContext.Provider, { value: tooltipPortal }, /* @__PURE__ */ import_react.createElement(TreemapDispatchInject, props))));
}

//#endregion
//#region node_modules/es-toolkit/dist/compat/math/sumBy.js
var require_sumBy$1 = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/dist/compat/math/sumBy.js": ((exports) => {
	Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
	var iteratee = require_iteratee();
	function sumBy$1(array, iteratee$1$1) {
		if (!array || !array.length) return 0;
		if (iteratee$1$1 != null) iteratee$1$1 = iteratee.iteratee(iteratee$1$1);
		let result = void 0;
		for (let i = 0; i < array.length; i++) {
			const current$1 = iteratee$1$1 ? iteratee$1$1(array[i]) : array[i];
			if (current$1 !== void 0) if (result === void 0) result = current$1;
			else result += current$1;
		}
		return result;
	}
	exports.sumBy = sumBy$1;
}) });

//#endregion
//#region node_modules/es-toolkit/compat/sumBy.js
var require_sumBy = /* @__PURE__ */ __commonJS({ "node_modules/es-toolkit/compat/sumBy.js": ((exports, module) => {
	module.exports = require_sumBy$1().sumBy;
}) });

//#endregion
//#region node_modules/recharts/es6/chart/Sankey.js
var import_maxBy = /* @__PURE__ */ __toESM(require_maxBy());
var import_sumBy = /* @__PURE__ */ __toESM(require_sumBy());
var import_get$1 = /* @__PURE__ */ __toESM(require_get());
var _excluded$1 = [
	"sourceX",
	"sourceY",
	"sourceControlX",
	"targetX",
	"targetY",
	"targetControlX",
	"linkWidth"
], _excluded2$1 = [
	"className",
	"style",
	"children"
];
function _extends$3() {
	return _extends$3 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$3.apply(null, arguments);
}
function _objectWithoutProperties$1(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose$1(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose$1(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys$4(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$4(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$4(Object(t), !0).forEach(function(r$2) {
			_defineProperty$4(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$4(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$4(e, r$1, t) {
	return (r$1 = _toPropertyKey$4(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$4(t) {
	var i = _toPrimitive$4(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$4(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var interpolationGenerator = (a$1, b) => {
	var ka$1 = +a$1;
	var kb = b - ka$1;
	return (t) => ka$1 + kb * t;
};
var centerY = (node) => node.y + node.dy / 2;
var getValue = (entry) => entry && entry.value || 0;
var getSumOfIds = (links, ids) => ids.reduce((result, id) => result + getValue(links[id]), 0);
var getSumWithWeightedSource = (tree, links, ids) => ids.reduce((result, id) => {
	var link = links[id];
	var sourceNode = tree[link.source];
	return result + centerY(sourceNode) * getValue(links[id]);
}, 0);
var getSumWithWeightedTarget = (tree, links, ids) => ids.reduce((result, id) => {
	var link = links[id];
	var targetNode = tree[link.target];
	return result + centerY(targetNode) * getValue(links[id]);
}, 0);
var ascendingY = (a$1, b) => a$1.y - b.y;
var searchTargetsAndSources = (links, id) => {
	var sourceNodes = [];
	var sourceLinks = [];
	var targetNodes = [];
	var targetLinks = [];
	for (var i = 0, len = links.length; i < len; i++) {
		var link = links[i];
		if (link.source === id) {
			targetNodes.push(link.target);
			targetLinks.push(i);
		}
		if (link.target === id) {
			sourceNodes.push(link.source);
			sourceLinks.push(i);
		}
	}
	return {
		sourceNodes,
		sourceLinks,
		targetLinks,
		targetNodes
	};
};
var updateDepthOfTargets = (tree, curNode) => {
	var { targetNodes } = curNode;
	for (var i = 0, len = targetNodes.length; i < len; i++) {
		var target = tree[targetNodes[i]];
		if (target) {
			target.depth = Math.max(curNode.depth + 1, target.depth);
			updateDepthOfTargets(tree, target);
		}
	}
};
var getNodesTree = (_ref$1, width, nodeWidth) => {
	var _maxBy$depth, _maxBy;
	var { nodes, links } = _ref$1;
	var tree = nodes.map((entry, index) => {
		var result = searchTargetsAndSources(links, index);
		return _objectSpread$4(_objectSpread$4(_objectSpread$4({}, entry), result), {}, {
			value: Math.max(getSumOfIds(links, result.sourceLinks), getSumOfIds(links, result.targetLinks)),
			depth: 0
		});
	});
	for (var i = 0, len = tree.length; i < len; i++) {
		var node = tree[i];
		if (!node.sourceNodes.length) updateDepthOfTargets(tree, node);
	}
	var maxDepth = (_maxBy$depth = (_maxBy = (0, import_maxBy.default)(tree, (entry) => entry.depth)) === null || _maxBy === void 0 ? void 0 : _maxBy.depth) !== null && _maxBy$depth !== void 0 ? _maxBy$depth : 0;
	if (maxDepth >= 1) {
		var childWidth = (width - nodeWidth) / maxDepth;
		for (var _i = 0, _len = tree.length; _i < _len; _i++) {
			var _node = tree[_i];
			if (!_node.targetNodes.length) _node.depth = maxDepth;
			_node.x = _node.depth * childWidth;
			_node.dx = nodeWidth;
		}
	}
	return {
		tree,
		maxDepth
	};
};
var getDepthTree = (tree) => {
	var result = [];
	for (var i = 0, len = tree.length; i < len; i++) {
		var node = tree[i];
		if (!result[node.depth]) result[node.depth] = [];
		result[node.depth].push(node);
	}
	return result;
};
var updateYOfTree = (depthTree, height, nodePadding, links) => {
	var yRatio = Math.min(...depthTree.map((nodes) => (height - (nodes.length - 1) * nodePadding) / (0, import_sumBy.default)(nodes, getValue)));
	for (var d = 0, maxDepth = depthTree.length; d < maxDepth; d++) for (var i = 0, len = depthTree[d].length; i < len; i++) {
		var node = depthTree[d][i];
		node.y = i;
		node.dy = node.value * yRatio;
	}
	return links.map((link) => _objectSpread$4(_objectSpread$4({}, link), {}, { dy: getValue(link) * yRatio }));
};
var resolveCollisions = function resolveCollisions$1(depthTree, height, nodePadding) {
	var sort = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
	for (var i = 0, len = depthTree.length; i < len; i++) {
		var nodes = depthTree[i];
		var n = nodes.length;
		if (sort) nodes.sort(ascendingY);
		var y0 = 0;
		for (var j = 0; j < n; j++) {
			var node = nodes[j];
			var dy = y0 - node.y;
			if (dy > 0) node.y += dy;
			y0 = node.y + node.dy + nodePadding;
		}
		y0 = height + nodePadding;
		for (var _j = n - 1; _j >= 0; _j--) {
			var _node2 = nodes[_j];
			var _dy = _node2.y + _node2.dy + nodePadding - y0;
			if (_dy > 0) {
				_node2.y -= _dy;
				y0 = _node2.y;
			} else break;
		}
	}
};
var relaxLeftToRight = (tree, depthTree, links, alpha$1) => {
	for (var i = 0, maxDepth = depthTree.length; i < maxDepth; i++) {
		var nodes = depthTree[i];
		for (var j = 0, len = nodes.length; j < len; j++) {
			var node = nodes[j];
			if (node.sourceLinks.length) {
				var sourceSum = getSumOfIds(links, node.sourceLinks);
				var y$1 = getSumWithWeightedSource(tree, links, node.sourceLinks) / sourceSum;
				node.y += (y$1 - centerY(node)) * alpha$1;
			}
		}
	}
};
var relaxRightToLeft = (tree, depthTree, links, alpha$1) => {
	for (var i = depthTree.length - 1; i >= 0; i--) {
		var nodes = depthTree[i];
		for (var j = 0, len = nodes.length; j < len; j++) {
			var node = nodes[j];
			if (node.targetLinks.length) {
				var targetSum = getSumOfIds(links, node.targetLinks);
				var y$1 = getSumWithWeightedTarget(tree, links, node.targetLinks) / targetSum;
				node.y += (y$1 - centerY(node)) * alpha$1;
			}
		}
	}
};
var updateYOfLinks = (tree, links) => {
	for (var i = 0, len = tree.length; i < len; i++) {
		var node = tree[i];
		var sy = 0;
		var ty = 0;
		node.targetLinks.sort((a$1, b) => tree[links[a$1].target].y - tree[links[b].target].y);
		node.sourceLinks.sort((a$1, b) => tree[links[a$1].source].y - tree[links[b].source].y);
		for (var j = 0, tLen = node.targetLinks.length; j < tLen; j++) {
			var link = links[node.targetLinks[j]];
			if (link) {
				link.sy = sy;
				sy += link.dy;
			}
		}
		for (var _j2 = 0, sLen = node.sourceLinks.length; _j2 < sLen; _j2++) {
			var _link = links[node.sourceLinks[_j2]];
			if (_link) {
				_link.ty = ty;
				ty += _link.dy;
			}
		}
	}
};
var computeData = (_ref2) => {
	var { data, width, height, iterations, nodeWidth, nodePadding, sort } = _ref2;
	var { links } = data;
	var { tree } = getNodesTree(data, width, nodeWidth);
	var depthTree = getDepthTree(tree);
	var linksWithDy = updateYOfTree(depthTree, height, nodePadding, links);
	resolveCollisions(depthTree, height, nodePadding, sort);
	var alpha$1 = 1;
	for (var i = 1; i <= iterations; i++) {
		relaxRightToLeft(tree, depthTree, linksWithDy, alpha$1 *= .99);
		resolveCollisions(depthTree, height, nodePadding, sort);
		relaxLeftToRight(tree, depthTree, linksWithDy, alpha$1);
		resolveCollisions(depthTree, height, nodePadding, sort);
	}
	updateYOfLinks(tree, linksWithDy);
	return {
		nodes: tree,
		links: linksWithDy
	};
};
var getNodeCoordinateOfTooltip = (item) => {
	return {
		x: +item.x + +item.width / 2,
		y: +item.y + +item.height / 2
	};
};
var getLinkCoordinateOfTooltip = (item) => {
	return "sourceX" in item ? {
		x: (item.sourceX + item.targetX) / 2,
		y: (item.sourceY + item.targetY) / 2
	} : void 0;
};
var getPayloadOfTooltip = (item, type, nameKey) => {
	var { payload } = item;
	if (type === "node") return {
		payload,
		name: getValueByDataKey(payload, nameKey, ""),
		value: getValueByDataKey(payload, "value")
	};
	if ("source" in payload && payload.source && payload.target) {
		var sourceName = getValueByDataKey(payload.source, nameKey, "");
		var targetName = getValueByDataKey(payload.target, nameKey, "");
		return {
			payload,
			name: "".concat(sourceName, " - ").concat(targetName),
			value: getValueByDataKey(payload, "value")
		};
	}
};
var sankeyPayloadSearcher = (_, activeIndex, computedData, nameKey) => {
	if (activeIndex == null || typeof activeIndex !== "string") return;
	var [targetType, index] = activeIndex.split("-");
	var item = (0, import_get$1.default)(computedData, "".concat(targetType, "s[").concat(index, "]"));
	if (item) return getPayloadOfTooltip(item, targetType, nameKey);
};
var options = {
	chartName: "Sankey",
	defaultTooltipEventType: "item",
	validateTooltipEventTypes: ["item"],
	tooltipPayloadSearcher: sankeyPayloadSearcher,
	eventEmitter: void 0
};
function getTooltipEntrySettings$2(props) {
	var { dataKey, nameKey, stroke, strokeWidth, fill, name, data } = props;
	return {
		dataDefinedOnItem: data,
		positions: void 0,
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			name,
			nameKey,
			color: fill,
			unit: ""
		}
	};
}
var defaultSankeyMargin = {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0
};
function renderLinkItem(option, props) {
	if (/* @__PURE__ */ import_react.isValidElement(option)) return /* @__PURE__ */ import_react.cloneElement(option, props);
	if (typeof option === "function") return option(props);
	var { sourceX, sourceY, sourceControlX, targetX, targetY, targetControlX, linkWidth } = props, others = _objectWithoutProperties$1(props, _excluded$1);
	return /* @__PURE__ */ import_react.createElement("path", _extends$3({
		className: "recharts-sankey-link",
		d: "\n          M".concat(sourceX, ",").concat(sourceY, "\n          C").concat(sourceControlX, ",").concat(sourceY, " ").concat(targetControlX, ",").concat(targetY, " ").concat(targetX, ",").concat(targetY, "\n        "),
		fill: "none",
		stroke: "#333",
		strokeWidth: linkWidth,
		strokeOpacity: "0.2"
	}, svgPropertiesNoEvents(others)));
}
var buildLinkProps = (_ref3) => {
	var { link, nodes, left, top, i, linkContent, linkCurvature } = _ref3;
	var { sy: sourceRelativeY, ty: targetRelativeY, dy: linkWidth } = link;
	var sourceNode = nodes[link.source];
	var targetNode = nodes[link.target];
	var sourceX = sourceNode.x + sourceNode.dx + left;
	var targetX = targetNode.x + left;
	var interpolationFunc = interpolationGenerator(sourceX, targetX);
	var sourceControlX = interpolationFunc(linkCurvature);
	var targetControlX = interpolationFunc(1 - linkCurvature);
	var sourceY = sourceNode.y + sourceRelativeY + linkWidth / 2 + top;
	var targetY = targetNode.y + targetRelativeY + linkWidth / 2 + top;
	return _objectSpread$4({
		sourceX,
		targetX,
		sourceY,
		targetY,
		sourceControlX,
		targetControlX,
		sourceRelativeY,
		targetRelativeY,
		linkWidth,
		index: i,
		payload: _objectSpread$4(_objectSpread$4({}, link), {}, {
			source: sourceNode,
			target: targetNode
		})
	}, svgPropertiesNoEventsFromUnknown(linkContent));
};
function SankeyLinkElement(_ref4) {
	var { props, i, linkContent, onMouseEnter: _onMouseEnter, onMouseLeave: _onMouseLeave, onClick: _onClick, dataKey } = _ref4;
	var activeCoordinate = getLinkCoordinateOfTooltip(props);
	var activeIndex = "link-".concat(i);
	var dispatch = useAppDispatch();
	return /* @__PURE__ */ import_react.createElement(Layer, {
		onMouseEnter: (e) => {
			dispatch(setActiveMouseOverItemIndex({
				activeIndex,
				activeDataKey: dataKey,
				activeCoordinate
			}));
			_onMouseEnter(props, e);
		},
		onMouseLeave: (e) => {
			dispatch(mouseLeaveItem());
			_onMouseLeave(props, e);
		},
		onClick: (e) => {
			dispatch(setActiveClickItemIndex({
				activeIndex,
				activeDataKey: dataKey,
				activeCoordinate
			}));
			_onClick(props, e);
		}
	}, renderLinkItem(linkContent, props));
}
function AllSankeyLinkElements(_ref5) {
	var { modifiedLinks, links, linkContent, onMouseEnter, onMouseLeave, onClick, dataKey } = _ref5;
	return /* @__PURE__ */ import_react.createElement(Layer, {
		className: "recharts-sankey-links",
		key: "recharts-sankey-links"
	}, links.map((link, i) => {
		var linkProps = modifiedLinks[i];
		return /* @__PURE__ */ import_react.createElement(SankeyLinkElement, {
			key: "link-".concat(link.source, "-").concat(link.target, "-").concat(link.value),
			props: linkProps,
			linkContent,
			i,
			onMouseEnter,
			onMouseLeave,
			onClick,
			dataKey
		});
	}));
}
function renderNodeItem(option, props) {
	if (/* @__PURE__ */ import_react.isValidElement(option)) return /* @__PURE__ */ import_react.cloneElement(option, props);
	if (typeof option === "function") return option(props);
	return /* @__PURE__ */ import_react.createElement(Rectangle, _extends$3({
		className: "recharts-sankey-node",
		fill: "#0088fe",
		fillOpacity: "0.8"
	}, svgPropertiesNoEvents(props)));
}
var buildNodeProps = (_ref6) => {
	var { node, nodeContent, top, left, i } = _ref6;
	var { x: x$1, y: y$1, dx, dy } = node;
	return _objectSpread$4(_objectSpread$4({}, svgPropertiesNoEventsFromUnknown(nodeContent)), {}, {
		x: x$1 + left,
		y: y$1 + top,
		width: dx,
		height: dy,
		index: i,
		payload: node
	});
};
function NodeElement(_ref7) {
	var { props, nodeContent, i, onMouseEnter: _onMouseEnter2, onMouseLeave: _onMouseLeave2, onClick: _onClick2, dataKey } = _ref7;
	var dispatch = useAppDispatch();
	var activeCoordinate = getNodeCoordinateOfTooltip(props);
	var activeIndex = "node-".concat(i);
	return /* @__PURE__ */ import_react.createElement(Layer, {
		onMouseEnter: (e) => {
			dispatch(setActiveMouseOverItemIndex({
				activeIndex,
				activeDataKey: dataKey,
				activeCoordinate
			}));
			_onMouseEnter2(props, e);
		},
		onMouseLeave: (e) => {
			dispatch(mouseLeaveItem());
			_onMouseLeave2(props, e);
		},
		onClick: (e) => {
			dispatch(setActiveClickItemIndex({
				activeIndex,
				activeDataKey: dataKey,
				activeCoordinate
			}));
			_onClick2(props, e);
		}
	}, renderNodeItem(nodeContent, props));
}
function AllNodeElements(_ref8) {
	var { modifiedNodes, nodeContent, onMouseEnter, onMouseLeave, onClick, dataKey } = _ref8;
	return /* @__PURE__ */ import_react.createElement(Layer, {
		className: "recharts-sankey-nodes",
		key: "recharts-sankey-nodes"
	}, modifiedNodes.map((modifiedNode, i) => {
		return /* @__PURE__ */ import_react.createElement(NodeElement, {
			key: "node-".concat(modifiedNode.index, "-").concat(modifiedNode.x, "-").concat(modifiedNode.y),
			props: modifiedNode,
			nodeContent,
			i,
			onMouseEnter,
			onMouseLeave,
			onClick,
			dataKey
		});
	}));
}
var sankeyDefaultProps = {
	nameKey: "name",
	dataKey: "value",
	nodePadding: 10,
	nodeWidth: 10,
	linkCurvature: .5,
	iterations: 32,
	margin: {
		top: 5,
		right: 5,
		bottom: 5,
		left: 5
	},
	sort: true
};
function SankeyImpl(props) {
	var { className, style, children } = props, others = _objectWithoutProperties$1(props, _excluded2$1);
	var { link, dataKey, node, onMouseEnter, onMouseLeave, onClick, data, iterations, nodeWidth, nodePadding, sort, linkCurvature, margin } = props;
	var attrs = svgPropertiesNoEvents(others);
	var width = useChartWidth();
	var height = useChartHeight();
	var { links, modifiedLinks, modifiedNodes } = (0, import_react.useMemo)(() => {
		var _margin$left, _margin$right, _margin$top, _margin$bottom;
		if (!data || !width || !height || width <= 0 || height <= 0) return {
			nodes: [],
			links: [],
			modifiedLinks: [],
			modifiedNodes: []
		};
		var contentWidth = width - ((_margin$left = margin.left) !== null && _margin$left !== void 0 ? _margin$left : 0) - ((_margin$right = margin.right) !== null && _margin$right !== void 0 ? _margin$right : 0);
		var contentHeight = height - ((_margin$top = margin.top) !== null && _margin$top !== void 0 ? _margin$top : 0) - ((_margin$bottom = margin.bottom) !== null && _margin$bottom !== void 0 ? _margin$bottom : 0);
		var computed = computeData({
			data,
			width: contentWidth,
			height: contentHeight,
			iterations,
			nodeWidth,
			nodePadding,
			sort
		});
		var top = margin.top || 0;
		var left = margin.left || 0;
		var newModifiedLinks = computed.links.map((l, i) => {
			return buildLinkProps({
				link: l,
				nodes: computed.nodes,
				i,
				top,
				left,
				linkContent: link,
				linkCurvature
			});
		});
		var newModifiedNodes = computed.nodes.map((n, i) => {
			return buildNodeProps({
				node: n,
				nodeContent: node,
				i,
				top,
				left
			});
		});
		return {
			nodes: computed.nodes,
			links: computed.links,
			modifiedLinks: newModifiedLinks,
			modifiedNodes: newModifiedNodes
		};
	}, [
		data,
		width,
		height,
		margin,
		iterations,
		nodeWidth,
		nodePadding,
		sort,
		link,
		node,
		linkCurvature
	]);
	var handleMouseEnter = (0, import_react.useCallback)((item, type, e) => {
		if (onMouseEnter) onMouseEnter(item, type, e);
	}, [onMouseEnter]);
	var handleMouseLeave = (0, import_react.useCallback)((item, type, e) => {
		if (onMouseLeave) onMouseLeave(item, type, e);
	}, [onMouseLeave]);
	var handleClick = (0, import_react.useCallback)((item, type, e) => {
		if (onClick) onClick(item, type, e);
	}, [onClick]);
	if (!isPositiveNumber(width) || !isPositiveNumber(height) || !data || !data.links || !data.nodes) return null;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetComputedData, { computedData: {
		links: modifiedLinks,
		nodes: modifiedNodes
	} }), /* @__PURE__ */ import_react.createElement(Surface, _extends$3({}, attrs, {
		width,
		height
	}), children, /* @__PURE__ */ import_react.createElement(AllSankeyLinkElements, {
		links,
		modifiedLinks,
		linkContent: link,
		dataKey,
		onMouseEnter: (linkProps, e) => handleMouseEnter(linkProps, "link", e),
		onMouseLeave: (linkProps, e) => handleMouseLeave(linkProps, "link", e),
		onClick: (linkProps, e) => handleClick(linkProps, "link", e)
	}), /* @__PURE__ */ import_react.createElement(AllNodeElements, {
		modifiedNodes,
		nodeContent: node,
		dataKey,
		onMouseEnter: (nodeProps, e) => handleMouseEnter(nodeProps, "node", e),
		onMouseLeave: (nodeProps, e) => handleMouseLeave(nodeProps, "node", e),
		onClick: (nodeProps, e) => handleClick(nodeProps, "node", e)
	})));
}
function Sankey(outsideProps) {
	var props = resolveDefaultProps(outsideProps, sankeyDefaultProps);
	var { width, height, style, className } = props;
	var [tooltipPortal, setTooltipPortal] = (0, import_react.useState)(null);
	return /* @__PURE__ */ import_react.createElement(RechartsStoreProvider, {
		preloadedState: { options },
		reduxStoreName: className !== null && className !== void 0 ? className : "Sankey"
	}, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$2,
		args: props
	}), /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width,
		height
	}), /* @__PURE__ */ import_react.createElement(ReportChartMargin, { margin: defaultSankeyMargin }), /* @__PURE__ */ import_react.createElement(RechartsWrapper, {
		className,
		style,
		width,
		height,
		responsive: false,
		ref: (node) => {
			if (node && !tooltipPortal) setTooltipPortal(node);
		},
		onMouseEnter: void 0,
		onMouseLeave: void 0,
		onClick: void 0,
		onMouseMove: void 0,
		onMouseDown: void 0,
		onMouseUp: void 0,
		onContextMenu: void 0,
		onDoubleClick: void 0,
		onTouchStart: void 0,
		onTouchMove: void 0,
		onTouchEnd: void 0
	}, /* @__PURE__ */ import_react.createElement(TooltipPortalContext.Provider, { value: tooltipPortal }, /* @__PURE__ */ import_react.createElement(SankeyImpl, props))));
}
Sankey.displayName = "Sankey";

//#endregion
//#region node_modules/recharts/es6/chart/RadarChart.js
var allowedTooltipTypes$5 = ["axis"];
var defaultProps$1 = {
	layout: "centric",
	startAngle: 90,
	endAngle: -270,
	cx: "50%",
	cy: "50%",
	innerRadius: 0,
	outerRadius: "80%"
};
var RadarChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var propsWithDefaults = resolveDefaultProps(props, defaultProps$1);
	return /* @__PURE__ */ import_react.createElement(PolarChart, {
		chartName: "RadarChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$5,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: propsWithDefaults,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/ScatterChart.js
var allowedTooltipTypes$4 = ["item"];
var ScatterChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "ScatterChart",
		defaultTooltipEventType: "item",
		validateTooltipEventTypes: allowedTooltipTypes$4,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/AreaChart.js
var allowedTooltipTypes$3 = ["axis"];
var AreaChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "AreaChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$3,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/RadialBarChart.js
var allowedTooltipTypes$2 = ["axis", "item"];
var defaultProps = {
	layout: "radial",
	startAngle: 0,
	endAngle: 360,
	cx: "50%",
	cy: "50%",
	innerRadius: 0,
	outerRadius: "80%"
};
var RadialBarChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	var propsWithDefaults = resolveDefaultProps(props, defaultProps);
	return /* @__PURE__ */ import_react.createElement(PolarChart, {
		chartName: "RadialBarChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$2,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: propsWithDefaults,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/ComposedChart.js
var allowedTooltipTypes$1 = ["axis"];
var ComposedChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "ComposedChart",
		defaultTooltipEventType: "axis",
		validateTooltipEventTypes: allowedTooltipTypes$1,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
//#region node_modules/recharts/es6/chart/SunburstChart.js
var import_get = /* @__PURE__ */ __toESM(require_get());
function _extends$2() {
	return _extends$2 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$2.apply(null, arguments);
}
function ownKeys$3(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$3(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$3(Object(t), !0).forEach(function(r$2) {
			_defineProperty$3(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$3(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$3(e, r$1, t) {
	return (r$1 = _toPropertyKey$3(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$3(t) {
	var i = _toPrimitive$3(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$3(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var defaultTextProps = {
	fontWeight: "bold",
	paintOrder: "stroke fill",
	fontSize: ".75rem",
	stroke: "#FFF",
	fill: "black",
	pointerEvents: "none"
};
function getMaxDepthOf(node) {
	if (!node.children || node.children.length === 0) return 1;
	var childDepths = node.children.map((d) => getMaxDepthOf(d));
	return 1 + Math.max(...childDepths);
}
function convertMapToRecord(map$2) {
	var record = {};
	map$2.forEach((value, key) => {
		record[key] = value;
	});
	return record;
}
function getTooltipEntrySettings$1(_ref$1) {
	var { dataKey, nameKey, data, stroke, fill, positions } = _ref$1;
	return {
		dataDefinedOnItem: data.children,
		positions: convertMapToRecord(positions),
		settings: {
			stroke,
			strokeWidth: void 0,
			fill,
			nameKey,
			dataKey,
			name: nameKey ? void 0 : dataKey,
			hide: false,
			type: void 0,
			color: fill,
			unit: ""
		}
	};
}
var defaultSunburstMargin = {
	top: 0,
	right: 0,
	bottom: 0,
	left: 0
};
var payloadSearcher = (data, activeIndex) => {
	return (0, import_get.default)(data, activeIndex);
};
var addToSunburstNodeIndex = function addToSunburstNodeIndex$1(indexInChildrenArr) {
	var activeTooltipIndexSoFar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
	return "".concat(activeTooltipIndexSoFar, "children[").concat(indexInChildrenArr, "]");
};
var preloadedState = { options: {
	validateTooltipEventTypes: ["item"],
	defaultTooltipEventType: "item",
	chartName: "Sunburst",
	tooltipPayloadSearcher: payloadSearcher,
	eventEmitter: void 0
} };
var SunburstChartImpl = (_ref2) => {
	var { className, data, children, padding = 2, dataKey = "value", nameKey = "name", ringPadding = 2, innerRadius = 50, fill = "#333", stroke = "#FFF", textOptions = defaultTextProps, outerRadius: outerRadiusFromProps, cx: cxFromProps, cy: cyFromProps, startAngle = 0, endAngle = 360, onClick, onMouseEnter, onMouseLeave, responsive = false, style } = _ref2;
	var dispatch = useAppDispatch();
	var width = useChartWidth();
	var height = useChartHeight();
	var outerRadius = outerRadiusFromProps !== null && outerRadiusFromProps !== void 0 ? outerRadiusFromProps : Math.min(width, height) / 2;
	var cx = cxFromProps !== null && cxFromProps !== void 0 ? cxFromProps : width / 2;
	var cy = cyFromProps !== null && cyFromProps !== void 0 ? cyFromProps : height / 2;
	var rScale = linear([0, data[dataKey]], [0, endAngle]);
	var treeDepth = getMaxDepthOf(data);
	var thickness = (outerRadius - innerRadius) / treeDepth;
	var sectors = [];
	var positions = /* @__PURE__ */ new Map([]);
	var [tooltipPortal, setTooltipPortal] = (0, import_react.useState)(null);
	function handleMouseEnter(node, e) {
		if (onMouseEnter) onMouseEnter(node, e);
		dispatch(setActiveMouseOverItemIndex({
			activeIndex: node.tooltipIndex,
			activeDataKey: dataKey,
			activeCoordinate: positions.get(node.name)
		}));
	}
	function handleMouseLeave(node, e) {
		if (onMouseLeave) onMouseLeave(node, e);
		dispatch(mouseLeaveItem());
	}
	function handleClick(node) {
		if (onClick) onClick(node);
		dispatch(setActiveClickItemIndex({
			activeIndex: node.tooltipIndex,
			activeDataKey: dataKey,
			activeCoordinate: positions.get(node.name)
		}));
	}
	function drawArcs(childNodes, options$2) {
		var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
		var { radius, innerR, initialAngle, childColor, nestedActiveTooltipIndex } = options$2;
		var currentAngle = initialAngle;
		if (!childNodes) return;
		childNodes.forEach((d, i) => {
			var _ref3, _d$fill;
			var currentTooltipIndex = depth === 1 ? "[".concat(i, "]") : addToSunburstNodeIndex(i, nestedActiveTooltipIndex);
			var nodeWithIndex = _objectSpread$3(_objectSpread$3({}, d), {}, { tooltipIndex: currentTooltipIndex });
			var arcLength = rScale(d[dataKey]);
			var start = currentAngle;
			var fillColor = (_ref3 = (_d$fill = d === null || d === void 0 ? void 0 : d.fill) !== null && _d$fill !== void 0 ? _d$fill : childColor) !== null && _ref3 !== void 0 ? _ref3 : fill;
			var { x: textX, y: textY } = polarToCartesian(0, 0, innerR + radius / 2, -(start + arcLength - arcLength / 2));
			currentAngle += arcLength;
			sectors.push(/* @__PURE__ */ import_react.createElement("g", { key: "sunburst-sector-".concat(d.name, "-").concat(i) }, /* @__PURE__ */ import_react.createElement(Sector, {
				onClick: () => handleClick(nodeWithIndex),
				onMouseEnter: (e) => handleMouseEnter(nodeWithIndex, e),
				onMouseLeave: (e) => handleMouseLeave(nodeWithIndex, e),
				fill: fillColor,
				stroke,
				strokeWidth: padding,
				startAngle: start,
				endAngle: start + arcLength,
				innerRadius: innerR,
				outerRadius: innerR + radius,
				cx,
				cy
			}), /* @__PURE__ */ import_react.createElement(Text, _extends$2({}, textOptions, {
				alignmentBaseline: "middle",
				textAnchor: "middle",
				x: textX + cx,
				y: cy - textY
			}), d[dataKey])));
			var { x: tooltipX, y: tooltipY } = polarToCartesian(cx, cy, innerR + radius / 2, start);
			positions.set(d.name, {
				x: tooltipX,
				y: tooltipY
			});
			return drawArcs(d.children, {
				radius,
				innerR: innerR + radius + ringPadding,
				initialAngle: start,
				childColor: fillColor,
				nestedActiveTooltipIndex: currentTooltipIndex
			}, depth + 1);
		});
	}
	drawArcs(data.children, {
		radius: thickness,
		innerR: innerRadius,
		initialAngle: startAngle
	});
	var layerClass = clsx("recharts-sunburst", className);
	return /* @__PURE__ */ import_react.createElement(TooltipPortalContext.Provider, { value: tooltipPortal }, /* @__PURE__ */ import_react.createElement(RechartsWrapper, {
		className,
		width,
		height,
		responsive,
		style,
		ref: (node) => {
			if (tooltipPortal == null && node != null) setTooltipPortal(node);
		},
		onMouseEnter: void 0,
		onMouseLeave: void 0,
		onClick: void 0,
		onMouseMove: void 0,
		onMouseDown: void 0,
		onMouseUp: void 0,
		onContextMenu: void 0,
		onDoubleClick: void 0,
		onTouchStart: void 0,
		onTouchMove: void 0,
		onTouchEnd: void 0
	}, /* @__PURE__ */ import_react.createElement(Surface, {
		width,
		height
	}, /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, sectors), /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings$1,
		args: {
			dataKey,
			data,
			stroke,
			fill,
			nameKey,
			positions
		}
	}), children)));
};
var SunburstChart = (props) => {
	var _props$className;
	return /* @__PURE__ */ import_react.createElement(RechartsStoreProvider, {
		preloadedState,
		reduxStoreName: (_props$className = props.className) !== null && _props$className !== void 0 ? _props$className : "SunburstChart"
	}, /* @__PURE__ */ import_react.createElement(ReportChartSize, {
		width: props.width,
		height: props.height
	}), /* @__PURE__ */ import_react.createElement(ReportChartMargin, { margin: defaultSunburstMargin }), /* @__PURE__ */ import_react.createElement(SunburstChartImpl, props));
};

//#endregion
//#region node_modules/recharts/es6/util/FunnelUtils.js
function _extends$1() {
	return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends$1.apply(null, arguments);
}
function ownKeys$2(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$2(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$2(Object(t), !0).forEach(function(r$2) {
			_defineProperty$2(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$2(e, r$1, t) {
	return (r$1 = _toPropertyKey$2(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$2(t) {
	var i = _toPrimitive$2(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$2(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
function typeGuardTrapezoidProps(option, props) {
	var xValue = "".concat(props.x || option.x);
	var x$1 = parseInt(xValue, 10);
	var yValue = "".concat(props.y || option.y);
	var y$1 = parseInt(yValue, 10);
	var heightValue = "".concat((props === null || props === void 0 ? void 0 : props.height) || (option === null || option === void 0 ? void 0 : option.height));
	var height = parseInt(heightValue, 10);
	return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, props), getPropsFromShapeOption(option)), {}, {
		height,
		x: x$1,
		y: y$1
	});
}
function FunnelTrapezoid(props) {
	return /* @__PURE__ */ import_react.createElement(Shape, _extends$1({
		shapeType: "trapezoid",
		propTransformer: typeGuardTrapezoidProps
	}, props));
}

//#endregion
//#region node_modules/recharts/es6/state/selectors/funnelSelectors.js
function ownKeys$1(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread$1(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys$1(Object(t), !0).forEach(function(r$2) {
			_defineProperty$1(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty$1(e, r$1, t) {
	return (r$1 = _toPropertyKey$1(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey$1(t) {
	var i = _toPrimitive$1(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive$1(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
var pickFunnelSettings = (_state, funnelSettings) => funnelSettings;
var selectFunnelTrapezoids = createSelector([
	selectChartOffsetInternal,
	pickFunnelSettings,
	selectChartDataAndAlwaysIgnoreIndexes
], (offset, _ref$1, _ref2) => {
	var { data, dataKey, nameKey, tooltipType, lastShapeType, reversed, customWidth, cells, presentationProps } = _ref$1;
	var { chartData } = _ref2;
	var displayedData;
	if (data != null && data.length > 0) displayedData = data;
	else if (chartData != null && chartData.length > 0) displayedData = chartData;
	if (displayedData && displayedData.length) displayedData = displayedData.map((entry, index) => _objectSpread$1(_objectSpread$1(_objectSpread$1({ payload: entry }, presentationProps), entry), cells && cells[index] && cells[index].props));
	else if (cells && cells.length) displayedData = cells.map((cell) => _objectSpread$1(_objectSpread$1({}, presentationProps), cell.props));
	else return [];
	return computeFunnelTrapezoids({
		dataKey,
		nameKey,
		displayedData,
		tooltipType,
		lastShapeType,
		reversed,
		offset,
		customWidth
	});
});

//#endregion
//#region node_modules/recharts/es6/cartesian/Funnel.js
var import_omit = /* @__PURE__ */ __toESM(require_omit());
var _excluded = [
	"onMouseEnter",
	"onClick",
	"onMouseLeave",
	"shape",
	"activeShape"
], _excluded2 = [
	"stroke",
	"fill",
	"legendType",
	"hide",
	"isAnimationActive",
	"animationBegin",
	"animationDuration",
	"animationEasing",
	"nameKey",
	"lastShapeType"
];
function _extends() {
	return _extends = Object.assign ? Object.assign.bind() : function(n) {
		for (var e = 1; e < arguments.length; e++) {
			var t = arguments[e];
			for (var r$1 in t) ({}).hasOwnProperty.call(t, r$1) && (n[r$1] = t[r$1]);
		}
		return n;
	}, _extends.apply(null, arguments);
}
function _objectWithoutProperties(e, t) {
	if (null == e) return {};
	var o, r$1, i = _objectWithoutPropertiesLoose(e, t);
	if (Object.getOwnPropertySymbols) {
		var n = Object.getOwnPropertySymbols(e);
		for (r$1 = 0; r$1 < n.length; r$1++) o = n[r$1], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
	}
	return i;
}
function _objectWithoutPropertiesLoose(r$1, e) {
	if (null == r$1) return {};
	var t = {};
	for (var n in r$1) if ({}.hasOwnProperty.call(r$1, n)) {
		if (-1 !== e.indexOf(n)) continue;
		t[n] = r$1[n];
	}
	return t;
}
function ownKeys(e, r$1) {
	var t = Object.keys(e);
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(e);
		r$1 && (o = o.filter(function(r$2) {
			return Object.getOwnPropertyDescriptor(e, r$2).enumerable;
		})), t.push.apply(t, o);
	}
	return t;
}
function _objectSpread(e) {
	for (var r$1 = 1; r$1 < arguments.length; r$1++) {
		var t = null != arguments[r$1] ? arguments[r$1] : {};
		r$1 % 2 ? ownKeys(Object(t), !0).forEach(function(r$2) {
			_defineProperty(e, r$2, t[r$2]);
		}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$2) {
			Object.defineProperty(e, r$2, Object.getOwnPropertyDescriptor(t, r$2));
		});
	}
	return e;
}
function _defineProperty(e, r$1, t) {
	return (r$1 = _toPropertyKey(r$1)) in e ? Object.defineProperty(e, r$1, {
		value: t,
		enumerable: !0,
		configurable: !0,
		writable: !0
	}) : e[r$1] = t, e;
}
function _toPropertyKey(t) {
	var i = _toPrimitive(t, "string");
	return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r$1) {
	if ("object" != typeof t || !t) return t;
	var e = t[Symbol.toPrimitive];
	if (void 0 !== e) {
		var i = e.call(t, r$1 || "default");
		if ("object" != typeof i) return i;
		throw new TypeError("@@toPrimitive must return a primitive value.");
	}
	return ("string" === r$1 ? String : Number)(t);
}
/**
* Internal props, combination of external props + defaultProps + private Recharts state
*/
/**
* External props, intended for end users to fill in
*/
function getTooltipEntrySettings(props) {
	var { dataKey, nameKey, stroke, strokeWidth, fill, name, hide, tooltipType, data } = props;
	return {
		dataDefinedOnItem: data,
		positions: props.trapezoids.map((_ref$1) => {
			var { tooltipPosition } = _ref$1;
			return tooltipPosition;
		}),
		settings: {
			stroke,
			strokeWidth,
			fill,
			dataKey,
			name,
			nameKey,
			hide,
			type: tooltipType,
			color: fill,
			unit: ""
		}
	};
}
function FunnelLabelListProvider(_ref2) {
	var { showLabels, trapezoids, children } = _ref2;
	var labelListEntries = (0, import_react.useMemo)(() => {
		if (!showLabels) return;
		return trapezoids === null || trapezoids === void 0 ? void 0 : trapezoids.map((entry) => {
			var viewBox = {
				x: entry.x,
				y: entry.y,
				width: entry.upperWidth,
				height: entry.height
			};
			return _objectSpread(_objectSpread({}, viewBox), {}, {
				value: entry.name,
				payload: entry.payload,
				parentViewBox: void 0,
				viewBox,
				fill: entry.fill
			});
		});
	}, [showLabels, trapezoids]);
	return /* @__PURE__ */ import_react.createElement(CartesianLabelListContextProvider, { value: labelListEntries }, children);
}
function FunnelTrapezoids(props) {
	var { trapezoids, allOtherFunnelProps } = props;
	var activeItemIndex = useAppSelector((state) => selectActiveIndex(state, "item", state.tooltip.settings.trigger, void 0));
	var { onMouseEnter: onMouseEnterFromProps, onClick: onItemClickFromProps, onMouseLeave: onMouseLeaveFromProps, shape, activeShape } = allOtherFunnelProps, restOfAllOtherProps = _objectWithoutProperties(allOtherFunnelProps, _excluded);
	var onMouseEnterFromContext = useMouseEnterItemDispatch(onMouseEnterFromProps, allOtherFunnelProps.dataKey);
	var onMouseLeaveFromContext = useMouseLeaveItemDispatch(onMouseLeaveFromProps);
	var onClickFromContext = useMouseClickItemDispatch(onItemClickFromProps, allOtherFunnelProps.dataKey);
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, trapezoids.map((entry, i) => {
		var isActiveIndex = Boolean(activeShape) && activeItemIndex === String(i);
		var trapezoidOptions = isActiveIndex ? activeShape : shape;
		var trapezoidProps = _objectSpread(_objectSpread({}, entry), {}, {
			option: trapezoidOptions,
			isActive: isActiveIndex,
			stroke: entry.stroke
		});
		return /* @__PURE__ */ import_react.createElement(Layer, _extends({
			key: "trapezoid-".concat(entry === null || entry === void 0 ? void 0 : entry.x, "-").concat(entry === null || entry === void 0 ? void 0 : entry.y, "-").concat(entry === null || entry === void 0 ? void 0 : entry.name, "-").concat(entry === null || entry === void 0 ? void 0 : entry.value),
			className: "recharts-funnel-trapezoid"
		}, adaptEventsOfChild(restOfAllOtherProps, entry, i), {
			onMouseEnter: onMouseEnterFromContext(entry, i),
			onMouseLeave: onMouseLeaveFromContext(entry, i),
			onClick: onClickFromContext(entry, i)
		}), /* @__PURE__ */ import_react.createElement(FunnelTrapezoid, trapezoidProps));
	}));
}
function TrapezoidsWithAnimation(_ref3) {
	var { previousTrapezoidsRef, props } = _ref3;
	var { trapezoids, isAnimationActive, animationBegin, animationDuration, animationEasing, onAnimationEnd, onAnimationStart } = props;
	var prevTrapezoids = previousTrapezoidsRef.current;
	var [isAnimating, setIsAnimating] = (0, import_react.useState)(false);
	var showLabels = !isAnimating;
	var animationId = useAnimationId(trapezoids, "recharts-funnel-");
	var handleAnimationEnd = (0, import_react.useCallback)(() => {
		if (typeof onAnimationEnd === "function") onAnimationEnd();
		setIsAnimating(false);
	}, [onAnimationEnd]);
	var handleAnimationStart = (0, import_react.useCallback)(() => {
		if (typeof onAnimationStart === "function") onAnimationStart();
		setIsAnimating(true);
	}, [onAnimationStart]);
	return /* @__PURE__ */ import_react.createElement(FunnelLabelListProvider, {
		showLabels,
		trapezoids
	}, /* @__PURE__ */ import_react.createElement(JavascriptAnimate, {
		animationId,
		begin: animationBegin,
		duration: animationDuration,
		isActive: isAnimationActive,
		easing: animationEasing,
		key: animationId,
		onAnimationStart: handleAnimationStart,
		onAnimationEnd: handleAnimationEnd
	}, (t) => {
		var stepData = t === 1 ? trapezoids : trapezoids.map((entry, index) => {
			var prev = prevTrapezoids && prevTrapezoids[index];
			if (prev) return _objectSpread(_objectSpread({}, entry), {}, {
				x: interpolate(prev.x, entry.x, t),
				y: interpolate(prev.y, entry.y, t),
				upperWidth: interpolate(prev.upperWidth, entry.upperWidth, t),
				lowerWidth: interpolate(prev.lowerWidth, entry.lowerWidth, t),
				height: interpolate(prev.height, entry.height, t)
			});
			return _objectSpread(_objectSpread({}, entry), {}, {
				x: interpolate(entry.x + entry.upperWidth / 2, entry.x, t),
				y: interpolate(entry.y + entry.height / 2, entry.y, t),
				upperWidth: interpolate(0, entry.upperWidth, t),
				lowerWidth: interpolate(0, entry.lowerWidth, t),
				height: interpolate(0, entry.height, t)
			});
		});
		if (t > 0) previousTrapezoidsRef.current = stepData;
		return /* @__PURE__ */ import_react.createElement(Layer, null, /* @__PURE__ */ import_react.createElement(FunnelTrapezoids, {
			trapezoids: stepData,
			allOtherFunnelProps: props
		}));
	}), /* @__PURE__ */ import_react.createElement(LabelListFromLabelProp, { label: props.label }), props.children);
}
function RenderTrapezoids(props) {
	var previousTrapezoidsRef = (0, import_react.useRef)(void 0);
	return /* @__PURE__ */ import_react.createElement(TrapezoidsWithAnimation, {
		props,
		previousTrapezoidsRef
	});
}
var getRealWidthHeight = (customWidth, offset) => {
	var { width, height, left, right, top, bottom } = offset;
	var realHeight = height;
	var realWidth = width;
	if (isNumber(customWidth)) realWidth = customWidth;
	else if (typeof customWidth === "string") realWidth = realWidth * parseFloat(customWidth) / 100;
	return {
		realWidth: realWidth - left - right - 50,
		realHeight: realHeight - bottom - top,
		offsetX: (width - realWidth) / 2,
		offsetY: (height - realHeight) / 2
	};
};
var FunnelWithState = class extends import_react.PureComponent {
	render() {
		var { className } = this.props;
		var layerClass = clsx("recharts-trapezoids", className);
		return /* @__PURE__ */ import_react.createElement(Layer, { className: layerClass }, /* @__PURE__ */ import_react.createElement(RenderTrapezoids, this.props));
	}
};
var defaultFunnelProps = {
	stroke: "#fff",
	fill: "#808080",
	legendType: "rect",
	hide: false,
	isAnimationActive: !Global.isSsr,
	animationBegin: 400,
	animationDuration: 1500,
	animationEasing: "ease",
	nameKey: "name",
	lastShapeType: "triangle"
};
function FunnelImpl(props) {
	var plotArea = usePlotArea();
	var _resolveDefaultProps = resolveDefaultProps(props, defaultFunnelProps), { stroke, fill, legendType, hide, isAnimationActive, animationBegin, animationDuration, animationEasing, nameKey, lastShapeType } = _resolveDefaultProps, everythingElse = _objectWithoutProperties(_resolveDefaultProps, _excluded2);
	var presentationProps = svgPropertiesNoEvents(props);
	var cells = findAllByType(props.children, Cell);
	var funnelSettings = (0, import_react.useMemo)(() => ({
		dataKey: props.dataKey,
		nameKey,
		data: props.data,
		tooltipType: props.tooltipType,
		lastShapeType,
		reversed: props.reversed,
		customWidth: props.width,
		cells,
		presentationProps
	}), [
		props.dataKey,
		nameKey,
		props.data,
		props.tooltipType,
		lastShapeType,
		props.reversed,
		props.width,
		cells,
		presentationProps
	]);
	var trapezoids = useAppSelector((state) => selectFunnelTrapezoids(state, funnelSettings));
	if (hide || !trapezoids || !trapezoids.length || !plotArea) return null;
	var { height, width } = plotArea;
	return /* @__PURE__ */ import_react.createElement(import_react.Fragment, null, /* @__PURE__ */ import_react.createElement(SetTooltipEntrySettings, {
		fn: getTooltipEntrySettings,
		args: _objectSpread(_objectSpread({}, props), {}, { trapezoids })
	}), /* @__PURE__ */ import_react.createElement(FunnelWithState, _extends({}, everythingElse, {
		stroke,
		fill,
		nameKey,
		lastShapeType,
		animationBegin,
		animationDuration,
		animationEasing,
		isAnimationActive,
		hide,
		legendType,
		height,
		width,
		trapezoids
	})));
}
function computeFunnelTrapezoids(_ref4) {
	var { dataKey, nameKey, displayedData, tooltipType, lastShapeType, reversed, offset, customWidth } = _ref4;
	var { left, top } = offset;
	var { realHeight, realWidth, offsetX, offsetY } = getRealWidthHeight(customWidth, offset);
	var maxValue = Math.max.apply(null, displayedData.map((entry) => getValueByDataKey(entry, dataKey, 0)));
	var len = displayedData.length;
	var rowHeight = realHeight / len;
	var parentViewBox = {
		x: offset.left,
		y: offset.top,
		width: offset.width,
		height: offset.height
	};
	var trapezoids = displayedData.map((entry, i) => {
		var rawVal = getValueByDataKey(entry, dataKey, 0);
		var name = getValueByDataKey(entry, nameKey, i);
		var val = rawVal;
		var nextVal;
		if (i !== len - 1) {
			nextVal = getValueByDataKey(displayedData[i + 1], dataKey, 0);
			if (nextVal instanceof Array) [nextVal] = nextVal;
		} else if (rawVal instanceof Array && rawVal.length === 2) [val, nextVal] = rawVal;
		else if (lastShapeType === "rectangle") nextVal = val;
		else nextVal = 0;
		var x$1 = (maxValue - val) * realWidth / (2 * maxValue) + top + 25 + offsetX;
		var y$1 = rowHeight * i + left + offsetY;
		var upperWidth = val / maxValue * realWidth;
		var lowerWidth = nextVal / maxValue * realWidth;
		var tooltipPayload = [{
			name,
			value: val,
			payload: entry,
			dataKey,
			type: tooltipType
		}];
		var tooltipPosition = {
			x: x$1 + upperWidth / 2,
			y: y$1 + rowHeight / 2
		};
		return _objectSpread(_objectSpread({
			x: x$1,
			y: y$1,
			width: Math.max(upperWidth, lowerWidth),
			upperWidth,
			lowerWidth,
			height: rowHeight,
			name,
			val,
			tooltipPayload,
			tooltipPosition
		}, (0, import_omit.default)(entry, ["width"])), {}, {
			payload: entry,
			parentViewBox,
			labelViewBox: {
				x: x$1 + (upperWidth - lowerWidth) / 4,
				y: y$1,
				width: Math.abs(upperWidth - lowerWidth) / 2 + Math.min(upperWidth, lowerWidth),
				height: rowHeight
			}
		});
	});
	if (reversed) trapezoids = trapezoids.map((entry, index) => {
		var newY = entry.y - index * rowHeight + (len - 1 - index) * rowHeight;
		return _objectSpread(_objectSpread({}, entry), {}, {
			upperWidth: entry.lowerWidth,
			lowerWidth: entry.upperWidth,
			x: entry.x - (entry.lowerWidth - entry.upperWidth) / 2,
			y: entry.y - index * rowHeight + (len - 1 - index) * rowHeight,
			tooltipPosition: _objectSpread(_objectSpread({}, entry.tooltipPosition), {}, { y: newY + rowHeight / 2 }),
			labelViewBox: _objectSpread(_objectSpread({}, entry.labelViewBox), {}, { y: newY })
		});
	});
	return trapezoids;
}
var Funnel = class extends import_react.PureComponent {
	render() {
		return /* @__PURE__ */ import_react.createElement(FunnelImpl, this.props);
	}
};
_defineProperty(Funnel, "displayName", "Funnel");
_defineProperty(Funnel, "defaultProps", defaultFunnelProps);

//#endregion
//#region node_modules/recharts/es6/chart/FunnelChart.js
var allowedTooltipTypes = ["item"];
var FunnelChart = /* @__PURE__ */ (0, import_react.forwardRef)((props, ref) => {
	return /* @__PURE__ */ import_react.createElement(CartesianChart, {
		chartName: "FunnelChart",
		defaultTooltipEventType: "item",
		validateTooltipEventTypes: allowedTooltipTypes,
		tooltipPayloadSearcher: arrayTooltipSearcher,
		categoricalChartProps: props,
		ref
	});
});

//#endregion
export { Area, AreaChart, Bar, BarChart, Brush, CartesianAxis, CartesianGrid, Cell, ComposedChart, Cross, Curve, Customized, DefaultLegendContent, DefaultTooltipContent, Dot, ErrorBar, Funnel, FunnelChart, Global, Label, LabelList, Layer, Legend, Line, LineChart, Pie, PieChart, PolarAngleAxis, PolarGrid, PolarRadiusAxis, Polygon, Radar, RadarChart, RadialBar, RadialBarChart, Rectangle, ReferenceArea, ReferenceDot, ReferenceLine, ResponsiveContainer, Sankey, Scatter, ScatterChart, Sector, SunburstChart, Surface, Symbols, Text, Tooltip, Trapezoid, Treemap, XAxis, YAxis, ZAxis, getNiceTickValues, useActiveTooltipDataPoints, useActiveTooltipLabel, useChartHeight, useChartWidth, useMargin, useOffset, usePlotArea, useXAxisDomain, useYAxisDomain };
//# sourceMappingURL=recharts.js.map